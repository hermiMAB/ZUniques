{
  "version": 3,
  "sources": ["../../@fluentui/set-version/lib/setVersion.ts", "../../@fluentui/set-version/lib/index.ts", "../../@fluentui/react-hooks/lib/version.ts", "../../@fluentui/utilities/lib/dom/dom/canUseDOM.ts", "../../@fluentui/utilities/lib/dom/dom/getWindow.ts", "../../@fluentui/utilities/lib/Async.ts", "../../@fluentui/dom-utilities/lib/isVirtualElement.ts", "../../@fluentui/dom-utilities/lib/getVirtualParent.ts", "../../@fluentui/dom-utilities/lib/getParent.ts", "../../@fluentui/dom-utilities/lib/elementContains.ts", "../../@fluentui/dom-utilities/lib/findElementRecursive.ts", "../../@fluentui/dom-utilities/lib/elementContainsAttribute.ts", "../../@fluentui/dom-utilities/lib/getActiveElement.ts", "../../@fluentui/dom-utilities/lib/getChildren.ts", "../../@fluentui/dom-utilities/lib/getEventTarget.ts", "../../@fluentui/dom-utilities/lib/setPortalAttribute.ts", "../../@fluentui/dom-utilities/lib/portalContainsElement.ts", "../../@fluentui/dom-utilities/lib/setVirtualParent.ts", "../../@fluentui/dom-utilities/lib/version.ts", "../../@fluentui/utilities/lib/dom/dom/getDocument.ts", "../../@fluentui/utilities/lib/focus.ts", "../../@fluentui/utilities/lib/dom/dom/getFirstVisibleElementFromSelector.ts", "../../@fluentui/utilities/lib/dom/dom/getRect.ts", "../../@fluentui/utilities/lib/dom/dom/on.ts", "../../@fluentui/utilities/lib/dom/dom/raiseClick.ts", "../../@fluentui/utilities/lib/object.ts", "../../@fluentui/utilities/lib/EventGroup.ts", "../../@fluentui/merge-styles/lib/shadowConfig.ts", "../../@fluentui/merge-styles/lib/extractStyleParts.ts", "../../@fluentui/merge-styles/lib/StyleOptionsState.ts", "../../@fluentui/merge-styles/lib/Stylesheet.ts", "../../@fluentui/merge-styles/lib/transforms/transforms/kebabRules.ts", "../../@fluentui/merge-styles/lib/getVendorSettings.ts", "../../@fluentui/merge-styles/lib/transforms/transforms/prefixRules.ts", "../../@fluentui/merge-styles/lib/transforms/transforms/provideUnits.ts", "../../@fluentui/merge-styles/lib/transforms/transforms/rtlifyRules.ts", "../../@fluentui/merge-styles/lib/tokenizeWithParentheses.ts", "../../@fluentui/merge-styles/lib/styleToClassName.ts", "../../@fluentui/merge-styles/lib/mergeStyles.ts", "../../@fluentui/merge-styles/lib/concatStyleSets.ts", "../../@fluentui/merge-styles/lib/mergeStyleSets.ts", "../../@fluentui/merge-styles/lib/concatStyleSetsWithProps.ts", "../../@fluentui/merge-styles/lib/fontFace.ts", "../../@fluentui/merge-styles/lib/keyframes.ts", "../../@fluentui/merge-styles/lib/ShadowDomStylesheet.ts", "../../@fluentui/merge-styles/lib/cloneCSSStyleSheet.ts", "../../@fluentui/merge-styles/lib/version.ts", "../../@fluentui/utilities/lib/scroll.ts", "../../@fluentui/utilities/lib/AutoScroll.ts", "../../@fluentui/utilities/lib/BaseComponent.ts", "../../@fluentui/utilities/lib/warn/warn/warn.ts", "../../@fluentui/utilities/lib/warn/warn/warnConditionallyRequiredProps.ts", "../../@fluentui/utilities/lib/warn/warn/warnMutuallyExclusive.ts", "../../@fluentui/utilities/lib/warn/warn/warnDeprecations.ts", "../../@fluentui/utilities/lib/DelayedRender.tsx", "../../@fluentui/utilities/lib/FabricPerformance.ts", "../../@fluentui/utilities/lib/GlobalSettings.ts", "../../@fluentui/utilities/lib/KeyCodes.ts", "../../@fluentui/utilities/lib/Rectangle.ts", "../../@fluentui/utilities/lib/appendFunction.ts", "../../@fluentui/utilities/lib/aria.ts", "../../@fluentui/utilities/lib/array.ts", "../../@fluentui/utilities/lib/asAsync.tsx", "../../@fluentui/utilities/lib/assertNever.ts", "../../@fluentui/utilities/lib/sessionStorage.ts", "../../@fluentui/utilities/lib/rtl.ts", "../../@fluentui/utilities/lib/classNamesFunction.ts", "../../@fluentui/utilities/lib/componentAs/componentAs/composeComponentAs.tsx", "../../@fluentui/utilities/lib/memoize.ts", "../../@fluentui/utilities/lib/controlled.ts", "../../@fluentui/utilities/lib/css.ts", "../../@fluentui/utilities/lib/customizations/customizations/Customizations.ts", "../../@fluentui/utilities/lib/customizations/customizations/Customizer.tsx", "../../@fluentui/utilities/lib/customizations/customizations/CustomizerContext.ts", "../../@fluentui/utilities/lib/customizations/customizations/mergeSettings.ts", "../../@fluentui/utilities/lib/customizations/customizations/mergeCustomizations.ts", "../../@fluentui/utilities/lib/customizations/customizations/customizable.tsx", "../../@fluentui/utilities/lib/hoistStatics.ts", "../../@fluentui/utilities/lib/shadowDom/hooks/shadowDom/hooks/useMergeStylesHooks.ts", "../../@fluentui/utilities/lib/shadowDom/contexts/shadowDom/contexts/MergeStylesDefaultContext.tsx", "../../@fluentui/utilities/lib/shadowDom/hooks/shadowDom/hooks/useMergeStylesShadowRoot.ts", "../../@fluentui/utilities/lib/shadowDom/contexts/shadowDom/contexts/MergeStylesShadowRootContext.tsx", "../../@fluentui/utilities/lib/shadowDom/contexts/shadowDom/contexts/MergeStylesShadowRootConsumer.ts", "../../@fluentui/react-window-provider/src/WindowProvider.tsx", "../../@fluentui/react-window-provider/src/version.ts", "../../@fluentui/utilities/lib/customizations/customizations/useCustomizationSettings.ts", "../../@fluentui/utilities/lib/extendComponent.ts", "../../@fluentui/utilities/lib/getId.ts", "../../@fluentui/utilities/lib/properties.ts", "../../@fluentui/utilities/lib/getNativeElementProps.ts", "../../@fluentui/utilities/lib/hoist.ts", "../../@fluentui/utilities/lib/initializeComponentRef.ts", "../../@fluentui/utilities/lib/keyboard.ts", "../../@fluentui/utilities/lib/setFocusVisibility.ts", "../../@fluentui/utilities/lib/initializeFocusRects.ts", "../../@fluentui/utilities/lib/FocusRectsProvider.tsx", "../../@fluentui/utilities/lib/useFocusRects.ts", "../../@fluentui/utilities/lib/initials.ts", "../../@fluentui/utilities/lib/localStorage.ts", "../../@fluentui/utilities/lib/language.ts", "../../@fluentui/utilities/lib/math.ts", "../../@fluentui/utilities/lib/merge.ts", "../../@fluentui/utilities/lib/mobileDetector.ts", "../../@fluentui/utilities/lib/modalize.ts", "../../@fluentui/utilities/lib/osDetector.ts", "../../@fluentui/utilities/lib/overflow.ts", "../../@fluentui/utilities/lib/renderFunction/renderFunction/composeRenderFunction.tsx", "../../@fluentui/utilities/lib/resources.ts", "../../@fluentui/utilities/lib/safeRequestAnimationFrame.ts", "../../@fluentui/utilities/lib/safeSetTimeout.ts", "../../@fluentui/utilities/lib/selection/selection/Selection.types.ts", "../../@fluentui/utilities/lib/selection/selection/Selection.ts", "../../@fluentui/utilities/lib/string.ts", "../../@fluentui/utilities/lib/styled.tsx", "../../@fluentui/utilities/lib/shadowDom/contexts/shadowDom/contexts/MergeStylesRootContext.tsx", "../../@fluentui/utilities/lib/shadowDom/hooks/shadowDom/hooks/useAdoptedStylesheet.ts", "../../@fluentui/utilities/lib/shadowDom/hooks/shadowDom/hooks/useMergeStylesRootStylesheets.ts", "../../@fluentui/utilities/lib/shadowDom/hooks/shadowDom/hooks/useShadowConfig.ts", "../../@fluentui/utilities/lib/shadowDom/hooks/shadowDom/hooks/useStyled.ts", "../../@fluentui/utilities/lib/warn/warn/warnControlledUsage.ts", "../../@fluentui/utilities/lib/ie11Detector.ts", "../../@fluentui/utilities/lib/getPropsWithDefaults.ts", "../../@fluentui/utilities/lib/dom/dom/setSSR.ts", "../../@fluentui/utilities/lib/createMergedRef.ts", "../../@fluentui/utilities/lib/useIsomorphicLayoutEffect.ts", "../../@fluentui/utilities/lib/version.ts", "../../@fluentui/react-hooks/lib/useAsync.ts", "../../@fluentui/react-hooks/lib/useBoolean.ts", "../../@fluentui/react-hooks/lib/useConst.ts", "../../@fluentui/react-hooks/lib/useConstCallback.ts", "../../@fluentui/react-hooks/lib/useControllableValue.ts", "../../@fluentui/react-hooks/lib/useEventCallback.ts", "../../@fluentui/react-hooks/lib/useForceUpdate.ts", "../../@fluentui/react-hooks/lib/useId.ts", "../../@fluentui/react-hooks/lib/useMergedRefs.ts", "../../@fluentui/react-hooks/lib/useMount.ts", "../../@fluentui/react-hooks/lib/useMountSync.ts", "../../@fluentui/react-hooks/lib/useOnEvent.ts", "../../@fluentui/react-hooks/lib/usePrevious.ts", "../../@fluentui/react-hooks/lib/useRefEffect.ts", "../../@fluentui/react-hooks/lib/useSetInterval.ts", "../../@fluentui/react-hooks/lib/useSetTimeout.ts", "../../@fluentui/react-hooks/lib/useTarget.ts", "../../@fluentui/react-hooks/lib/useUnmount.ts", "../../@fluentui/react-hooks/lib/useWarnings.ts"],
  "sourcesContent": ["// A packages cache that makes sure that we don't inject the same packageName twice in the same bundle -\n// this cache is local to the module closure inside this bundle\nconst packagesCache: { [name: string]: string } = {};\n\n// Cache access to window to avoid IE11 memory leak.\nlet _win: Window | undefined = undefined;\n\ntry {\n  _win = window;\n} catch (e) {\n  /* no-op */\n}\n\nexport function setVersion(packageName: string, packageVersion: string): void {\n  if (typeof _win !== 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const packages = ((_win as any).__packages__ = (_win as any).__packages__ || {});\n\n    // We allow either the global packages or local packages caches to invalidate so testing can\n    // just clear the global to set this state\n    if (!packages[packageName] || !packagesCache[packageName]) {\n      packagesCache[packageName] = packageVersion;\n      const versions = (packages[packageName] = packages[packageName] || []);\n      versions.push(packageVersion);\n    }\n  }\n}\n", "import { setVersion } from './setVersion';\nexport { setVersion };\n\nsetVersion('@fluentui/set-version', '6.0.0');\n", "// Do not modify this file; it is generated as part of publish.\n// The checked in version is a placeholder only and will not be updated.\nimport { setVersion } from '@fluentui/set-version';\nsetVersion('@fluentui/react-hooks', '8.8.16');", "/**\n * Verifies if an application can use DOM.\n */\nexport function canUseDOM(): boolean {\n  return (\n    // eslint-disable-next-line no-restricted-globals\n    typeof window !== 'undefined' &&\n    !!(\n      // eslint-disable-next-line no-restricted-globals, deprecation/deprecation\n      (window.document && window.document.createElement)\n    )\n  );\n}\n", "import { canUseDOM } from './canUseDOM';\n\nlet _window: Window | undefined = undefined;\n\n// Note: Accessing \"window\" in IE11 is somewhat expensive, and calling \"typeof window\"\n// hits a memory leak, whereas aliasing it and calling \"typeof _window\" does not.\n// Caching the window value at the file scope lets us minimize the impact.\ntry {\n  // eslint-disable-next-line no-restricted-globals\n  _window = window;\n} catch (e) {\n  /* no-op */\n}\n\n/**\n * Helper to get the window object. The helper will make sure to use a cached variable\n * of \"window\", to avoid overhead and memory leaks in IE11. Note that in popup scenarios the\n * window object won't match the \"global\" window object, and for these scenarios, you should\n * pass in an element hosted within the popup.\n *\n * @public\n */\nexport function getWindow(rootElement?: Element | null): Window | undefined {\n  if (!canUseDOM() || typeof _window === 'undefined') {\n    return undefined;\n  } else {\n    const el = rootElement as Element;\n\n    return el && el.ownerDocument && el.ownerDocument.defaultView ? el.ownerDocument.defaultView : _window;\n  }\n}\n", "import { getWindow } from './dom/getWindow';\n\ndeclare function setTimeout(cb: Function, delay: number): number;\ndeclare function setInterval(cb: Function, delay: number): number;\n\n/**\n * Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled.\n * This Async helper class solves these issues by tying async code to the lifetime of a disposable object.\n *\n * Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a\n * new instance of the class and remember to call dispose() during your code's dispose handler.\n *\n * @public\n */\nexport class Async {\n  private _timeoutIds: { [id: number]: boolean } | null = null;\n  private _immediateIds: { [id: number]: boolean } | null = null;\n  private _intervalIds: { [id: number]: boolean } | null = null;\n  private _animationFrameIds: { [id: number]: boolean } | null = null;\n  private _isDisposed: boolean;\n  private _parent: object | null;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _onErrorHandler: ((e: any) => void) | undefined;\n  private _noop: () => void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(parent?: object, onError?: (e: any) => void) {\n    this._isDisposed = false;\n    this._parent = parent || null;\n    this._onErrorHandler = onError;\n    this._noop = () => {\n      /* do nothing */\n    };\n  }\n\n  /**\n   * Dispose function, clears all async operations.\n   */\n  public dispose(): void {\n    let id;\n\n    this._isDisposed = true;\n    this._parent = null;\n\n    // Clear timeouts.\n    if (this._timeoutIds) {\n      for (id in this._timeoutIds) {\n        if (this._timeoutIds.hasOwnProperty(id)) {\n          this.clearTimeout(parseInt(id, 10));\n        }\n      }\n\n      this._timeoutIds = null;\n    }\n\n    // Clear immediates.\n    if (this._immediateIds) {\n      for (id in this._immediateIds) {\n        if (this._immediateIds.hasOwnProperty(id)) {\n          this.clearImmediate(parseInt(id, 10));\n        }\n      }\n\n      this._immediateIds = null;\n    }\n\n    // Clear intervals.\n    if (this._intervalIds) {\n      for (id in this._intervalIds) {\n        if (this._intervalIds.hasOwnProperty(id)) {\n          this.clearInterval(parseInt(id, 10));\n        }\n      }\n      this._intervalIds = null;\n    }\n\n    // Clear animation frames.\n    if (this._animationFrameIds) {\n      for (id in this._animationFrameIds) {\n        if (this._animationFrameIds.hasOwnProperty(id)) {\n          this.cancelAnimationFrame(parseInt(id, 10));\n        }\n      }\n\n      this._animationFrameIds = null;\n    }\n  }\n\n  /**\n   * SetTimeout override, which will auto cancel the timeout during dispose.\n   * @param callback - Callback to execute.\n   * @param duration - Duration in milliseconds.\n   * @returns The setTimeout id.\n   */\n  public setTimeout(callback: () => void, duration: number): number {\n    let timeoutId = 0;\n\n    if (!this._isDisposed) {\n      if (!this._timeoutIds) {\n        this._timeoutIds = {};\n      }\n\n      timeoutId = setTimeout(() => {\n        // Time to execute the timeout, enqueue it as a foreground task to be executed.\n\n        try {\n          // Now delete the record and call the callback.\n          if (this._timeoutIds) {\n            delete this._timeoutIds[timeoutId];\n          }\n          callback.apply(this._parent);\n        } catch (e) {\n          this._logError(e);\n        }\n      }, duration);\n\n      this._timeoutIds[timeoutId] = true;\n    }\n\n    return timeoutId;\n  }\n\n  /**\n   * Clears the timeout.\n   * @param id - Id to cancel.\n   */\n  public clearTimeout(id: number): void {\n    if (this._timeoutIds && this._timeoutIds[id]) {\n      clearTimeout(id);\n      delete this._timeoutIds[id];\n    }\n  }\n\n  /**\n   * SetImmediate override, which will auto cancel the immediate during dispose.\n   * @param callback - Callback to execute.\n   * @param targetElement - Optional target element to use for identifying the correct window.\n   * @returns The setTimeout id.\n   */\n  public setImmediate(callback: () => void, targetElement?: Element | null): number {\n    let immediateId = 0;\n    const win = getWindow(targetElement)!;\n\n    if (!this._isDisposed) {\n      if (!this._immediateIds) {\n        this._immediateIds = {};\n      }\n\n      let setImmediateCallback = () => {\n        // Time to execute the timeout, enqueue it as a foreground task to be executed.\n\n        try {\n          // Now delete the record and call the callback.\n          if (this._immediateIds) {\n            delete this._immediateIds[immediateId];\n          }\n          callback.apply(this._parent);\n        } catch (e) {\n          this._logError(e);\n        }\n      };\n\n      immediateId = win.setTimeout(setImmediateCallback, 0);\n\n      this._immediateIds[immediateId] = true;\n    }\n\n    return immediateId;\n  }\n\n  /**\n   * Clears the immediate.\n   * @param id - Id to cancel.\n   * @param targetElement - Optional target element to use for identifying the correct window.\n   */\n  public clearImmediate(id: number, targetElement?: Element | null): void {\n    const win = getWindow(targetElement)!;\n\n    if (this._immediateIds && this._immediateIds[id]) {\n      win.clearTimeout(id);\n      delete this._immediateIds[id];\n    }\n  }\n\n  /**\n   * SetInterval override, which will auto cancel the timeout during dispose.\n   * @param callback - Callback to execute.\n   * @param duration - Duration in milliseconds.\n   * @returns The setTimeout id.\n   */\n  public setInterval(callback: () => void, duration: number): number {\n    let intervalId = 0;\n\n    if (!this._isDisposed) {\n      if (!this._intervalIds) {\n        this._intervalIds = {};\n      }\n\n      intervalId = setInterval(() => {\n        // Time to execute the interval callback, enqueue it as a foreground task to be executed.\n        try {\n          callback.apply(this._parent);\n        } catch (e) {\n          this._logError(e);\n        }\n      }, duration);\n\n      this._intervalIds[intervalId] = true;\n    }\n\n    return intervalId;\n  }\n\n  /**\n   * Clears the interval.\n   * @param id - Id to cancel.\n   */\n  public clearInterval(id: number): void {\n    if (this._intervalIds && this._intervalIds[id]) {\n      clearInterval(id);\n      delete this._intervalIds[id];\n    }\n  }\n\n  /**\n   * Creates a function that, when executed, will only call the func function at most once per\n   * every wait milliseconds. Provide an options object to indicate that func should be invoked\n   * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled\n   * function will return the result of the last func call.\n   *\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\n   * the timeout only if the throttled function is invoked more than once during the wait timeout.\n   *\n   * @param func - The function to throttle.\n   * @param wait - The number of milliseconds to throttle executions to. Defaults to 0.\n   * @param options - The options object.\n   * @returns The new throttled function.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public throttle<T extends (...args: any[]) => any>(\n    func: T,\n    wait?: number,\n    options?: {\n      leading?: boolean;\n      trailing?: boolean;\n    },\n  ): T {\n    if (this._isDisposed) {\n      return this._noop as T;\n    }\n\n    let waitMS = wait || 0;\n    let leading = true;\n    let trailing = true;\n    let lastExecuteTime = 0;\n    let lastResult: T;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let lastArgs: any[];\n    let timeoutId: number | null = null;\n\n    if (options && typeof options.leading === 'boolean') {\n      leading = options.leading;\n    }\n\n    if (options && typeof options.trailing === 'boolean') {\n      trailing = options.trailing;\n    }\n\n    let callback = (userCall?: boolean) => {\n      let now = Date.now();\n      let delta = now - lastExecuteTime;\n      let waitLength = leading ? waitMS - delta : waitMS;\n      if (delta >= waitMS && (!userCall || leading)) {\n        lastExecuteTime = now;\n        if (timeoutId) {\n          this.clearTimeout(timeoutId);\n          timeoutId = null;\n        }\n        lastResult = func.apply(this._parent, lastArgs);\n      } else if (timeoutId === null && trailing) {\n        timeoutId = this.setTimeout(callback, waitLength);\n      }\n\n      return lastResult;\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let resultFunction = ((...args: any[]): any => {\n      lastArgs = args;\n      return callback(true);\n    }) as T;\n\n    return resultFunction;\n  }\n\n  /**\n   * Creates a function that will delay the execution of func until after wait milliseconds have\n   * elapsed since the last time it was invoked. Provide an options object to indicate that func\n   * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls\n   * to the debounced function will return the result of the last func call.\n   *\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\n   * the timeout only if the debounced function is invoked more than once during the wait\n   * timeout.\n   *\n   * @param func - The function to debounce.\n   * @param wait - The number of milliseconds to delay.\n   * @param options - The options object.\n   * @returns The new debounced function.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public debounce<T extends (...args: any[]) => any>(\n    func: T,\n    wait?: number,\n    options?: {\n      leading?: boolean;\n      maxWait?: number;\n      trailing?: boolean;\n    },\n  ): ICancelable<T> & T {\n    if (this._isDisposed) {\n      let noOpFunction = (() => {\n        /** Do nothing */\n      }) as ICancelable<T> & T;\n\n      noOpFunction.cancel = () => {\n        return;\n      };\n      noOpFunction.flush = (() => null) as unknown as () => ReturnType<T>;\n      noOpFunction.pending = () => false;\n\n      return noOpFunction;\n    }\n\n    let waitMS = wait || 0;\n    let leading = false;\n    let trailing = true;\n    let maxWait: number | null = null;\n    let lastCallTime = 0;\n    let lastExecuteTime = Date.now();\n    let lastResult: ReturnType<T>;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let lastArgs: any[];\n    let timeoutId: number | null = null;\n\n    if (options && typeof options.leading === 'boolean') {\n      leading = options.leading;\n    }\n\n    if (options && typeof options.trailing === 'boolean') {\n      trailing = options.trailing;\n    }\n\n    if (options && typeof options.maxWait === 'number' && !isNaN(options.maxWait)) {\n      maxWait = options.maxWait;\n    }\n\n    let markExecuted = (time: number) => {\n      if (timeoutId) {\n        this.clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n      lastExecuteTime = time;\n    };\n\n    let invokeFunction = (time: number) => {\n      markExecuted(time);\n      lastResult = func.apply(this._parent, lastArgs);\n    };\n\n    let callback = (userCall?: boolean) => {\n      let now = Date.now();\n      let executeImmediately = false;\n      if (userCall) {\n        if (leading && now - lastCallTime >= waitMS) {\n          executeImmediately = true;\n        }\n        lastCallTime = now;\n      }\n      let delta = now - lastCallTime;\n      let waitLength = waitMS - delta;\n      let maxWaitDelta = now - lastExecuteTime;\n      let maxWaitExpired = false;\n\n      if (maxWait !== null) {\n        // maxWait only matters when there is a pending callback\n        if (maxWaitDelta >= maxWait && timeoutId) {\n          maxWaitExpired = true;\n        } else {\n          waitLength = Math.min(waitLength, maxWait - maxWaitDelta);\n        }\n      }\n\n      if (delta >= waitMS || maxWaitExpired || executeImmediately) {\n        invokeFunction(now);\n      } else if ((timeoutId === null || !userCall) && trailing) {\n        timeoutId = this.setTimeout(callback, waitLength);\n      }\n\n      return lastResult;\n    };\n\n    let pending = (): boolean => {\n      return !!timeoutId;\n    };\n\n    let cancel = (): void => {\n      if (pending()) {\n        // Mark the debounced function as having executed\n        markExecuted(Date.now());\n      }\n    };\n\n    let flush = () => {\n      if (pending()) {\n        invokeFunction(Date.now());\n      }\n\n      return lastResult;\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let resultFunction = ((...args: any[]) => {\n      lastArgs = args;\n      return callback(true);\n    }) as ICancelable<T> & T;\n\n    resultFunction.cancel = cancel;\n    resultFunction.flush = flush;\n    resultFunction.pending = pending;\n\n    return resultFunction;\n  }\n\n  public requestAnimationFrame(callback: () => void, targetElement?: Element | null): number {\n    let animationFrameId = 0;\n    const win = getWindow(targetElement)!;\n\n    if (!this._isDisposed) {\n      if (!this._animationFrameIds) {\n        this._animationFrameIds = {};\n      }\n\n      let animationFrameCallback = () => {\n        try {\n          // Now delete the record and call the callback.\n          if (this._animationFrameIds) {\n            delete this._animationFrameIds[animationFrameId];\n          }\n\n          callback.apply(this._parent);\n        } catch (e) {\n          this._logError(e);\n        }\n      };\n\n      animationFrameId = win.requestAnimationFrame\n        ? win.requestAnimationFrame(animationFrameCallback)\n        : win.setTimeout(animationFrameCallback, 0);\n\n      this._animationFrameIds[animationFrameId] = true;\n    }\n\n    return animationFrameId;\n  }\n\n  public cancelAnimationFrame(id: number, targetElement?: Element | null): void {\n    const win = getWindow(targetElement)!;\n\n    if (this._animationFrameIds && this._animationFrameIds[id]) {\n      win.cancelAnimationFrame ? win.cancelAnimationFrame(id) : win.clearTimeout(id);\n      delete this._animationFrameIds[id];\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected _logError(e: any): void {\n    if (this._onErrorHandler) {\n      this._onErrorHandler(e);\n    }\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ICancelable<T extends (...args: any[]) => any> = {\n  flush: () => ReturnType<T>;\n  cancel: () => void;\n  pending: () => boolean;\n};\n", "import { IVirtualElement } from './IVirtualElement';\n/**\n * Determines whether or not an element has the virtual hierarchy extension.\n *\n * @public\n */\nexport function isVirtualElement(element: HTMLElement | IVirtualElement): element is IVirtualElement {\n  return element && !!(<IVirtualElement>element)._virtual;\n}\n", "import { isVirtualElement } from './isVirtualElement';\n/**\n * Gets the virtual parent given the child element, if it exists.\n *\n * @public\n */\nexport function getVirtualParent(child: HTMLElement): HTMLElement | undefined {\n  let parent: HTMLElement | undefined;\n  if (child && isVirtualElement(child)) {\n    parent = child._virtual.parent;\n  }\n  return parent;\n}\n", "import { getVirtualParent } from './getVirtualParent';\n/**\n * Gets the element which is the parent of a given element.\n * If `allowVirtuaParents` is `true`, this method prefers the virtual parent over\n * real DOM parent when present.\n *\n * @public\n */\nexport function getParent(child: HTMLElement, allowVirtualParents: boolean = true): HTMLElement | null {\n  if (!child) {\n    return null;\n  }\n\n  const parent = allowVirtualParents && getVirtualParent(child);\n\n  if (parent) {\n    return parent;\n  }\n\n  // Support looking for parents in shadow DOM\n  if (typeof (child as HTMLSlotElement).assignedElements !== 'function' && child.assignedSlot?.parentNode) {\n    // Element is slotted\n    return child.assignedSlot as HTMLElement;\n  } else if (child.parentNode?.nodeType === 11) {\n    // nodeType 11 is DOCUMENT_FRAGMENT\n    // Element is in shadow root\n    return (child.parentNode as ShadowRoot).host as HTMLElement;\n  } else {\n    return child.parentNode as HTMLElement;\n  }\n}\n", "import { getParent } from './getParent';\n/**\n * Determines whether or not a parent element contains a given child element.\n * If `allowVirtualParents` is true, this method may return `true` if the child\n * has the parent in its virtual element hierarchy.\n *\n * @public\n */\nexport function elementContains(\n  parent: HTMLElement | null,\n  child: HTMLElement | null,\n  allowVirtualParents: boolean = true,\n): boolean {\n  let isContained = false;\n\n  if (parent && child) {\n    if (allowVirtualParents) {\n      if (parent === child) {\n        isContained = true;\n      } else {\n        isContained = false;\n\n        while (child) {\n          const nextParent: HTMLElement | null = getParent(child);\n\n          if (nextParent === parent) {\n            isContained = true;\n            break;\n          }\n\n          child = nextParent;\n        }\n      }\n    } else if (parent.contains) {\n      isContained = parent.contains(child);\n    }\n  }\n\n  return isContained;\n}\n", "import { getParent } from './getParent';\n/**\n * Finds the first parent element where the matchFunction returns true\n * @param element - element to start searching at\n * @param matchFunction - the function that determines if the element is a match\n * @returns the matched element or null no match was found\n */\nexport function findElementRecursive(\n  element: HTMLElement | null,\n  matchFunction: (element: HTMLElement) => boolean,\n  doc?: Document,\n): HTMLElement | null {\n  // eslint-disable-next-line no-restricted-globals\n  doc ??= document;\n  if (!element || element === doc.body || element instanceof Document) {\n    return null;\n  }\n  return matchFunction(element) ? element : findElementRecursive(getParent(element), matchFunction);\n}\n", "import { findElementRecursive } from './findElementRecursive';\n\n/**\n * Determines if an element, or any of its ancestors, contain the given attribute\n * @param element - element to start searching at\n * @param attribute - the attribute to search for\n * @returns the value of the first instance found\n */\nexport function elementContainsAttribute(element: HTMLElement, attribute: string, doc?: Document): string | null {\n  const elementMatch = findElementRecursive(\n    element,\n    (testElement: HTMLElement) => testElement.hasAttribute(attribute),\n    doc,\n  );\n\n  return elementMatch && elementMatch.getAttribute(attribute);\n}\n", "export const getActiveElement = (doc: Document): Element | null => {\n  let ae = doc.activeElement;\n\n  while (ae?.shadowRoot) {\n    ae = ae.shadowRoot.activeElement;\n  }\n\n  return ae;\n};\n", "import { isVirtualElement } from './isVirtualElement';\n/**\n * Gets the elements which are child elements of the given element.\n * If `allowVirtualChildren` is `true`, this method enumerates virtual child elements\n * after the original children.\n * @param parent - The element to get the children of.\n * @param allowVirtualChildren - true if the method should enumerate virtual child elements.\n */\nexport function getChildren(parent: HTMLElement, allowVirtualChildren: boolean = true): HTMLElement[] {\n  const children: HTMLElement[] = [];\n  if (parent) {\n    for (let i = 0; i < parent.children.length; i++) {\n      children.push(parent.children.item(i) as HTMLElement);\n    }\n    if (allowVirtualChildren && isVirtualElement(parent)) {\n      children.push(...parent._virtual.children);\n    }\n  }\n  return children;\n}\n", "export const getEventTarget = (event: Event): HTMLElement | null => {\n  let target = event.target as HTMLElement;\n  if (target && target.shadowRoot) {\n    target = event.composedPath()[0] as HTMLElement;\n  }\n\n  return target;\n};\n", "export const DATA_PORTAL_ATTRIBUTE = 'data-portal-element';\n\n/**\n * Identify element as a portal by setting an attribute.\n * @param element - Element to mark as a portal.\n */\nexport function setPortalAttribute(element: HTMLElement): void {\n  element.setAttribute(DATA_PORTAL_ATTRIBUTE, 'true');\n}\n", "import { findElementRecursive } from './findElementRecursive';\nimport { DATA_PORTAL_ATTRIBUTE } from './setPortalAttribute';\n\n/**\n * Determine whether a target is within a portal from perspective of root or optional parent.\n * This function only works against portal components that use the setPortalAttribute function.\n * If both parent and child are within the same portal this function will return false.\n * @param target - Element to query portal containment status of.\n * @param parent - Optional parent perspective. Search for containing portal stops at parent\n * (or root if parent is undefined or invalid.)\n */\nexport function portalContainsElement(target: HTMLElement, parent?: HTMLElement, doc?: Document): boolean {\n  const elementMatch = findElementRecursive(\n    target,\n    (testElement: HTMLElement) => parent === testElement || !!testElement.hasAttribute?.(DATA_PORTAL_ATTRIBUTE),\n    doc,\n  );\n  return elementMatch !== null && !!elementMatch.hasAttribute?.(DATA_PORTAL_ATTRIBUTE);\n}\n", "import { IVirtualElement } from './IVirtualElement';\n/**\n * Sets the virtual parent of an element.\n * Pass `undefined` as the `parent` to clear the virtual parent.\n *\n * @public\n */\nexport function setVirtualParent(child: HTMLElement, parent: HTMLElement | null): void {\n  const virtualChild = <IVirtualElement>child;\n  const virtualParent = <IVirtualElement | null>parent;\n\n  if (!virtualChild._virtual) {\n    virtualChild._virtual = {\n      children: [],\n    };\n  }\n\n  const oldParent = virtualChild._virtual.parent;\n\n  if (oldParent && oldParent !== parent) {\n    // Remove the child from its old parent.\n    const index = oldParent._virtual.children.indexOf(virtualChild);\n\n    if (index > -1) {\n      oldParent._virtual.children.splice(index, 1);\n    }\n  }\n\n  virtualChild._virtual.parent = virtualParent || undefined;\n\n  if (virtualParent) {\n    if (!virtualParent._virtual) {\n      virtualParent._virtual = {\n        children: [],\n      };\n    }\n\n    virtualParent._virtual.children.push(virtualChild);\n  }\n}\n", "// Do not modify this file; it is generated as part of publish.\n// The checked in version is a placeholder only and will not be updated.\nimport { setVersion } from '@fluentui/set-version';\nsetVersion('@fluentui/dom-utilities', '2.3.9');", "import { canUseDOM } from './canUseDOM';\n\n/**\n * Helper to get the document object. Note that in popup window cases, document\n * might be the wrong document, which is why we look at ownerDocument for the\n * truth.\n *\n * @public\n */\nexport function getDocument(rootElement?: HTMLElement | null): Document | undefined {\n  // eslint-disable-next-line no-restricted-globals\n  if (!canUseDOM() || typeof document === 'undefined') {\n    return undefined;\n  } else {\n    const el = rootElement as Element;\n\n    // eslint-disable-next-line no-restricted-globals\n    return el && el.ownerDocument ? el.ownerDocument : document;\n  }\n}\n", "import { elementContainsAttribute } from './dom/elementContainsAttribute';\nimport { elementContains } from './dom/elementContains';\nimport { getParent } from './dom/getParent';\nimport { getWindow } from './dom/getWindow';\nimport { getDocument } from './dom/getDocument';\n\nconst IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nconst IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nconst FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nconst FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';\n\n/**\n * Gets the first focusable element.\n *\n * @public\n */\nexport function getFirstFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  includeShadowRoots?: boolean,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    true /*checkNode*/,\n    false /*suppressParentTraversal*/,\n    false /*suppressChildTraversal*/,\n    includeElementsInFocusZones,\n    undefined,\n    undefined,\n    undefined,\n    includeShadowRoots,\n  );\n}\n\n/**\n * Gets the last focusable element.\n *\n * @public\n */\nexport function getLastFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  includeShadowRoots?: boolean,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    true /*checkNode*/,\n    false /*suppressParentTraversal*/,\n    true /*traverseChildren*/,\n    includeElementsInFocusZones,\n    undefined,\n    undefined,\n    includeShadowRoots,\n  );\n}\n\n/**\n * Gets the first tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues forward.  Typical use passes rootElement.firstChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\nexport function getFirstTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode: boolean = true,\n  includeShadowRoots?: boolean,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /*suppressParentTraversal*/,\n    false /*suppressChildTraversal*/,\n    includeElementsInFocusZones,\n    false /*allowFocusRoot*/,\n    true /*tabbable*/,\n    undefined,\n    includeShadowRoots,\n  );\n}\n\n/**\n * Gets the last tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues in reverse.  Typical use passes rootElement.lastChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\nexport function getLastTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode: boolean = true,\n  includeShadowRoots?: boolean,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /*suppressParentTraversal*/,\n    true /*traverseChildren*/,\n    includeElementsInFocusZones,\n    false /*allowFocusRoot*/,\n    true /*tabbable*/,\n    includeShadowRoots,\n  );\n}\n\n/**\n * Attempts to focus the first focusable element that is a child or child's child of the rootElement.\n *\n * @public\n * @param rootElement - Element to start the search for a focusable child.\n * @param bypassHiddenElements - If true, focus will be not be set on hidden elements.\n * @returns True if focus was set, false if it was not.\n */\nexport function focusFirstChild(\n  rootElement: HTMLElement,\n  bypassHiddenElements?: boolean,\n  includeShadowRoots?: boolean,\n): boolean {\n  let element: HTMLElement | null = getNextElement(\n    rootElement,\n    rootElement,\n    true,\n    false,\n    false,\n    true,\n    undefined,\n    undefined,\n    bypassHiddenElements,\n    includeShadowRoots,\n  );\n\n  if (element) {\n    focusAsync(element);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Traverse to find the previous element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\nexport function getPreviousElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  traverseChildren?: boolean,\n  includeElementsInFocusZones?: boolean,\n  allowFocusRoot?: boolean,\n  tabbable?: boolean,\n  includeShadowRoots?: boolean,\n): HTMLElement | null {\n  if (!currentElement || (!allowFocusRoot && currentElement === rootElement)) {\n    return null;\n  }\n\n  let isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check its children.\n  if (\n    traverseChildren &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const lastElementChild = (currentElement.lastElementChild ||\n      (includeShadowRoots && currentElement.shadowRoot?.lastElementChild)) as HTMLElement;\n\n    const childMatch = getPreviousElement(\n      rootElement,\n      lastElementChild,\n      true,\n      true,\n      true,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n      includeShadowRoots,\n    );\n\n    if (childMatch) {\n      if ((tabbable && isElementTabbable(childMatch, true, includeShadowRoots)) || !tabbable) {\n        return childMatch;\n      }\n\n      const childMatchSiblingMatch = getPreviousElement(\n        rootElement,\n        childMatch.previousElementSibling as HTMLElement,\n        true,\n        true,\n        true,\n        includeElementsInFocusZones,\n        allowFocusRoot,\n        tabbable,\n        includeShadowRoots,\n      );\n      if (childMatchSiblingMatch) {\n        return childMatchSiblingMatch;\n      }\n\n      let childMatchParent = childMatch.parentElement;\n\n      // At this point if we have not found any potential matches\n      // start looking at the rest of the subtree under the currentParent.\n      // NOTE: We do not want to recurse here because doing so could\n      // cause elements to get skipped.\n      while (childMatchParent && childMatchParent !== currentElement) {\n        const childMatchParentMatch = getPreviousElement(\n          rootElement,\n          childMatchParent.previousElementSibling as HTMLElement,\n          true,\n          true,\n          true,\n          includeElementsInFocusZones,\n          allowFocusRoot,\n          tabbable,\n          includeShadowRoots,\n        );\n\n        if (childMatchParentMatch) {\n          return childMatchParentMatch;\n        }\n\n        childMatchParent = childMatchParent.parentElement;\n      }\n    }\n  }\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable, includeShadowRoots)) {\n    return currentElement;\n  }\n\n  // Check its previous sibling.\n  const siblingMatch = getPreviousElement(\n    rootElement,\n    currentElement.previousElementSibling as HTMLElement,\n    true,\n    true,\n    true,\n    includeElementsInFocusZones,\n    allowFocusRoot,\n    tabbable,\n    includeShadowRoots,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  // Check its parent.\n  if (!suppressParentTraversal) {\n    return getPreviousElement(\n      rootElement,\n      currentElement.parentElement,\n      true,\n      false,\n      false,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n      includeShadowRoots,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Traverse to find the next focusable element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n * @param checkNode - Include currentElement in search when true.\n */\nexport function getNextElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  suppressChildTraversal?: boolean,\n  includeElementsInFocusZones?: boolean,\n  allowFocusRoot?: boolean,\n  tabbable?: boolean,\n  bypassHiddenElements?: boolean,\n  includeShadowRoots?: boolean,\n): HTMLElement | null {\n  if (!currentElement || (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {\n    return null;\n  }\n\n  const checkElementVisibility = bypassHiddenElements ? isElementVisibleAndNotHidden : isElementVisible;\n\n  let isCurrentElementVisible = checkElementVisibility(currentElement);\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable, includeShadowRoots)) {\n    return currentElement;\n  }\n\n  // Check its children.\n  if (\n    !suppressChildTraversal &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const firstElementchild = (currentElement.firstElementChild ||\n      (includeShadowRoots && currentElement.shadowRoot?.firstElementChild)) as HTMLElement;\n\n    const childMatch = getNextElement(\n      rootElement,\n      firstElementchild,\n      true,\n      true,\n      false,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n      bypassHiddenElements,\n      includeShadowRoots,\n    );\n\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n\n  if (currentElement === rootElement) {\n    return null;\n  }\n\n  // Check its sibling.\n  const siblingMatch = getNextElement(\n    rootElement,\n    currentElement.nextElementSibling as HTMLElement,\n    true,\n    true,\n    false,\n    includeElementsInFocusZones,\n    allowFocusRoot,\n    tabbable,\n    bypassHiddenElements,\n    includeShadowRoots,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  if (!suppressParentTraversal) {\n    return getNextElement(\n      rootElement,\n      currentElement.parentElement,\n      false,\n      false,\n      true,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n      bypassHiddenElements,\n      includeShadowRoots,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Determines if an element is visible.\n *\n * @public\n */\nexport function isElementVisible(element: HTMLElement | undefined | null): boolean {\n  // If the element is not valid, return false.\n  if (!element || !element.getAttribute) {\n    return false;\n  }\n\n  const visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);\n\n  // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n    return visibilityAttribute === 'true';\n  }\n\n  // Fallback to other methods of determining actual visibility.\n  return (\n    element.offsetHeight !== 0 ||\n    element.offsetParent !== null ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (element as any).isVisible === true\n  ); // used as a workaround for testing.\n}\n\n/**\n * Determines if an element is visible and not hidden\n * @param element - Element to check\n * @returns Returns true if the given element is visible and not hidden\n *\n * @public\n */\nexport function isElementVisibleAndNotHidden(element: HTMLElement | undefined | null, win?: Window): boolean {\n  const theWin = win ?? getWindow()!;\n  return (\n    !!element &&\n    isElementVisible(element) &&\n    !element.hidden &&\n    theWin.getComputedStyle(element).visibility !== 'hidden'\n  );\n}\n\n/**\n * Determines if an element can receive focus programmatically or via a mouse click.\n * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key,\n * meaning tabIndex != -1.\n *\n * @public\n */\nexport function isElementTabbable(\n  element: HTMLElement,\n  checkTabIndex?: boolean,\n  checkShadowRoot: boolean = true,\n): boolean {\n  // If this element is null or is disabled, it is not considered tabbable.\n  if (!element || (element as HTMLButtonElement).disabled) {\n    return false;\n  }\n\n  let tabIndex = 0;\n  let tabIndexAttributeValue = null;\n\n  if (element && element.getAttribute) {\n    tabIndexAttributeValue = element.getAttribute('tabIndex');\n\n    if (tabIndexAttributeValue) {\n      tabIndex = parseInt(tabIndexAttributeValue, 10);\n    }\n  }\n\n  let isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\n  let isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;\n  let delegatesFocus = checkShadowRoot && element.shadowRoot ? !!element.shadowRoot.delegatesFocus : false;\n\n  const result =\n    !!element &&\n    isFocusableAttribute !== 'false' &&\n    (element.tagName === 'A' ||\n      element.tagName === 'BUTTON' ||\n      element.tagName === 'INPUT' ||\n      element.tagName === 'TEXTAREA' ||\n      element.tagName === 'SELECT' ||\n      isFocusableAttribute === 'true' ||\n      isTabIndexSet ||\n      delegatesFocus);\n\n  return checkTabIndex ? tabIndex !== -1 && result : result;\n}\n\n/**\n * Determines if a given element is a focus zone.\n *\n * @public\n */\nexport function isElementFocusZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));\n}\n\n/**\n * Determines if a given element is a focus sub zone.\n *\n * @public\n */\nexport function isElementFocusSubZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');\n}\n\n/**\n * Determines if an element, or any of its children, contain focus.\n *\n * @public\n */\nexport function doesElementContainFocus(element: HTMLElement): boolean {\n  let doc = getDocument(element);\n  let currentActiveElement: HTMLElement | undefined = doc && (doc.activeElement as HTMLElement);\n  if (currentActiveElement && elementContains(element, currentActiveElement)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap\n * @param element - element to start searching from\n * @param noWrapDataAttribute - the no wrap data attribute to match (either)\n * @returns true if focus should wrap, false otherwise\n */\nexport function shouldWrapFocus(\n  element: HTMLElement,\n  noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap',\n  doc?: Document,\n): boolean {\n  const theDoc = doc ?? getDocument()!;\n  return elementContainsAttribute(element, noWrapDataAttribute, theDoc) === 'true' ? false : true;\n}\n\nlet animationId: number | undefined = undefined;\n\n/**\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\n * only the latest called focusAsync element will actually be focused\n * @param element - The element to focus\n */\nexport function focusAsync(element: HTMLElement | { focus: () => void } | undefined | null): void {\n  if (element) {\n    const win = getWindow(element as Element);\n\n    if (win) {\n      // cancel any previous focus queues\n      if (animationId !== undefined) {\n        win.cancelAnimationFrame(animationId);\n      }\n\n      // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\n      animationId = win.requestAnimationFrame(() => {\n        element && element.focus();\n\n        // We are done focusing for this frame, so reset the queued focus element\n        animationId = undefined;\n      });\n    }\n  }\n}\n\n/**\n * Finds the closest focusable element via an index path from a parent. See\n * `getElementIndexPath` for getting an index path from an element to a child.\n */\nexport function getFocusableByIndexPath(parent: HTMLElement, path: number[]): HTMLElement | undefined {\n  let element = parent;\n\n  for (const index of path) {\n    const nextChild = element.children[Math.min(index, element.children.length - 1)] as HTMLElement;\n\n    if (!nextChild) {\n      break;\n    }\n    element = nextChild;\n  }\n\n  element =\n    isElementTabbable(element) && isElementVisible(element)\n      ? element\n      : getNextElement(parent, element, true) || getPreviousElement(parent, element)!;\n\n  return element as HTMLElement;\n}\n\n/**\n * Finds the element index path from a parent element to a child element.\n *\n * If you had this node structure: \"A has children [B, C] and C has child D\",\n * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.\n */\nexport function getElementIndexPath(fromElement: HTMLElement, toElement: HTMLElement): number[] {\n  const path: number[] = [];\n\n  while (toElement && fromElement && toElement !== fromElement) {\n    const parent = getParent(toElement, true);\n\n    if (parent === null) {\n      return [];\n    }\n\n    path.unshift(Array.prototype.indexOf.call(parent.children, toElement));\n    toElement = parent;\n  }\n\n  return path;\n}\n", "import { isElementVisibleAndNotHidden } from '../focus';\nimport { getDocument } from './getDocument';\n\n/**\n * Gets the first visible element that matches the given selector\n * @param selector - The selector to use to find potential visible elements\n * @returns The first visible element that matches the selector, otherwise undefined\n *\n * @public\n */\nexport function getFirstVisibleElementFromSelector(selector: string): Element | undefined {\n  const doc = getDocument()!;\n  const elements = doc.querySelectorAll(selector);\n\n  // Iterate across the elements that match the selector and return the first visible/non-hidden element\n  return Array.from(elements).find((element: HTMLElement) =>\n    isElementVisibleAndNotHidden(element, doc.defaultView ?? undefined),\n  );\n}\n", "import type { IRectangle } from '../IRectangle';\nimport { getWindow } from './getWindow';\n\n/**\n * Helper to get bounding client rect. Passing in window will get the window size.\n *\n * @public\n */\nexport function getRect(element: HTMLElement | Window | null, win?: Window): IRectangle | undefined {\n  const theWin =\n    win ?? (!element || (element && element.hasOwnProperty('devicePixelRatio')))\n      ? getWindow()\n      : getWindow(element as HTMLElement)!;\n  let rect: IRectangle | undefined;\n  if (element) {\n    if (element === theWin) {\n      rect = {\n        left: 0,\n        top: 0,\n        width: theWin.innerWidth,\n        height: theWin.innerHeight,\n        right: theWin.innerWidth,\n        bottom: theWin.innerHeight,\n      };\n    } else if ((element as { getBoundingClientRect?: unknown }).getBoundingClientRect) {\n      rect = (element as HTMLElement).getBoundingClientRect();\n    }\n  }\n  return rect;\n}\n", "export function on(\n  element: Element | Window | Document,\n  eventName: string,\n  callback: (ev: Event) => void,\n  options?: boolean,\n): () => void {\n  element.addEventListener(eventName, callback, options);\n\n  return () => element.removeEventListener(eventName, callback, options);\n}\n", "import { getDocument } from './getDocument';\n\n/** Raises a click event.\n * @deprecated Moved to `FocusZone` component since it was the only place internally using this function.\n */\nexport function raiseClick(target: Element, doc?: Document): void {\n  const theDoc = doc ?? getDocument()!;\n  const event = createNewEvent('MouseEvents', theDoc);\n  // eslint-disable-next-line deprecation/deprecation\n  event.initEvent('click', true, true);\n  target.dispatchEvent(event);\n}\n\nfunction createNewEvent(eventName: string, doc: Document): Event {\n  let event;\n  if (typeof Event === 'function') {\n    // Chrome, Opera, Firefox\n    event = new Event(eventName);\n  } else {\n    // IE\n    event = doc.createEvent('Event');\n    // eslint-disable-next-line deprecation/deprecation\n    event.initEvent(eventName, true, true);\n  }\n  return event;\n}\n", "/**\n * Compares a to b and b to a.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function shallowCompare<TA extends any, TB extends any>(a: TA, b: TB): boolean {\n  if (!a || !b) {\n    // only return true if both a and b are falsy\n    return !a && !b;\n  }\n\n  for (let propName in a) {\n    if ((a as Object).hasOwnProperty(propName)) {\n      if (!(b as Object).hasOwnProperty(propName) || (b as { [key: string]: unknown })[propName] !== a[propName]) {\n        return false;\n      }\n    }\n  }\n  for (let propName in b) {\n    if ((b as Object).hasOwnProperty(propName)) {\n      if (!(a as Object).hasOwnProperty(propName)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Makes a resulting merge of a bunch of objects. Pass in the target object followed by 1 or more\n * objects as arguments and they will be merged sequentially into the target. Note that this will\n * shallow merge; it will not create new cloned values for target members.\n *\n * @public\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function assign(this: any, target: any, ...args: any[]): any {\n  return filteredAssign.apply(this, [null, target].concat(args));\n}\n\n/**\n * Makes a resulting merge of a bunch of objects, but allows a filter function to be passed in to filter\n * the resulting merges. This allows for scenarios where you want to merge \"everything except that one thing\"\n * or \"properties that start with data-\". Note that this will shallow merge; it will not create new cloned\n * values for target members.\n *\n * @public\n * @param isAllowed - Callback to determine if the given propName is allowed in the result.\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function filteredAssign(isAllowed: (propName: string) => boolean, target: any, ...args: any[]): any {\n  target = target || {};\n\n  for (let sourceObject of args) {\n    if (sourceObject) {\n      for (let propName in sourceObject) {\n        if (sourceObject.hasOwnProperty(propName) && (!isAllowed || isAllowed(propName))) {\n          target[propName] = sourceObject[propName];\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\n/**\n * Takes an enum and iterates over each value of the enum (as a string), running the callback on each,\n * returning a mapped array.\n * @param theEnum - Enum to iterate over\n * @param callback - The first parameter the name of the entry, and the second parameter is the value\n * of that entry, which is the value you'd normally use when using the enum (usually a number).\n */\nexport function mapEnumByName<T>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  theEnum: any,\n  callback: (name?: string, value?: string | number) => T | undefined,\n): (T | undefined)[] | undefined {\n  // map<any> to satisfy compiler since it doesn't realize we strip out undefineds in the .filter() call\n  return Object.keys(theEnum)\n    .map<T | undefined>((p: string | number) => {\n      // map on each property name as a string\n      if (String(Number(p)) !== p) {\n        // if the property is not just a number (because enums in TypeScript will map both ways)\n        return callback(p as string, theEnum[p]);\n      }\n      return undefined;\n    })\n    .filter((v: T | undefined) => !!v); // only return elements with values\n}\n\n/**\n * Get all values in an object dictionary\n *\n * @param obj - The dictionary to get values for\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function values<T>(obj: any): T[] {\n  return Object.keys(obj).reduce((arr: T[], key: string): T[] => {\n    arr.push(obj[key]);\n    return arr;\n  }, []);\n}\n\n/**\n * Tiny helper to do the minimal amount of work in duplicating an object but omitting some\n * props. This ends up faster than using object ...rest or reduce to filter.\n *\n * This behaves very much like filteredAssign, but does not merge many objects together,\n * uses an exclusion object map, and avoids spreads all for optimal performance.\n *\n * See perf test for background:\n * https://jsperf.com/omit-vs-rest-vs-reduce/1\n *\n * @param obj - The object to clone\n * @param exclusions - The array of keys to exclude\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function omit<TObj extends Record<string, any>>(obj: TObj, exclusions: (keyof TObj)[]): TObj {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const result: Record<string, any> = {};\n\n  for (const key in obj) {\n    if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) {\n      result[key] = obj[key];\n    }\n  }\n\n  return result as TObj;\n}\n", "import { getDocument } from './dom';\nimport { assign } from './object';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * @internal\n */\nexport interface IEventRecord {\n  target: any;\n  eventName: string;\n  parent: any;\n  callback: (args?: any) => void;\n  elementCallback?: (...args: any[]) => void;\n  objectCallback?: (args?: any) => void;\n  options?: boolean | AddEventListenerOptions;\n}\n\n/**\n * @internal\n */\nexport interface IEventRecordsByName {\n  [eventName: string]: IEventRecordList;\n}\n\n/**\n * @internal\n */\nexport interface IEventRecordList {\n  [id: string]: IEventRecord[] | number;\n  count: number;\n}\n\n/**\n * @internal\n */\nexport interface IDeclaredEventsByName {\n  [eventName: string]: boolean;\n}\n\n/** An instance of EventGroup allows anything with a handle to it to trigger events on it.\n *  If the target is an HTMLElement, the event will be attached to the element and can be\n *  triggered as usual (like clicking for onClick).\n *  The event can be triggered by calling EventGroup.raise() here. If the target is an\n *  HTMLElement, the event gets raised and is handled by the browser. Otherwise, it gets\n *  handled here in EventGroup, and the handler is called in the context of the parent\n *  (which is passed in in the constructor).\n *\n * @public\n * {@docCategory EventGroup}\n */\nexport class EventGroup {\n  private static _uniqueId: number = 0;\n  private _parent: any;\n  private _eventRecords: IEventRecord[];\n  private _id: number = EventGroup._uniqueId++;\n  private _isDisposed!: boolean;\n\n  /** For IE8, bubbleEvent is ignored here and must be dealt with by the handler.\n   *  Events raised here by default have bubbling set to false and cancelable set to true.\n   *  This applies also to built-in events being raised manually here on HTMLElements,\n   *  which may lead to unexpected behavior if it differs from the defaults.\n   *\n   */\n  public static raise(\n    target: any,\n    eventName: string,\n    eventArgs?: any,\n    bubbleEvent?: boolean,\n    doc?: Document,\n  ): boolean | undefined {\n    let retVal;\n    const theDoc = doc ?? getDocument()!;\n\n    if (EventGroup._isElement(target)) {\n      if (typeof theDoc !== 'undefined' && theDoc.createEvent) {\n        let ev = theDoc.createEvent('HTMLEvents');\n\n        // eslint-disable-next-line deprecation/deprecation\n        ev.initEvent(eventName, bubbleEvent || false, true);\n\n        assign(ev, eventArgs);\n\n        retVal = target.dispatchEvent(ev);\n      } else if (typeof theDoc !== 'undefined' && (theDoc as any).createEventObject) {\n        // IE8\n        let evObj = (theDoc as any).createEventObject(eventArgs);\n        // cannot set cancelBubble on evObj, fireEvent will overwrite it\n        target.fireEvent('on' + eventName, evObj);\n      }\n    } else {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore  -- FIXME: strictBindCallApply error - https://github.com/microsoft/fluentui/issues/17331\n      while (target && retVal !== false) {\n        let events = <IEventRecordsByName>target.__events__;\n        let eventRecords = events ? events[eventName] : null;\n\n        if (eventRecords) {\n          for (let id in eventRecords) {\n            if (eventRecords.hasOwnProperty(id)) {\n              let eventRecordList = <IEventRecord[]>eventRecords[id];\n\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore  -- FIXME: strictBindCallApply error - https://github.com/microsoft/fluentui/issues/17331\n              for (let listIndex = 0; retVal !== false && listIndex < eventRecordList.length; listIndex++) {\n                let record = eventRecordList[listIndex];\n\n                if (record.objectCallback) {\n                  retVal = record.objectCallback.call(record.parent, eventArgs);\n                }\n              }\n            }\n          }\n        }\n\n        // If the target has a parent, bubble the event up.\n        target = bubbleEvent ? target.parent : null;\n      }\n    }\n\n    return retVal;\n  }\n\n  public static isObserved(target: any, eventName: string): boolean {\n    let events = target && <IEventRecordsByName>target.__events__;\n\n    return !!events && !!events[eventName];\n  }\n\n  /** Check to see if the target has declared support of the given event. */\n  public static isDeclared(target: any, eventName: string): boolean {\n    let declaredEvents = target && <IDeclaredEventsByName>target.__declaredEvents;\n\n    return !!declaredEvents && !!declaredEvents[eventName];\n  }\n\n  public static stopPropagation(event: any): void {\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else {\n      // IE8\n      event.cancelBubble = true;\n    }\n  }\n\n  private static _isElement(target: HTMLElement): boolean {\n    return (\n      !!target && (!!target.addEventListener || (typeof HTMLElement !== 'undefined' && target instanceof HTMLElement))\n    );\n  }\n\n  /** parent: the context in which events attached to non-HTMLElements are called */\n  public constructor(parent: any) {\n    this._parent = parent;\n    this._eventRecords = [];\n  }\n\n  public dispose(): void {\n    if (!this._isDisposed) {\n      this._isDisposed = true;\n\n      this.off();\n      this._parent = null;\n    }\n  }\n\n  /** On the target, attach a set of events, where the events object is a name to function mapping. */\n  public onAll(target: any, events: { [key: string]: (args?: any) => void }, useCapture?: boolean): void {\n    for (let eventName in events) {\n      if (events.hasOwnProperty(eventName)) {\n        this.on(target, eventName, events[eventName], useCapture);\n      }\n    }\n  }\n\n  /**\n   * On the target, attach an event whose handler will be called in the context of the parent\n   * of this instance of EventGroup.\n   */\n  public on(\n    target: any,\n    eventName: string,\n    callback: (args?: any) => void,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    if (eventName.indexOf(',') > -1) {\n      let events = eventName.split(/[ ,]+/);\n\n      for (let i = 0; i < events.length; i++) {\n        this.on(target, events[i], callback, options);\n      }\n    } else {\n      let parent = this._parent;\n      let eventRecord: IEventRecord = {\n        target,\n        eventName,\n        parent,\n        callback,\n        options,\n      };\n\n      // Initialize and wire up the record on the target, so that it can call the callback if the event fires.\n      let events = <IEventRecordsByName>(target.__events__ = target.__events__ || {});\n      events[eventName] =\n        events[eventName] ||\n        <IEventRecordList>{\n          count: 0,\n        };\n      events[eventName][this._id] = events[eventName][this._id] || [];\n      (<IEventRecord[]>events[eventName][this._id]).push(eventRecord);\n      events[eventName].count++;\n\n      if (EventGroup._isElement(target)) {\n        let processElementEvent = (...args: any[]) => {\n          if (this._isDisposed) {\n            return;\n          }\n\n          let result;\n          try {\n            result = callback.apply(parent, args);\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore  -- FIXME: strictBindCallApply error - https://github.com/microsoft/fluentui/issues/17331\n            if (result === false && args[0]) {\n              let e = args[0];\n\n              if (e.preventDefault) {\n                e.preventDefault();\n              }\n\n              if (e.stopPropagation) {\n                e.stopPropagation();\n              }\n\n              e.cancelBubble = true;\n            }\n          } catch (e) {\n            // ignore\n          }\n\n          return result;\n        };\n\n        eventRecord.elementCallback = processElementEvent;\n\n        if (target.addEventListener) {\n          (<EventTarget>target).addEventListener(eventName, processElementEvent, options);\n        } else if (target.attachEvent) {\n          // IE8\n          target.attachEvent('on' + eventName, processElementEvent);\n        }\n      } else {\n        let processObjectEvent = (...args: any[]) => {\n          if (this._isDisposed) {\n            return;\n          }\n\n          return callback.apply(parent, args);\n        };\n\n        eventRecord.objectCallback = processObjectEvent;\n      }\n\n      // Remember the record locally, so that it can be removed.\n      this._eventRecords.push(eventRecord);\n    }\n  }\n\n  public off(\n    target?: any,\n    eventName?: string,\n    callback?: (args?: any) => void,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    for (let i = 0; i < this._eventRecords.length; i++) {\n      let eventRecord = this._eventRecords[i];\n      if (\n        (!target || target === eventRecord.target) &&\n        (!eventName || eventName === eventRecord.eventName) &&\n        (!callback || callback === eventRecord.callback) &&\n        (typeof options !== 'boolean' || options === eventRecord.options)\n      ) {\n        let events = <IEventRecordsByName>eventRecord.target.__events__;\n        let targetArrayLookup = events[eventRecord.eventName];\n        let targetArray = targetArrayLookup ? <IEventRecord[]>targetArrayLookup[this._id] : null;\n\n        // We may have already target's entries, so check for null.\n        if (targetArray) {\n          if (targetArray.length === 1 || !callback) {\n            targetArrayLookup.count -= targetArray.length;\n            delete events[eventRecord.eventName][this._id];\n          } else {\n            targetArrayLookup.count--;\n            targetArray.splice(targetArray.indexOf(eventRecord), 1);\n          }\n\n          if (!targetArrayLookup.count) {\n            delete events[eventRecord.eventName];\n          }\n        }\n\n        if (eventRecord.elementCallback) {\n          if (eventRecord.target.removeEventListener) {\n            eventRecord.target.removeEventListener(\n              eventRecord.eventName,\n              eventRecord.elementCallback,\n              eventRecord.options,\n            );\n          } else if (eventRecord.target.detachEvent) {\n            // IE8\n            eventRecord.target.detachEvent('on' + eventRecord.eventName, eventRecord.elementCallback);\n          }\n        }\n\n        this._eventRecords.splice(i--, 1);\n      }\n    }\n  }\n\n  /** Trigger the given event in the context of this instance of EventGroup. */\n  public raise(eventName: string, eventArgs?: any, bubbleEvent?: boolean): boolean | undefined {\n    return EventGroup.raise(this._parent, eventName, eventArgs, bubbleEvent);\n  }\n\n  /** Declare an event as being supported by this instance of EventGroup. */\n  public declare(event: string | string[]): void {\n    let declaredEvents = (this._parent.__declaredEvents = this._parent.__declaredEvents || {});\n\n    if (typeof event === 'string') {\n      declaredEvents[event] = true;\n    } else {\n      for (let i = 0; i < event.length; i++) {\n        declaredEvents[event[i]] = true;\n      }\n    }\n  }\n}\n", "// eslint-disable-next-line @typescript-eslint/naming-convention\nexport interface ShadowConfig {\n  stylesheetKey: string;\n  inShadow: boolean;\n  window?: Window;\n  __isShadowConfig__: true;\n}\n\nexport const GLOBAL_STYLESHEET_KEY = '__global__';\nexport const SHADOW_DOM_STYLESHEET_SETTING = '__shadow_dom_stylesheet__';\n\nexport const DEFAULT_SHADOW_CONFIG: ShadowConfig = {\n  stylesheetKey: GLOBAL_STYLESHEET_KEY,\n  inShadow: false,\n  window: undefined,\n  __isShadowConfig__: true,\n};\n\nexport const makeShadowConfig = (stylesheetKey: string, inShadow: boolean, window?: Window): ShadowConfig => {\n  return {\n    stylesheetKey,\n    inShadow,\n    window,\n    __isShadowConfig__: true,\n  };\n};\n\nexport const isShadowConfig = (value: unknown): value is ShadowConfig => {\n  if (!(value && isRecord(value))) {\n    return false;\n  }\n\n  return value.__isShadowConfig__ === true;\n};\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return value !== null && typeof value === 'object' && !Array.isArray(value);\n}\n", "import { IStyle, IStyleBaseArray } from './IStyle';\nimport { Stylesheet } from './Stylesheet';\nimport { isShadowConfig } from './shadowConfig';\n\n/**\n * Separates the classes and style objects. Any classes that are pre-registered\n * args are auto expanded into objects.\n */\nexport function extractStyleParts(\n  sheet: Stylesheet,\n  ...args: (IStyle | IStyle[] | false | null | undefined)[]\n): {\n  classes: string[];\n  objects: IStyleBaseArray;\n} {\n  const classes: string[] = [];\n  const objects: {}[] = [];\n  const stylesheet = sheet;\n\n  function _processArgs(argsList: (IStyle | IStyle[])[]): void {\n    for (const arg of argsList) {\n      if (arg && !isShadowConfig(arg)) {\n        if (typeof arg === 'string') {\n          if (arg.indexOf(' ') >= 0) {\n            _processArgs(arg.split(' '));\n          } else {\n            const translatedArgs = stylesheet.argsFromClassName(arg);\n\n            if (translatedArgs) {\n              _processArgs(translatedArgs);\n            } else {\n              // Avoid adding the same class twice.\n              if (classes.indexOf(arg) === -1) {\n                classes.push(arg);\n              }\n            }\n          }\n        } else if (Array.isArray(arg)) {\n          _processArgs(arg);\n        } else if (typeof arg === 'object') {\n          objects.push(arg);\n        }\n      }\n    }\n  }\n\n  _processArgs(args);\n\n  return {\n    classes,\n    objects,\n  };\n}\n", "import { IStyleOptions } from './IStyleOptions';\nimport { DEFAULT_SHADOW_CONFIG } from './shadowConfig';\n\n/**\n * Sets the current RTL value.\n */\nexport function setRTL(isRTL: boolean): void {\n  if (_rtl !== isRTL) {\n    _rtl = isRTL;\n  }\n}\n\n/**\n * Gets the current RTL value.\n */\nexport function getRTL(): boolean {\n  if (_rtl === undefined) {\n    _rtl =\n      // eslint-disable-next-line no-restricted-globals\n      typeof document !== 'undefined' &&\n      // eslint-disable-next-line no-restricted-globals\n      !!document.documentElement &&\n      // eslint-disable-next-line no-restricted-globals\n      document.documentElement.getAttribute('dir') === 'rtl';\n  }\n  return _rtl;\n}\n\n// This has been split into 2 lines because it was working in Fabric due to the code being transpiled to es5, so this\n// was converted to var while not working in Fluent that uses babel to transpile the code to be es6-like. Splitting the\n// logic into two lines, however, allows it to work in both scenarios.\nlet _rtl: boolean;\n_rtl = getRTL();\n\nexport function getStyleOptions(): IStyleOptions {\n  return {\n    rtl: getRTL(),\n    shadowConfig: DEFAULT_SHADOW_CONFIG,\n  };\n}\n", "/* eslint no-restricted-globals: 0 */\n// globals in stylesheets will be addressed as part of shadow DOM work.\n// See: https://github.com/microsoft/fluentui/issues/28058\nimport { IStyle } from './IStyle';\nimport { GLOBAL_STYLESHEET_KEY, SHADOW_DOM_STYLESHEET_SETTING } from './shadowConfig';\nimport type { ShadowConfig } from './shadowConfig';\n\nexport const InjectionMode = {\n  /**\n   * Avoids style injection, use getRules() to read the styles.\n   */\n  none: 0 as 0,\n\n  /**\n   * Inserts rules using the insertRule api.\n   */\n  insertNode: 1 as 1,\n\n  /**\n   * Appends rules using appendChild.\n   */\n  appendChild: 2 as 2,\n};\n\nexport type InjectionMode = (typeof InjectionMode)[keyof typeof InjectionMode];\n\n/**\n * CSP settings for the stylesheet\n */\nexport interface ICSPSettings {\n  /**\n   * Nonce to inject into script tag\n   */\n  nonce?: string;\n}\n\n/**\n * Stylesheet config.\n *\n * @public\n */\nexport interface IStyleSheetConfig {\n  /**\n   * Injection mode for how rules are inserted.\n   */\n  injectionMode?: InjectionMode;\n\n  /**\n   * Default 'displayName' to use for a className.\n   * @defaultvalue 'css'\n   */\n  defaultPrefix?: string;\n\n  /**\n   * Defines the default direction of rules for auto-rtlifying things.\n   * While typically this is represented as a DIR attribute in the markup,\n   * the DIR is not enough to control whether padding goes on the left or\n   * right. Use this to set the default direction when rules are registered.\n   */\n  rtl?: boolean;\n\n  /**\n   * Default 'namespace' to attach before the className.\n   */\n  namespace?: string;\n\n  /**\n   * CSP settings\n   */\n  cspSettings?: ICSPSettings;\n\n  /**\n   * Callback executed when a rule is inserted.\n   * @deprecated Use `Stylesheet.onInsertRule` instead.\n   */\n  onInsertRule?: (rule: string) => void;\n\n  /**\n   * Initial value for classnames cache. Key is serialized css rules associated with a classname.\n   */\n  classNameCache?: { [key: string]: string };\n\n  window?: Window;\n\n  inShadow?: boolean;\n\n  stylesheetKey?: string;\n}\n\n/**\n * Representation of Stylesheet used for rehydration.\n */\nexport interface ISerializedStylesheet {\n  classNameToArgs: Stylesheet['_classNameToArgs'];\n  counter: Stylesheet['_counter'];\n  keyToClassName: Stylesheet['_keyToClassName'];\n  preservedRules: Stylesheet['_preservedRules'];\n  rules: Stylesheet['_rules'];\n}\n\nexport const STYLESHEET_SETTING = '__stylesheet__';\n\n/**\n * MSIE 11 doesn't cascade styles based on DOM ordering, but rather on the order that each style node\n * is created. As such, to maintain consistent priority, IE11 should reuse a single style node.\n */\nconst REUSE_STYLE_NODE = typeof navigator !== 'undefined' && /rv:11.0/.test(navigator.userAgent);\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  interface Document {\n    adoptedStyleSheets: CSSStyleSheet[];\n  }\n}\n\nexport type WindowWithMergeStyles = (Window | {}) & {\n  [STYLESHEET_SETTING]?: Stylesheet;\n  [SHADOW_DOM_STYLESHEET_SETTING]?: typeof Stylesheet;\n  FabricConfig?: {\n    mergeStyles?: IStyleSheetConfig;\n    serializedStylesheet?: ISerializedStylesheet;\n  };\n};\n\nlet _global: WindowWithMergeStyles = {};\n\n// Grab window.\ntry {\n  // Why the cast?\n  // if compiled/type checked in same program with `@fluentui/font-icons-mdl2` which extends `Window` on global\n  // ( check packages/font-icons-mdl2/src/index.ts ) the definitions don't match! Thus the need of this extra assertion\n  _global = (window || {}) as WindowWithMergeStyles;\n} catch {\n  /* leave as blank object */\n}\n\nlet _stylesheet: Stylesheet | undefined;\n\nexport type ExtendedCSSStyleSheet = CSSStyleSheet & {\n  bucketName: string;\n  metadata: Record<string, unknown>;\n};\n\ntype InsertRuleArgs = {\n  key?: string;\n  sheet?: ExtendedCSSStyleSheet | null;\n  rule?: string;\n};\n\nexport type InsertRuleCallback = ({ key, sheet, rule }: InsertRuleArgs) => void;\n\n/**\n * Represents the state of styles registered in the page. Abstracts\n * the surface for adding styles to the stylesheet, exposes helpers\n * for reading the styles registered in server rendered scenarios.\n *\n * @public\n */\nexport class Stylesheet {\n  protected _lastStyleElement?: HTMLStyleElement;\n  protected _config: IStyleSheetConfig;\n\n  private _styleElement?: HTMLStyleElement;\n\n  private _rules: string[] = [];\n  private _preservedRules: string[] = [];\n  private _counter = 0;\n  private _keyToClassName: { [key: string]: string } = {};\n  private _onInsertRuleCallbacks: (Function | InsertRuleCallback)[] = [];\n  private _onResetCallbacks: Function[] = [];\n  private _classNameToArgs: { [key: string]: { args: any; rules: string[] } } = {};\n\n  /**\n   * Gets the singleton instance.\n   */\n  public static getInstance(shadowConfig?: ShadowConfig): Stylesheet {\n    _stylesheet = _global[STYLESHEET_SETTING] as Stylesheet;\n\n    if (_global[SHADOW_DOM_STYLESHEET_SETTING]) {\n      return _global[SHADOW_DOM_STYLESHEET_SETTING].getInstance(shadowConfig);\n    }\n\n    if (!_stylesheet || (_stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document)) {\n      const fabricConfig = _global?.FabricConfig || {};\n\n      const stylesheet = new Stylesheet(fabricConfig.mergeStyles, fabricConfig.serializedStylesheet);\n      _stylesheet = stylesheet;\n      _global[STYLESHEET_SETTING] = stylesheet;\n    }\n\n    return _stylesheet;\n  }\n\n  constructor(config?: IStyleSheetConfig, serializedStylesheet?: ISerializedStylesheet) {\n    // If there is no document we won't have an element to inject into.\n    this._config = {\n      injectionMode: typeof document === 'undefined' ? InjectionMode.none : InjectionMode.insertNode,\n      defaultPrefix: 'css',\n      namespace: undefined,\n      cspSettings: undefined,\n      ...config,\n    };\n\n    this._classNameToArgs = serializedStylesheet?.classNameToArgs ?? this._classNameToArgs;\n    this._counter = serializedStylesheet?.counter ?? this._counter;\n    this._keyToClassName = this._config.classNameCache ?? serializedStylesheet?.keyToClassName ?? this._keyToClassName;\n    this._preservedRules = serializedStylesheet?.preservedRules ?? this._preservedRules;\n    this._rules = serializedStylesheet?.rules ?? this._rules;\n  }\n\n  /**\n   * Serializes the Stylesheet instance into a format which allows rehydration on creation.\n   * @returns string representation of `ISerializedStylesheet` interface.\n   */\n  public serialize(): string {\n    return JSON.stringify({\n      classNameToArgs: this._classNameToArgs,\n      counter: this._counter,\n      keyToClassName: this._keyToClassName,\n      preservedRules: this._preservedRules,\n      rules: this._rules,\n    });\n  }\n\n  /**\n   * Configures the stylesheet.\n   */\n  public setConfig(config?: IStyleSheetConfig): void {\n    this._config = {\n      ...this._config,\n      ...config,\n    };\n  }\n\n  /**\n   * Configures a reset callback.\n   *\n   * @param callback - A callback which will be called when the Stylesheet is reset.\n   * @returns function which when called un-registers provided callback.\n   */\n  public onReset(callback: Function): Function {\n    this._onResetCallbacks.push(callback);\n\n    return () => {\n      this._onResetCallbacks = this._onResetCallbacks.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Configures an insert rule callback.\n   *\n   * @param callback - A callback which will be called when a rule is inserted.\n   * @returns function which when called un-registers provided callback.\n   */\n  public onInsertRule(callback: Function | InsertRuleCallback): Function {\n    this._onInsertRuleCallbacks.push(callback);\n\n    return () => {\n      this._onInsertRuleCallbacks = this._onInsertRuleCallbacks.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Generates a unique classname.\n   *\n   * @param displayName - Optional value to use as a prefix.\n   */\n  public getClassName(displayName?: string): string {\n    const { namespace } = this._config;\n    const prefix = displayName || this._config.defaultPrefix;\n\n    return `${namespace ? namespace + '-' : ''}${prefix}-${this._counter++}`;\n  }\n\n  /**\n   * Used internally to cache information about a class which was\n   * registered with the stylesheet.\n   */\n  public cacheClassName(className: string, key: string, args: IStyle[], rules: string[]): void {\n    this._keyToClassName[this._getCacheKey(key)] = className;\n    this._classNameToArgs[className] = {\n      args,\n      rules,\n    };\n  }\n\n  /**\n   * Gets the appropriate classname given a key which was previously\n   * registered using cacheClassName.\n   */\n  public classNameFromKey(key: string): string | undefined {\n    return this._keyToClassName[this._getCacheKey(key)];\n  }\n\n  /**\n   * Gets all classnames cache with the stylesheet.\n   */\n  public getClassNameCache(): { [key: string]: string } {\n    return this._keyToClassName;\n  }\n\n  /**\n   * Gets the arguments associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n  public argsFromClassName(className: string): IStyle[] | undefined {\n    const entry = this._classNameToArgs[className];\n\n    return entry && entry.args;\n  }\n\n  /**\n   * Gets the rules associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n  public insertedRulesFromClassName(className: string): string[] | undefined {\n    const entry = this._classNameToArgs[className];\n\n    return entry && entry.rules;\n  }\n\n  /**\n   * Inserts a css rule into the stylesheet.\n   * @param preserve - Preserves the rule beyond a reset boundary.\n   */\n  public insertRule(rule: string, preserve?: boolean, stylesheetKey: string = GLOBAL_STYLESHEET_KEY): void {\n    const { injectionMode } = this._config;\n\n    const element: HTMLStyleElement | undefined =\n      injectionMode !== InjectionMode.none ? this._getStyleElement() : undefined;\n\n    if (preserve) {\n      this._preservedRules.push(rule);\n    }\n\n    if (element) {\n      switch (injectionMode) {\n        case InjectionMode.insertNode:\n          this._insertRuleIntoSheet(element.sheet, rule);\n          break;\n\n        case InjectionMode.appendChild:\n          (element as HTMLStyleElement).appendChild(document.createTextNode(rule));\n          break;\n      }\n    } else {\n      this._rules.push(rule);\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (this._config.onInsertRule) {\n      // eslint-disable-next-line deprecation/deprecation\n      this._config.onInsertRule(rule);\n    }\n\n    this._onInsertRuleCallbacks.forEach(callback =>\n      callback({ key: stylesheetKey, sheet: (element ? element.sheet : undefined) as ExtendedCSSStyleSheet, rule }),\n    );\n  }\n\n  /**\n   * Gets all rules registered with the stylesheet; only valid when\n   * using InsertionMode.none.\n   */\n  public getRules(includePreservedRules?: boolean): string {\n    return (includePreservedRules ? this._preservedRules.join('') : '') + this._rules.join('');\n  }\n\n  /**\n   * Resets the internal state of the stylesheet. Only used in server\n   * rendered scenarios where we're using InsertionMode.none.\n   */\n  public reset(): void {\n    this._rules = [];\n    this._counter = 0;\n    this._classNameToArgs = {};\n    this._keyToClassName = {};\n\n    this._onResetCallbacks.forEach(callback => callback());\n  }\n\n  // Forces the regeneration of incoming styles without totally resetting the stylesheet.\n  public resetKeys(): void {\n    this._keyToClassName = {};\n  }\n\n  protected _createStyleElement(): HTMLStyleElement {\n    const doc = this._config.window?.document || document;\n    const head: HTMLHeadElement = doc.head;\n    const styleElement = doc.createElement('style');\n    let nodeToInsertBefore: Node | null = null;\n\n    styleElement.setAttribute('data-merge-styles', 'true');\n\n    const { cspSettings } = this._config;\n    if (cspSettings) {\n      if (cspSettings.nonce) {\n        styleElement.setAttribute('nonce', cspSettings.nonce);\n      }\n    }\n    if (this._lastStyleElement) {\n      // If the `nextElementSibling` is null, then the insertBefore will act as a regular append.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore#Syntax\n      nodeToInsertBefore = this._lastStyleElement.nextElementSibling;\n    } else {\n      const placeholderStyleTag: Element | null = this._findPlaceholderStyleTag();\n\n      if (placeholderStyleTag) {\n        nodeToInsertBefore = placeholderStyleTag.nextElementSibling;\n      } else {\n        nodeToInsertBefore = head.childNodes[0];\n      }\n    }\n\n    head!.insertBefore(styleElement, head!.contains(nodeToInsertBefore) ? nodeToInsertBefore : null);\n    this._lastStyleElement = styleElement;\n\n    return styleElement;\n  }\n\n  protected _insertRuleIntoSheet(sheet: CSSStyleSheet | undefined | null, rule: string): boolean {\n    if (!sheet) {\n      return false;\n    }\n\n    try {\n      sheet!.insertRule(rule, sheet!.cssRules.length);\n      return true;\n    } catch (e) {\n      // The browser will throw exceptions on unsupported rules (such as a moz prefix in webkit.)\n      // We need to swallow the exceptions for this scenario, otherwise we'd need to filter\n      // which could be slower and bulkier.\n    }\n\n    return false;\n  }\n\n  protected _getCacheKey(key: string): string {\n    return key;\n  }\n\n  private _getStyleElement(): HTMLStyleElement | undefined {\n    if (!this._styleElement) {\n      this._styleElement = this._createStyleElement();\n\n      if (!REUSE_STYLE_NODE) {\n        // Reset the style element on the next frame.\n        const win = this._config.window || window;\n        win.requestAnimationFrame(() => {\n          this._styleElement = undefined;\n        });\n      }\n    }\n    return this._styleElement;\n  }\n\n  private _findPlaceholderStyleTag(): Element | null {\n    const head: HTMLHeadElement = document.head;\n    if (head) {\n      return head.querySelector('style[data-merge-styles]');\n    }\n    return null;\n  }\n}\n", "const rules: { [key: string]: string } = {};\n\nexport function kebabRules(rulePairs: (string | number)[], index: number): void {\n  const rule: string = rulePairs[index] as string;\n\n  if (rule.charAt(0) !== '-') {\n    rulePairs[index] = rules[rule] = rules[rule] || rule.replace(/([A-Z])/g, '-$1').toLowerCase();\n  }\n}\n", "export interface IVendorSettings {\n  isWebkit?: boolean;\n  isMoz?: boolean;\n  isMs?: boolean;\n  isOpera?: boolean;\n}\n\nlet _vendorSettings: IVendorSettings | undefined;\n\nexport function getVendorSettings(): IVendorSettings {\n  if (!_vendorSettings) {\n    // eslint-disable-next-line no-restricted-globals\n    const doc = typeof document !== 'undefined' ? document : undefined;\n    const nav = typeof navigator !== 'undefined' ? navigator : undefined;\n    const userAgent = nav?.userAgent?.toLowerCase();\n\n    if (!doc) {\n      _vendorSettings = {\n        isWebkit: true,\n        isMoz: true,\n        isOpera: true,\n        isMs: true,\n      };\n    } else {\n      _vendorSettings = {\n        isWebkit: !!(doc && 'WebkitAppearance' in doc.documentElement.style),\n        isMoz: !!(userAgent && userAgent.indexOf('firefox') > -1),\n        isOpera: !!(userAgent && userAgent.indexOf('opera') > -1),\n        isMs: !!(nav && (/rv:11.0/i.test(nav.userAgent) || /Edge\\/\\d./i.test(navigator.userAgent))),\n      };\n    }\n  }\n\n  return _vendorSettings;\n}\n\n/**\n * Sets the vendor settings for prefixing and vendor specific operations.\n */\nexport function setVendorSettings(vendorSettings?: IVendorSettings): void {\n  _vendorSettings = vendorSettings;\n}\n", "import { getVendorSettings } from '../getVendorSettings';\n\nconst autoPrefixNames: { [key: string]: number } = {\n  'user-select': 1,\n};\n\nexport function prefixRules(rulePairs: (string | number)[], index: number): void {\n  const vendorSettings = getVendorSettings();\n\n  const name = rulePairs[index];\n\n  if (autoPrefixNames[name]) {\n    const value = rulePairs[index + 1];\n\n    if (autoPrefixNames[name]) {\n      if (vendorSettings.isWebkit) {\n        rulePairs.push('-webkit-' + name, value);\n      }\n      if (vendorSettings.isMoz) {\n        rulePairs.push('-moz-' + name, value);\n      }\n      if (vendorSettings.isMs) {\n        rulePairs.push('-ms-' + name, value);\n      }\n      if (vendorSettings.isOpera) {\n        rulePairs.push('-o-' + name, value);\n      }\n    }\n  }\n}\n", "const NON_PIXEL_NUMBER_PROPS = [\n  'column-count',\n  'font-weight',\n  'flex',\n  'flex-grow',\n  'flex-shrink',\n  'fill-opacity',\n  'opacity',\n  'order',\n  'z-index',\n  'zoom',\n];\n\nexport function provideUnits(rulePairs: (string | number)[], index: number): void {\n  const name = rulePairs[index] as string;\n  const value = rulePairs[index + 1];\n\n  if (typeof value === 'number') {\n    const isNonPixelProp = NON_PIXEL_NUMBER_PROPS.indexOf(name as string) > -1;\n    const isVariableOrPrefixed = name.indexOf('--') > -1;\n    const unit = isNonPixelProp || isVariableOrPrefixed ? '' : 'px';\n\n    rulePairs[index + 1] = `${value}${unit}`;\n  }\n}\n", "import { IStyleOptions } from '../IStyleOptions';\n\nconst LEFT = 'left';\nconst RIGHT = 'right';\nconst NO_FLIP = '@noflip';\nconst NAME_REPLACEMENTS: { [key: string]: string } = {\n  [LEFT]: RIGHT,\n  [RIGHT]: LEFT,\n};\nconst VALUE_REPLACEMENTS: { [key: string]: string } = {\n  'w-resize': 'e-resize',\n  'sw-resize': 'se-resize',\n  'nw-resize': 'ne-resize',\n};\n\n/**\n * RTLifies the rulePair in the array at the current index. This mutates the array for performance\n * reasons.\n */\nexport function rtlifyRules(options: IStyleOptions, rulePairs: (string | number)[], index: number): void {\n  if (options.rtl) {\n    const name = rulePairs[index] as string;\n\n    if (!name) {\n      return;\n    }\n\n    const value = rulePairs[index + 1] as string;\n\n    if (typeof value === 'string' && value.indexOf(NO_FLIP) >= 0) {\n      rulePairs[index + 1] = value.replace(/\\s*(?:\\/\\*\\s*)?\\@noflip\\b(?:\\s*\\*\\/)?\\s*?/g, '');\n    } else if (name.indexOf(LEFT) >= 0) {\n      rulePairs[index] = name.replace(LEFT, RIGHT);\n    } else if (name.indexOf(RIGHT) >= 0) {\n      rulePairs[index] = name.replace(RIGHT, LEFT);\n    } else if (String(value).indexOf(LEFT) >= 0) {\n      rulePairs[index + 1] = value.replace(LEFT, RIGHT);\n    } else if (String(value).indexOf(RIGHT) >= 0) {\n      rulePairs[index + 1] = value.replace(RIGHT, LEFT);\n    } else if (NAME_REPLACEMENTS[name]) {\n      rulePairs[index] = NAME_REPLACEMENTS[name];\n    } else if (VALUE_REPLACEMENTS[value]) {\n      rulePairs[index + 1] = VALUE_REPLACEMENTS[value];\n    } else {\n      switch (name) {\n        case 'margin':\n        case 'padding':\n          rulePairs[index + 1] = flipQuad(value);\n          break;\n        case 'box-shadow':\n          rulePairs[index + 1] = negateNum(value, 0);\n          break;\n      }\n    }\n  }\n}\n\n/**\n * Given a string value in a space delimited format (e.g. \"1 2 3 4\"), negates a particular value.\n */\nfunction negateNum(value: string, partIndex: number): string {\n  const parts = value.split(' ');\n  const numberVal = parseInt(parts[partIndex], 10);\n\n  parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));\n\n  return parts.join(' ');\n}\n\n/**\n * Given a string quad, flips the left and right values.\n */\nfunction flipQuad(value: string): string {\n  if (typeof value === 'string') {\n    const parts = value.split(' ');\n\n    if (parts.length === 4) {\n      return `${parts[0]} ${parts[3]} ${parts[2]} ${parts[1]}`;\n    }\n  }\n\n  return value;\n}\n", "/**\n * Split a string into tokens separated by whitespace, except all text within parentheses\n * is treated as a single token (whitespace is ignored within parentheses).\n *\n * Unlike String.split(' '), multiple consecutive space characters are collapsed and\n * removed from the returned array (including leading and trailing spaces).\n *\n * For example:\n * `tokenizeWithParentheses(\"3px calc(var(--x) / 2) 9px    0 \")`\n *   => `[\"3px\", \"calc(var(--x) / 2)\", \"9px\", \"0\"]`\n *\n * @returns The array of tokens. Returns an empty array if the string was empty or contained only whitespace.\n */\nexport function tokenizeWithParentheses(value: string): string[] {\n  const parts = [];\n  let partStart = 0;\n  let parens = 0;\n\n  for (let i = 0; i < value.length; i++) {\n    switch (value[i]) {\n      case '(':\n        parens++;\n        break;\n      case ')':\n        if (parens) {\n          parens--;\n        }\n        break;\n      case '\\t':\n      case ' ':\n        if (!parens) {\n          // Add the new part if it's not an empty string\n          if (i > partStart) {\n            parts.push(value.substring(partStart, i));\n          }\n          partStart = i + 1;\n        }\n        break;\n    }\n  }\n\n  // Add the last part\n  if (partStart < value.length) {\n    parts.push(value.substring(partStart));\n  }\n\n  return parts;\n}\n", "import { IStyle } from './IStyle';\nimport { IRawStyle } from './IRawStyle';\n\nimport { Stylesheet } from './Stylesheet';\nimport { kebabRules } from './transforms/kebabRules';\nimport { prefixRules } from './transforms/prefixRules';\nimport { provideUnits } from './transforms/provideUnits';\nimport { rtlifyRules } from './transforms/rtlifyRules';\nimport { IStyleOptions } from './IStyleOptions';\nimport { tokenizeWithParentheses } from './tokenizeWithParentheses';\nimport { ShadowConfig } from './shadowConfig';\n\nconst DISPLAY_NAME = 'displayName';\n\ntype IDictionary = { [key: string]: any };\n\ninterface IRuleSet {\n  __order: string[];\n  [key: string]: IDictionary;\n}\n\nfunction getDisplayName(rules?: { [key: string]: IRawStyle }): string | undefined {\n  const rootStyle: IStyle = rules && rules['&'];\n\n  return rootStyle ? (rootStyle as IRawStyle).displayName : undefined;\n}\n\nconst globalSelectorRegExp = /\\:global\\((.+?)\\)/g;\n\ntype ReplacementInfo = [number, number, string];\n\n/**\n * Finds comma separated selectors in a :global() e.g. \":global(.class1, .class2, .class3)\"\n * and wraps them each in their own global \":global(.class1), :global(.class2), :global(.class3)\"\n *\n * @param selectorWithGlobals The selector to process\n * @returns The updated selector\n */\nfunction expandCommaSeparatedGlobals(selectorWithGlobals: string): string {\n  // We the selector does not have a :global() we can shortcut\n  if (!globalSelectorRegExp.test(selectorWithGlobals)) {\n    return selectorWithGlobals;\n  }\n\n  const replacementInfo: ReplacementInfo[] = [];\n\n  const findGlobal = /\\:global\\((.+?)\\)/g;\n  let match = null;\n  // Create a result list for global selectors so we can replace them.\n  while ((match = findGlobal.exec(selectorWithGlobals))) {\n    // Only if the found selector is a comma separated list we'll process it.\n    if (match[1].indexOf(',') > -1) {\n      replacementInfo.push([\n        match.index,\n        match.index + match[0].length,\n        // Wrap each of the found selectors in :global()\n        match[1]\n          .split(',')\n          .map((v: string) => `:global(${v.trim()})`)\n          .join(', '),\n      ]);\n    }\n  }\n\n  // Replace the found selectors with their wrapped variants in reverse order\n  return replacementInfo\n    .reverse()\n    .reduce((selector: string, [matchIndex, matchEndIndex, replacement]: ReplacementInfo) => {\n      const prefix = selector.slice(0, matchIndex);\n      const suffix = selector.slice(matchEndIndex);\n\n      return prefix + replacement + suffix;\n    }, selectorWithGlobals);\n}\n\nfunction isSelector(potentialSelector: string): boolean {\n  return potentialSelector.indexOf(':global(') >= 0 || potentialSelector.indexOf(':') === 0;\n}\n\nfunction expandSelector(newSelector: string, currentSelector: string): string {\n  if (newSelector.indexOf(':global(') >= 0) {\n    return newSelector.replace(globalSelectorRegExp, '$1');\n  } else if (newSelector.indexOf(':host(') === 0) {\n    return newSelector;\n  } else if (newSelector.indexOf(':') === 0) {\n    return currentSelector + newSelector;\n  } else if (newSelector.indexOf('&') < 0) {\n    return currentSelector + ' ' + newSelector;\n  }\n\n  return newSelector;\n}\n\nfunction extractSelector(\n  currentSelector: string,\n  rules: IRuleSet = { __order: [] },\n  selector: string,\n  value: IStyle,\n  stylesheet: Stylesheet,\n) {\n  if (selector.indexOf('@') === 0) {\n    selector = selector + '{' + currentSelector;\n    extractRules([value], rules, selector, stylesheet);\n  } else if (selector.indexOf(',') > -1) {\n    expandCommaSeparatedGlobals(selector)\n      .split(',')\n      .map((s: string) => s.trim())\n      .forEach((separatedSelector: string) =>\n        extractRules([value], rules, expandSelector(separatedSelector, currentSelector), stylesheet),\n      );\n  } else {\n    extractRules([value], rules, expandSelector(selector, currentSelector), stylesheet);\n  }\n}\n\nfunction extractRules(\n  args: IStyle[],\n  rules: IRuleSet = { __order: [] },\n  currentSelector: string = '&',\n  stylesheet: Stylesheet,\n): IRuleSet {\n  let currentRules: IDictionary | undefined = rules[currentSelector] as IDictionary;\n\n  if (!currentRules) {\n    currentRules = {};\n    rules[currentSelector] = currentRules;\n    rules.__order.push(currentSelector);\n  }\n\n  for (const arg of args) {\n    // If the arg is a string, we need to look up the class map and merge.\n    if (typeof arg === 'string') {\n      const expandedRules = stylesheet.argsFromClassName(arg);\n\n      if (expandedRules) {\n        extractRules(expandedRules, rules, currentSelector, stylesheet);\n      }\n      // Else if the arg is an array, we need to recurse in.\n    } else if (Array.isArray(arg)) {\n      extractRules(arg, rules, currentSelector, stylesheet);\n    } else {\n      for (const prop in arg as any) {\n        if ((arg as any).hasOwnProperty(prop)) {\n          const propValue = (arg as any)[prop];\n          if (prop === 'selectors') {\n            // every child is a selector.\n            const selectors: { [key: string]: IStyle } = (arg as any).selectors;\n\n            for (const newSelector in selectors) {\n              if (selectors.hasOwnProperty(newSelector)) {\n                extractSelector(currentSelector, rules, newSelector, selectors[newSelector], stylesheet);\n              }\n            }\n          } else if (typeof propValue === 'object' || isSelector(prop)) {\n            // prop is a selector.\n            if (propValue !== null && propValue !== undefined) {\n              extractSelector(currentSelector, rules, prop, propValue, stylesheet);\n            }\n          } else {\n            if (propValue !== undefined) {\n              // Else, add the rule to the currentSelector.\n              if (prop === 'margin' || prop === 'padding') {\n                expandQuads(currentRules, prop, propValue);\n              } else {\n                (currentRules as any)[prop] = propValue;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return rules;\n}\n\nfunction expandQuads(currentRules: IDictionary, name: string, value: string): void {\n  let parts = typeof value === 'string' ? tokenizeWithParentheses(value) : [value];\n\n  if (parts.length === 0) {\n    parts.push(value);\n  }\n\n  if (parts[parts.length - 1] === '!important') {\n    // Remove !important from parts, and append it to each part individually\n    parts = parts.slice(0, -1).map(p => p + ' !important');\n  }\n\n  currentRules[name + 'Top'] = parts[0];\n  currentRules[name + 'Right'] = parts[1] || parts[0];\n  currentRules[name + 'Bottom'] = parts[2] || parts[0];\n  currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];\n}\n\nfunction getKeyForRules(options: IStyleOptions, rules: IRuleSet): string | undefined {\n  const serialized: string[] = [options.rtl ? 'rtl' : 'ltr'];\n  let hasProps = false;\n\n  for (const selector of rules.__order) {\n    serialized.push(selector);\n    const rulesForSelector = rules[selector];\n\n    for (const propName in rulesForSelector) {\n      if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== undefined) {\n        hasProps = true;\n        serialized.push(propName, rulesForSelector[propName]);\n      }\n    }\n  }\n\n  return hasProps ? serialized.join('') : undefined;\n}\n\nfunction repeatString(target: string, count: number): string {\n  if (count <= 0) {\n    return '';\n  }\n\n  if (count === 1) {\n    return target;\n  }\n\n  return target + repeatString(target, count - 1);\n}\n\nexport function serializeRuleEntries(options: IStyleOptions, ruleEntries: { [key: string]: string | number }): string {\n  if (!ruleEntries) {\n    return '';\n  }\n\n  const allEntries: (string | number)[] = [];\n\n  for (const entry in ruleEntries) {\n    if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== undefined) {\n      allEntries.push(entry, ruleEntries[entry]);\n    }\n  }\n\n  // Apply transforms.\n  for (let i = 0; i < allEntries.length; i += 2) {\n    kebabRules(allEntries, i);\n    provideUnits(allEntries, i);\n    rtlifyRules(options, allEntries, i);\n    prefixRules(allEntries, i);\n  }\n\n  // Apply punctuation.\n  for (let i = 1; i < allEntries.length; i += 4) {\n    allEntries.splice(i, 1, ':', allEntries[i], ';');\n  }\n\n  return allEntries.join('');\n}\n\nexport interface IRegistration {\n  className: string;\n  key: string;\n  args: IStyle[];\n  rulesToInsert: string[];\n}\n\nexport function styleToRegistration(options: IStyleOptions, ...args: IStyle[]): IRegistration | undefined {\n  const stylesheet = options.stylesheet ?? Stylesheet.getInstance(options.shadowConfig);\n  const rules: IRuleSet = extractRules(args, undefined, undefined, stylesheet);\n  const key = getKeyForRules(options, rules);\n\n  if (key) {\n    const registration: Partial<IRegistration> = {\n      className: stylesheet.classNameFromKey(key),\n      key,\n      args,\n    };\n\n    if (!registration.className) {\n      registration.className = stylesheet.getClassName(getDisplayName(rules));\n      const rulesToInsert: string[] = [];\n\n      for (const selector of rules.__order) {\n        rulesToInsert.push(selector, serializeRuleEntries(options, rules[selector]));\n      }\n      registration.rulesToInsert = rulesToInsert;\n    }\n\n    return registration as IRegistration;\n  }\n\n  return undefined;\n}\n\n/**\n * Insert style to stylesheet.\n * @param registration Style registration.\n * @param specificityMultiplier Number of times classname selector is repeated in the css rule.\n * This is to increase css specificity in case it's needed. Default to 1.\n */\nexport function applyRegistration(\n  registration: IRegistration,\n  specificityMultiplier: number = 1,\n  shadowConfig?: ShadowConfig,\n  sheet?: Stylesheet,\n): void {\n  const stylesheet = sheet ?? Stylesheet.getInstance(shadowConfig);\n  const { className, key, args, rulesToInsert } = registration;\n\n  if (rulesToInsert) {\n    // rulesToInsert is an ordered array of selector/rule pairs.\n    for (let i = 0; i < rulesToInsert.length; i += 2) {\n      const rules = rulesToInsert[i + 1];\n      if (rules) {\n        let selector = rulesToInsert[i];\n        selector = selector.replace(/&/g, repeatString(`.${registration.className}`, specificityMultiplier));\n\n        // Insert. Note if a media query, we must close the query with a final bracket.\n        const processedRule = `${selector}{${rules}}${selector.indexOf('@') === 0 ? '}' : ''}`;\n        stylesheet.insertRule(processedRule);\n      }\n    }\n    stylesheet.cacheClassName(className!, key!, args!, rulesToInsert);\n  }\n}\n\nexport function styleToClassName(options: IStyleOptions, ...args: IStyle[]): string {\n  const registration = styleToRegistration(options, ...args);\n  if (registration) {\n    applyRegistration(registration, options.specificityMultiplier, options.shadowConfig, options.stylesheet);\n\n    return registration.className;\n  }\n\n  return '';\n}\n", "import { extractStyleParts } from './extractStyleParts';\nimport { IStyle, IStyleBaseArray } from './IStyle';\nimport { IStyleOptions } from './IStyleOptions';\nimport { isShadowConfig, ShadowConfig } from './shadowConfig';\nimport { getStyleOptions } from './StyleOptionsState';\nimport { Stylesheet } from './Stylesheet';\nimport { styleToClassName } from './styleToClassName';\n\ntype Missing = false | null | undefined;\ntype StyleArg = IStyle | IStyleBaseArray | Missing;\ntype StyleArgWithShadow = StyleArg | ShadowConfig;\n\nexport function mergeStyles(...args: StyleArg[]): string;\nexport function mergeStyles(shadowConfig: ShadowConfig, ...args: StyleArg[]): string;\n/**\n * Concatenation helper, which can merge class names together. Skips over falsey values.\n *\n * @public\n */\nexport function mergeStyles(...args: any[]): string {\n  return mergeCss(args, getStyleOptions());\n}\n\n/**\n * Concatenation helper, which can merge class names together. Skips over falsey values.\n * Accepts a set of options that will be used when calculating styles.\n *\n * @public\n */\nexport function mergeCss(args: StyleArgWithShadow | StyleArgWithShadow[], options?: IStyleOptions): string {\n  const styleArgs = args instanceof Array ? args : [args];\n  const opts = options || {};\n  const hasShadowConfig = isShadowConfig(styleArgs[0]);\n  if (hasShadowConfig) {\n    opts.shadowConfig = styleArgs[0] as ShadowConfig;\n  }\n  opts.stylesheet = Stylesheet.getInstance(opts.shadowConfig);\n  const { classes, objects } = extractStyleParts(opts.stylesheet, styleArgs);\n\n  if (objects.length) {\n    classes.push(styleToClassName(opts, objects));\n  }\n\n  return classes.join(' ');\n}\n", "import { IStyleSet, IConcatenatedStyleSet } from './IStyleSet';\nimport { IStyleBase, IStyle } from './IStyle';\nimport { IStyleFunctionOrObject } from './IStyleFunction';\nimport { ObjectOnly } from './ObjectOnly';\nimport { ShadowConfig, isShadowConfig } from './shadowConfig';\n\ntype Missing = false | null | undefined;\ntype MissingOrShadowConfig = Missing | ShadowConfig;\n\n/**\n * Combine a set of styles together (but does not register css classes).\n * @param styleSet - The first style set to be concatenated.\n */\nexport function concatStyleSets<TStyleSet>(styleSet: TStyleSet | Missing): IConcatenatedStyleSet<ObjectOnly<TStyleSet>>;\n\n/**\n * Combine a set of styles together (but does not register css classes).\n * @param styleSet1 - The first style set to be concatenated.\n * @param styleSet2 - The second style set to be concatenated.\n */\nexport function concatStyleSets<TStyleSet1, TStyleSet2>(\n  styleSet1: TStyleSet1 | MissingOrShadowConfig,\n  styleSet2: TStyleSet2 | Missing,\n): IConcatenatedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2>>;\n\n/**\n * Combine a set of styles together (but does not register css classes).\n * @param styleSet1 - The first style set to be concatenated.\n * @param styleSet2 - The second style set to be concatenated.\n * @param styleSet3 - The third style set to be concatenated.\n */\nexport function concatStyleSets<TStyleSet1, TStyleSet2, TStyleSet3>(\n  styleSet1: TStyleSet1 | MissingOrShadowConfig,\n  styleSet2: TStyleSet2 | Missing,\n  styleSet3: TStyleSet3 | Missing,\n): IConcatenatedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3>>;\n\n/**\n * Combine a set of styles together (but does not register css classes).\n * @param styleSet1 - The first style set to be concatenated.\n * @param styleSet2 - The second style set to be concatenated.\n * @param styleSet3 - The third style set to be concatenated.\n * @param styleSet4 - The fourth style set to be concatenated.\n */\nexport function concatStyleSets<TStyleSet1, TStyleSet2, TStyleSet3, TStyleSet4>(\n  styleSet1: TStyleSet1 | MissingOrShadowConfig,\n  styleSet2: TStyleSet2 | Missing,\n  styleSet3: TStyleSet3 | Missing,\n  styleSet4: TStyleSet4 | Missing,\n): IConcatenatedStyleSet<\n  ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3> & ObjectOnly<TStyleSet4>\n>;\n\n/**\n * Combine a set of styles together (but does not register css classes).\n * @param styleSet1 - The first style set to be concatenated.\n * @param styleSet2 - The second style set to be concatenated.\n * @param styleSet3 - The third style set to be concatenated.\n * @param styleSet4 - The fourth style set to be concatenated.\n * @param styleSet5 - The fifth set to be concatenated.\n */\nexport function concatStyleSets<TStyleSet1, TStyleSet2, TStyleSet3, TStyleSet4, TStyleSet5>(\n  styleSet1: TStyleSet1 | MissingOrShadowConfig,\n  styleSet2: TStyleSet2 | Missing,\n  styleSet3: TStyleSet3 | Missing,\n  styleSet4: TStyleSet4 | Missing,\n  styleSet5: TStyleSet5 | Missing,\n): IConcatenatedStyleSet<\n  ObjectOnly<TStyleSet1> &\n    ObjectOnly<TStyleSet2> &\n    ObjectOnly<TStyleSet3> &\n    ObjectOnly<TStyleSet4> &\n    ObjectOnly<TStyleSet5>\n>;\n\n/**\n * Combine a set of styles together (but does not register css classes).\n * @param styleSet1 - The first style set to be concatenated.\n * @param styleSet2 - The second style set to be concatenated.\n * @param styleSet3 - The third style set to be concatenated.\n * @param styleSet4 - The fourth style set to be concatenated.\n * @param styleSet5 - The fifth set to be concatenated.\n * @param styleSet6 - The sixth set to be concatenated.\n */\nexport function concatStyleSets<TStyleSet1, TStyleSet2, TStyleSet3, TStyleSet4, TStyleSet5, TStyleSet6>(\n  styleSet1: TStyleSet1 | MissingOrShadowConfig,\n  styleSet2: TStyleSet2 | Missing,\n  styleSet3: TStyleSet3 | Missing,\n  styleSet4: TStyleSet4 | Missing,\n  styleSet5: TStyleSet5 | Missing,\n  styleSet6: TStyleSet6 | Missing,\n): IConcatenatedStyleSet<\n  ObjectOnly<TStyleSet1> &\n    ObjectOnly<TStyleSet2> &\n    ObjectOnly<TStyleSet3> &\n    ObjectOnly<TStyleSet4> &\n    ObjectOnly<TStyleSet5> &\n    ObjectOnly<TStyleSet6>\n>;\n\n/**\n * Combine a set of styles together (but does not register css classes).\n * @param styleSets - One or more stylesets to be merged (each param can also be falsy).\n */\nexport function concatStyleSets(...styleSets: (IStyleSet | MissingOrShadowConfig)[]): IConcatenatedStyleSet<any>;\n\n/**\n * Combine a set of styles together (but does not register css classes).\n * @param styleSets - One or more stylesets to be merged (each param can also be falsy).\n */\nexport function concatStyleSets(...styleSets: any[]): IConcatenatedStyleSet<any> {\n  if (\n    styleSets &&\n    styleSets.length === 1 &&\n    styleSets[0] &&\n    !(styleSets[0] as IStyleSet).subComponentStyles &&\n    !isShadowConfig(styleSets[0])\n  ) {\n    return styleSets[0] as IConcatenatedStyleSet<any>;\n  }\n\n  const mergedSet: IConcatenatedStyleSet<any> = {};\n\n  // We process sub component styles in two phases. First we collect them, then we combine them into 1 style function.\n  const workingSubcomponentStyles: { [key: string]: Array<IStyleFunctionOrObject<any, any>> } = {};\n\n  for (const currentSet of styleSets) {\n    if (currentSet && !isShadowConfig(currentSet)) {\n      for (const prop in currentSet) {\n        if (currentSet.hasOwnProperty(prop)) {\n          if (prop === 'subComponentStyles' && currentSet.subComponentStyles !== undefined) {\n            // subcomponent styles - style functions or objects\n\n            const currentComponentStyles = currentSet.subComponentStyles;\n            for (const subCompProp in currentComponentStyles) {\n              if (currentComponentStyles.hasOwnProperty(subCompProp)) {\n                if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {\n                  workingSubcomponentStyles[subCompProp].push(currentComponentStyles[subCompProp]);\n                } else {\n                  workingSubcomponentStyles[subCompProp] = [currentComponentStyles[subCompProp]];\n                }\n              }\n            }\n\n            continue;\n          }\n\n          // the as any casts below is a workaround for ts 2.8.\n          // todo: remove cast to any in ts 2.9.\n          const mergedValue: IStyle = (mergedSet as any)[prop];\n          const currentValue = (currentSet as any)[prop];\n\n          if (mergedValue === undefined) {\n            (mergedSet as any)[prop] = currentValue;\n          } else {\n            (mergedSet as any)[prop] = [\n              // https://github.com/Microsoft/TypeScript/issues/25474\n              ...(Array.isArray(mergedValue) ? mergedValue : [mergedValue as IStyleBase]),\n              ...(Array.isArray(currentValue) ? currentValue : [currentValue as IStyleBase]),\n            ];\n          }\n        }\n      }\n    }\n  }\n\n  if (Object.keys(workingSubcomponentStyles).length > 0) {\n    mergedSet.subComponentStyles = {};\n    const mergedSubStyles = mergedSet.subComponentStyles;\n\n    // now we process the subcomponent styles if there are any\n    for (const subCompProp in workingSubcomponentStyles) {\n      if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {\n        const workingSet = workingSubcomponentStyles[subCompProp];\n        mergedSubStyles[subCompProp] = (styleProps: any) => {\n          return concatStyleSets(\n            ...workingSet.map((styleFunctionOrObject: IStyleFunctionOrObject<any, any>) =>\n              typeof styleFunctionOrObject === 'function' ? styleFunctionOrObject(styleProps) : styleFunctionOrObject,\n            ),\n          );\n        };\n      }\n    }\n  }\n\n  return mergedSet;\n}\n", "import { concatStyleSets } from './concatStyleSets';\nimport { extractStyleParts } from './extractStyleParts';\nimport { IStyle } from './IStyle';\nimport { IStyleOptions } from './IStyleOptions';\nimport { IConcatenatedStyleSet, IProcessedStyleSet, IStyleSet } from './IStyleSet';\nimport { getStyleOptions } from './StyleOptionsState';\nimport { applyRegistration, styleToRegistration } from './styleToClassName';\nimport { ObjectOnly } from './ObjectOnly';\nimport { isShadowConfig, ShadowConfig } from './shadowConfig';\nimport { Stylesheet } from './Stylesheet';\n\ntype Missing = false | null | undefined;\ntype MissingOrShadowConfig = Missing | ShadowConfig;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet - The first style set to be merged and reigstered.\n */\nexport function mergeStyleSets<TStyleSet>(styleSet: TStyleSet | Missing): IProcessedStyleSet<ObjectOnly<TStyleSet>>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet1 - The first style set to be merged.\n * @param styleSet2 - The second style set to be merged.\n */\nexport function mergeStyleSets<TStyleSet1, TStyleSet2>(\n  styleSet1: TStyleSet1 | Missing,\n  styleSet2: TStyleSet2 | Missing,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2>>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet1 - The first style set to be merged.\n * @param styleSet2 - The second style set to be merged.\n * @param styleSet3 - The third style set to be merged.\n */\nexport function mergeStyleSets<TStyleSet1, TStyleSet2, TStyleSet3>(\n  styleSet1: TStyleSet1 | Missing,\n  styleSet2: TStyleSet2 | Missing,\n  styleSet3: TStyleSet3 | Missing,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3>>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet1 - The first style set to be merged.\n * @param styleSet2 - The second style set to be merged.\n * @param styleSet3 - The third style set to be merged.\n * @param styleSet4 - The fourth style set to be merged.\n */\nexport function mergeStyleSets<TStyleSet1, TStyleSet2, TStyleSet3, TStyleSet4>(\n  styleSet1: TStyleSet1 | Missing,\n  styleSet2: TStyleSet2 | Missing,\n  styleSet3: TStyleSet3 | Missing,\n  styleSet4: TStyleSet4 | Missing,\n): IProcessedStyleSet<\n  ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3> & ObjectOnly<TStyleSet4>\n>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n */\nexport function mergeStyleSets(...styleSets: Array<IStyleSet | MissingOrShadowConfig>): IProcessedStyleSet<any>;\n\nexport function mergeStyleSets(\n  shadowConfig: ShadowConfig,\n  ...styleSets: Array<IStyleSet | Missing>\n): IProcessedStyleSet<any>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n */\nexport function mergeStyleSets(...styleSets: any[]): IProcessedStyleSet<any> {\n  return mergeCssSets(styleSets as any, getStyleOptions());\n}\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet>(\n  styleSets: [TStyleSet | Missing],\n  options?: IStyleOptions,\n): IProcessedStyleSet<ObjectOnly<TStyleSet>>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet1, TStyleSet2>(\n  styleSets: [TStyleSet1 | MissingOrShadowConfig, TStyleSet2 | Missing],\n  options?: IStyleOptions,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2>>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet1, TStyleSet2, TStyleSet3>(\n  styleSets: [TStyleSet1 | MissingOrShadowConfig, TStyleSet2 | Missing, TStyleSet3 | Missing],\n  options?: IStyleOptions,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3>>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet1, TStyleSet2, TStyleSet3, TStyleSet4>(\n  styleSets: [TStyleSet1 | MissingOrShadowConfig, TStyleSet2 | Missing, TStyleSet3 | Missing, TStyleSet4 | Missing],\n  options?: IStyleOptions,\n): IProcessedStyleSet<\n  ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3> & ObjectOnly<TStyleSet4>\n>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet>(\n  styleSet: [TStyleSet | Missing],\n  options?: IStyleOptions,\n): IProcessedStyleSet<ObjectOnly<TStyleSet>>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets(styleSets: any[], options?: IStyleOptions): IProcessedStyleSet<any> {\n  const classNameSet: IProcessedStyleSet<any> & Record<string, unknown> = { subComponentStyles: {} };\n\n  let shadowConfig: ShadowConfig | undefined = undefined;\n  let styleSet;\n  if (isShadowConfig(styleSets[0])) {\n    shadowConfig = styleSets[0];\n    styleSet = styleSets[1];\n  } else {\n    styleSet = styleSets[0];\n  }\n\n  shadowConfig ??= options?.shadowConfig;\n\n  const opts = { ...options, shadowConfig };\n\n  if (!styleSet && styleSets.length <= 1) {\n    return { subComponentStyles: {} } as any;\n  }\n\n  const sheet = Stylesheet.getInstance(shadowConfig);\n  opts.stylesheet = sheet;\n  const concatenatedStyleSet = concatStyleSets(...styleSets);\n\n  const registrations = [];\n\n  for (const styleSetArea in concatenatedStyleSet) {\n    if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {\n      if (styleSetArea === 'subComponentStyles') {\n        classNameSet.subComponentStyles = concatenatedStyleSet.subComponentStyles || {};\n        continue;\n      } else if (styleSetArea === '__shadowConfig__') {\n        continue;\n      }\n\n      const styles: IStyle = (concatenatedStyleSet as any)[styleSetArea];\n\n      const { classes, objects } = extractStyleParts(sheet, styles);\n\n      if (objects?.length) {\n        const registration = styleToRegistration(opts || {}, { displayName: styleSetArea }, objects);\n\n        if (registration) {\n          registrations.push(registration);\n          classNameSet[styleSetArea] = classes.concat([registration.className]).join(' ');\n        }\n      } else {\n        classNameSet[styleSetArea] = classes.join(' ');\n      }\n    }\n  }\n\n  for (const registration of registrations) {\n    if (registration) {\n      applyRegistration(registration, options?.specificityMultiplier, shadowConfig);\n    }\n  }\n\n  return classNameSet;\n}\n", "import { concatStyleSets } from './concatStyleSets';\nimport { IStyleSetBase } from './IStyleSet';\nimport { IStyleFunctionOrObject } from './IStyleFunction';\nimport { DeepPartialV2 as DeepPartial } from './DeepPartial';\n\n/**\n * Concatenates style sets into one, but resolves functional sets using the given props.\n * @param styleProps - Props used to resolve functional sets.\n * @param allStyles - Style sets, which can be functions or objects.\n */\nexport function concatStyleSetsWithProps<TStyleProps, TStyleSet extends IStyleSetBase>(\n  styleProps: TStyleProps,\n  ...allStyles: (IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined)[]\n): DeepPartial<TStyleSet> {\n  const result: Array<DeepPartial<TStyleSet>> = [];\n  for (const styles of allStyles) {\n    if (styles) {\n      result.push(typeof styles === 'function' ? styles(styleProps) : styles);\n    }\n  }\n  if (result.length === 1) {\n    return result[0];\n  } else if (result.length) {\n    // cliffkoh: I cannot figure out how to avoid the cast to any here.\n    // It is something to do with the use of Omit in IStyleSet.\n    // It might not be necessary once  Omit becomes part of lib.d.ts (when we remove our own Omit and rely on\n    // the official version).\n    return concatStyleSets(...result) as DeepPartial<TStyleSet>;\n  }\n\n  return {} as DeepPartial<TStyleSet>;\n}\n", "import { IFontFace } from './IRawStyleBase';\nimport { getStyleOptions } from './StyleOptionsState';\nimport { Stylesheet } from './Stylesheet';\nimport { serializeRuleEntries } from './styleToClassName';\n\n/**\n * Registers a font face.\n * @public\n */\nexport function fontFace(font: IFontFace): void {\n  const stylesheet = Stylesheet.getInstance();\n\n  const rule = serializeRuleEntries(getStyleOptions(), font as {});\n\n  const className = stylesheet.classNameFromKey(rule);\n\n  if (className) {\n    return;\n  }\n\n  const name = stylesheet.getClassName();\n  stylesheet.insertRule(`@font-face{${rule}}`, true);\n  stylesheet.cacheClassName(name, rule, [], ['font-face', rule]);\n}\n", "import { IKeyframes } from './IKeyframes';\nimport { getStyleOptions } from './StyleOptionsState';\nimport { Stylesheet } from './Stylesheet';\nimport { serializeRuleEntries } from './styleToClassName';\n\n/**\n * Registers keyframe definitions.\n *\n * @public\n */\nexport function keyframes(timeline: IKeyframes): string {\n  const stylesheet = Stylesheet.getInstance();\n  const rulesArray: string[] = [];\n\n  for (const prop in timeline) {\n    if (timeline.hasOwnProperty(prop)) {\n      rulesArray.push(prop, '{', serializeRuleEntries(getStyleOptions(), timeline[prop]), '}');\n    }\n  }\n  const rules = rulesArray.join('');\n\n  const className = stylesheet.classNameFromKey(rules);\n\n  if (className) {\n    return className;\n  }\n\n  const name = stylesheet.getClassName();\n  stylesheet.insertRule(`@keyframes ${name}{${rules}}`, true);\n  stylesheet.cacheClassName(name, rules, [], ['keyframes', rules]);\n\n  return name;\n}\n", "/* eslint no-restricted-globals: 0 */\nimport { InjectionMode, STYLESHEET_SETTING, Stylesheet } from './Stylesheet';\nimport { DEFAULT_SHADOW_CONFIG, GLOBAL_STYLESHEET_KEY, SHADOW_DOM_STYLESHEET_SETTING } from './shadowConfig';\n\nimport type {\n  ExtendedCSSStyleSheet,\n  ISerializedStylesheet,\n  IStyleSheetConfig,\n  WindowWithMergeStyles,\n} from './Stylesheet';\nimport type { ShadowConfig } from './shadowConfig';\n\nexport const SUPPORTS_CONSTRUCTABLE_STYLESHEETS =\n  typeof document !== 'undefined' && Array.isArray(document.adoptedStyleSheets) && 'replace' in CSSStyleSheet.prototype;\n\nlet supportsModifyingAdoptedStyleSheets = false;\n\nif (SUPPORTS_CONSTRUCTABLE_STYLESHEETS) {\n  try {\n    document.adoptedStyleSheets.push();\n    supportsModifyingAdoptedStyleSheets = true;\n  } catch (e) {\n    supportsModifyingAdoptedStyleSheets = false;\n  }\n}\n\nexport const SUPPORTS_MODIFYING_ADOPTED_STYLESHEETS = supportsModifyingAdoptedStyleSheets;\n\nlet _stylesheet: ShadowDomStylesheet | undefined;\n\nlet _global: WindowWithMergeStyles = {};\n\n// Grab window.\ntry {\n  // Why the cast?\n  // if compiled/type checked in same program with `@fluentui/font-icons-mdl2` which extends `Window` on global\n  // ( check packages/font-icons-mdl2/src/index.ts ) the definitions don't match! Thus the need of this extra assertion\n  _global = (window || {}) as WindowWithMergeStyles;\n} catch {\n  /* leave as blank object */\n}\n\nexport type AddSheetCallback = ({ key, sheet }: { key: string; sheet: ExtendedCSSStyleSheet }) => void;\n\nconst copyOldGlobalRules = (\n  stylesheet: ShadowDomStylesheet,\n  inShadow: boolean = false,\n  win: Window | undefined,\n  doc: Document | undefined,\n) => {\n  if (!doc) {\n    // SSR\n    return;\n  }\n\n  const oldGlobalRules = doc.querySelectorAll('[data-merge-styles]');\n  if (oldGlobalRules) {\n    stylesheet.setConfig({\n      window: win,\n      inShadow,\n      stylesheetKey: GLOBAL_STYLESHEET_KEY,\n    });\n\n    for (let i = 0; i < oldGlobalRules.length; i++) {\n      const styleElem = oldGlobalRules[i] as HTMLStyleElement;\n      styleElem.setAttribute('data-merge-styles-global', 'true');\n      const cssRules = styleElem.sheet?.cssRules || [];\n\n      for (let j = 0; j < cssRules.length; j++) {\n        const rule = cssRules[j];\n        stylesheet.insertRule(rule.cssText);\n      }\n    }\n  }\n};\n\nexport class ShadowDomStylesheet extends Stylesheet {\n  private _onAddSheetCallbacks: AddSheetCallback[] = [];\n  private _adoptableSheets: Map<string, ExtendedCSSStyleSheet>;\n  private _sheetCounter = 0;\n\n  public static getInstance(shadowConfig?: ShadowConfig): ShadowDomStylesheet {\n    const sConfig = shadowConfig || DEFAULT_SHADOW_CONFIG;\n    const stylesheetKey = sConfig.stylesheetKey || GLOBAL_STYLESHEET_KEY;\n    const inShadow = sConfig.inShadow;\n    const win = sConfig.window || (typeof window !== 'undefined' ? window : undefined);\n    const global = (win || _global) as WindowWithMergeStyles;\n    const doc = win ? win.document : typeof document !== 'undefined' ? document : undefined;\n\n    _stylesheet = global[STYLESHEET_SETTING] as ShadowDomStylesheet;\n\n    // When an app has multiple versions of Fluent v8 it is possible\n    // that an older version of Stylesheet is initialized before\n    // the version that supports shadow DOM. We check for this case\n    // and re-initialize the stylesheet in that case.\n    const oldStylesheetInitializedFirst = _stylesheet && !_stylesheet.getAdoptedSheets;\n\n    if (\n      !_stylesheet ||\n      oldStylesheetInitializedFirst ||\n      (_stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== doc)\n    ) {\n      const fabricConfig = global?.FabricConfig || {};\n      const defaultMergeStyles = {\n        window: win,\n        inShadow,\n        stylesheetKey,\n      };\n      fabricConfig.mergeStyles = fabricConfig.mergeStyles || {};\n      fabricConfig.mergeStyles = { ...defaultMergeStyles, ...fabricConfig.mergeStyles };\n\n      let stylesheet: ShadowDomStylesheet;\n      if (oldStylesheetInitializedFirst) {\n        stylesheet = new ShadowDomStylesheet(fabricConfig.mergeStyles, JSON.parse(_stylesheet.serialize()));\n        copyOldGlobalRules(stylesheet, inShadow, win, doc);\n      } else {\n        stylesheet = new ShadowDomStylesheet(fabricConfig.mergeStyles, fabricConfig.serializedStylesheet);\n      }\n\n      _stylesheet = stylesheet;\n      global[STYLESHEET_SETTING] = _stylesheet;\n    } else {\n      _stylesheet.setConfig({\n        window: win,\n        inShadow,\n        stylesheetKey,\n      });\n    }\n    if (win) {\n      _stylesheet._getAdoptableStyleSheet(stylesheetKey);\n    }\n\n    return _stylesheet;\n  }\n\n  constructor(config?: IStyleSheetConfig, serializedStylesheet?: ISerializedStylesheet) {\n    super(config, serializedStylesheet);\n\n    this._adoptableSheets = new Map();\n\n    _global[SHADOW_DOM_STYLESHEET_SETTING] = ShadowDomStylesheet;\n  }\n\n  public getAdoptedSheets(): Map<string, ExtendedCSSStyleSheet> {\n    return this._adoptableSheets;\n  }\n\n  public onAddSheet(callback: AddSheetCallback): Function {\n    this._onAddSheetCallbacks.push(callback);\n\n    return () => {\n      this._onAddSheetCallbacks = this._onAddSheetCallbacks.filter(cb => cb !== callback);\n    };\n  }\n\n  public insertRule(rule: string, preserve?: boolean): void {\n    const { injectionMode, stylesheetKey = GLOBAL_STYLESHEET_KEY } = this._config;\n\n    const injectStyles = injectionMode !== InjectionMode.none;\n    const addToConstructableStylesheet =\n      stylesheetKey === GLOBAL_STYLESHEET_KEY || !!this._adoptableSheets.has(stylesheetKey);\n\n    let constructableSheet: CSSStyleSheet | undefined = undefined;\n\n    if (injectStyles && addToConstructableStylesheet) {\n      constructableSheet = this._getAdoptableStyleSheet(stylesheetKey);\n    }\n\n    if (constructableSheet) {\n      this._insertRuleIntoSheet(constructableSheet, rule);\n    }\n\n    super.insertRule(rule, preserve, stylesheetKey);\n  }\n\n  protected _getCacheKey(key: string): string {\n    const { inShadow = false, stylesheetKey: currentStylesheetKey = GLOBAL_STYLESHEET_KEY } = this._config;\n\n    if (inShadow) {\n      return `__${currentStylesheetKey}__${key}`;\n    }\n\n    return super._getCacheKey(key);\n  }\n\n  protected _createStyleElement(): HTMLStyleElement {\n    const styleElement = super._createStyleElement();\n\n    if (this._config.stylesheetKey === GLOBAL_STYLESHEET_KEY) {\n      styleElement.setAttribute('data-merge-styles-global', 'true');\n    }\n\n    return styleElement;\n  }\n\n  private _makeCSSStyleSheet(): ExtendedCSSStyleSheet {\n    const win = this._config.window || window;\n    let sheet: ExtendedCSSStyleSheet | undefined = undefined;\n    if (!SUPPORTS_CONSTRUCTABLE_STYLESHEETS) {\n      const style = this._createStyleElement();\n      sheet = style.sheet as ExtendedCSSStyleSheet;\n    } else {\n      sheet = new (win as Window & typeof globalThis).CSSStyleSheet() as ExtendedCSSStyleSheet;\n    }\n\n    if (sheet) {\n      sheet.bucketName = 'merge-styles';\n      sheet.metadata = {\n        stylesheetKey: this._config.stylesheetKey || GLOBAL_STYLESHEET_KEY,\n        sortOrder: this._sheetCounter++,\n      };\n    }\n\n    return sheet;\n  }\n\n  private _addAdoptableStyleSheet(key: string, sheet: ExtendedCSSStyleSheet, queue: boolean = true): void {\n    if (!this._adoptableSheets.has(key)) {\n      this._adoptableSheets.set(key, sheet);\n      const win = this._config.window;\n      if (queue && win) {\n        win.queueMicrotask(() => {\n          this._onAddSheetCallbacks.forEach(callback => callback({ key, sheet }));\n        });\n      }\n    }\n  }\n\n  private _getAdoptableStyleSheet(key: string): ExtendedCSSStyleSheet {\n    let sheet = this._adoptableSheets.get(key);\n    if (!sheet) {\n      sheet = this._makeCSSStyleSheet();\n      this._addAdoptableStyleSheet(key, sheet);\n    }\n\n    return sheet;\n  }\n}\n", "import type { ExtendedCSSStyleSheet } from './Stylesheet';\n\nexport const cloneCSSStyleSheet = (srcSheet: CSSStyleSheet, targetSheet: CSSStyleSheet): CSSStyleSheet => {\n  for (let i = 0; i < srcSheet.cssRules.length; i++) {\n    targetSheet.insertRule(srcSheet.cssRules[i].cssText, i);\n  }\n\n  return targetSheet;\n};\n\nexport const cloneExtendedCSSStyleSheet = (\n  srcSheet: ExtendedCSSStyleSheet,\n  targetSheet: ExtendedCSSStyleSheet,\n): ExtendedCSSStyleSheet => {\n  const clone = cloneCSSStyleSheet(srcSheet, targetSheet) as ExtendedCSSStyleSheet;\n\n  clone.bucketName = srcSheet.bucketName;\n  for (const key of Object.keys(srcSheet.metadata)) {\n    clone.metadata[key] = srcSheet.metadata[key];\n  }\n\n  return clone;\n};\n", "// Do not modify this file; it is generated as part of publish.\n// The checked in version is a placeholder only and will not be updated.\nimport { setVersion } from '@fluentui/set-version';\nsetVersion('@fluentui/merge-styles', '8.6.13');", "import { getDocument } from './dom/getDocument';\nimport { mergeStyles } from '@fluentui/merge-styles';\nimport { EventGroup } from './EventGroup';\nimport { getWindow } from './dom/getWindow';\n\nlet _scrollbarWidth: number;\nlet _bodyScrollDisabledCount = 0;\n\nconst DisabledScrollClassName = mergeStyles({\n  overflow: 'hidden !important' as 'hidden',\n});\n\n/**\n * Placing this attribute on scrollable divs optimizes detection to know\n * if the div is scrollable or not (given we can avoid expensive operations\n * like getComputedStyle.)\n *\n * @public\n */\nexport const DATA_IS_SCROLLABLE_ATTRIBUTE = 'data-is-scrollable';\n\n/**\n * Allows the user to scroll within a element,\n * while preventing the user from scrolling the body\n */\nexport const allowScrollOnElement = (element: HTMLElement | null, events: EventGroup): void => {\n  const window = getWindow(element);\n\n  if (!element || !window) {\n    return;\n  }\n\n  let _previousClientY = 0;\n  let _element: Element | null = null;\n  let computedStyles: CSSStyleDeclaration | undefined = window.getComputedStyle(element);\n\n  // remember the clientY for future calls of _preventOverscrolling\n  const _saveClientY = (event: TouchEvent): void => {\n    if (event.targetTouches.length === 1) {\n      _previousClientY = event.targetTouches[0].clientY;\n    }\n  };\n\n  // prevent the body from scrolling when the user attempts\n  // to scroll past the top or bottom of the element\n  const _preventOverscrolling = (event: TouchEvent): void => {\n    // only respond to a single-finger touch\n    if (event.targetTouches.length !== 1) {\n      return;\n    }\n\n    // prevent the body touchmove handler from firing\n    // so that scrolling is allowed within the element\n    event.stopPropagation();\n\n    if (!_element) {\n      return;\n    }\n\n    const clientY = event.targetTouches[0].clientY - _previousClientY;\n\n    const scrollableParent = findScrollableParent(event.target as HTMLElement) as HTMLElement;\n    if (scrollableParent && _element !== scrollableParent) {\n      _element = scrollableParent;\n      computedStyles = window.getComputedStyle(_element);\n    }\n\n    const scrollTop = _element.scrollTop;\n    const isColumnReverse = computedStyles?.flexDirection === 'column-reverse';\n\n    // if the element is scrolled to the top,\n    // prevent the user from scrolling up\n    if (scrollTop === 0 && (isColumnReverse ? clientY < 0 : clientY > 0)) {\n      event.preventDefault();\n    }\n\n    // if the element is scrolled to the bottom,\n    // prevent the user from scrolling down\n    if (\n      _element.scrollHeight - Math.abs(Math.ceil(scrollTop)) <= _element.clientHeight &&\n      (isColumnReverse ? clientY > 0 : clientY < 0)\n    ) {\n      event.preventDefault();\n    }\n  };\n\n  events.on(element, 'touchstart', _saveClientY, { passive: false });\n  events.on(element, 'touchmove', _preventOverscrolling, { passive: false });\n\n  _element = element;\n};\n\n/**\n * Same as allowScrollOnElement but does not prevent overscrolling.\n */\nexport const allowOverscrollOnElement = (element: HTMLElement | null, events: EventGroup): void => {\n  if (!element) {\n    return;\n  }\n  const _allowElementScroll = (event: TouchEvent) => {\n    event.stopPropagation();\n  };\n  events.on(element, 'touchmove', _allowElementScroll, { passive: false });\n};\n\nconst _disableIosBodyScroll = (event: TouchEvent) => {\n  event.preventDefault();\n};\n\n/**\n * Disables the body scrolling.\n *\n * @public\n */\nexport function disableBodyScroll(): void {\n  let doc = getDocument();\n\n  if (doc && doc.body && !_bodyScrollDisabledCount) {\n    doc.body.classList.add(DisabledScrollClassName);\n    doc.body.addEventListener('touchmove', _disableIosBodyScroll, { passive: false, capture: false });\n  }\n\n  _bodyScrollDisabledCount++;\n}\n\n/**\n * Enables the body scrolling.\n *\n * @public\n */\nexport function enableBodyScroll(): void {\n  if (_bodyScrollDisabledCount > 0) {\n    let doc = getDocument();\n\n    if (doc && doc.body && _bodyScrollDisabledCount === 1) {\n      doc.body.classList.remove(DisabledScrollClassName);\n      doc.body.removeEventListener('touchmove', _disableIosBodyScroll);\n    }\n\n    _bodyScrollDisabledCount--;\n  }\n}\n\n/**\n * Calculates the width of a scrollbar for the browser/os.\n *\n * @public\n */\nexport function getScrollbarWidth(doc?: Document): number {\n  if (_scrollbarWidth === undefined) {\n    const theDoc = doc ?? getDocument()!;\n    let scrollDiv: HTMLElement = theDoc.createElement('div');\n    scrollDiv.style.setProperty('width', '100px');\n    scrollDiv.style.setProperty('height', '100px');\n    scrollDiv.style.setProperty('overflow', 'scroll');\n    scrollDiv.style.setProperty('position', 'absolute');\n    scrollDiv.style.setProperty('top', '-9999px');\n    theDoc.body.appendChild(scrollDiv);\n    // Get the scrollbar width\n    _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n    // Delete the DIV\n    theDoc.body.removeChild(scrollDiv);\n  }\n\n  return _scrollbarWidth;\n}\n\n/**\n * Traverses up the DOM for the element with the data-is-scrollable=true attribute, or returns\n * document.body.\n *\n * @public\n */\nexport function findScrollableParent(startingElement: HTMLElement | null): HTMLElement | Window | undefined | null {\n  let el: HTMLElement | Window | undefined | null = startingElement;\n  const doc = getDocument(startingElement)!;\n\n  // First do a quick scan for the scrollable attribute.\n  while (el && el !== doc.body) {\n    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) === 'true') {\n      return el;\n    }\n    el = el.parentElement;\n  }\n\n  // If we haven't found it, the use the slower method: compute styles to evaluate if overflow is set.\n  el = startingElement;\n\n  while (el && el !== doc.body) {\n    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) !== 'false') {\n      const computedStyles = getComputedStyle(el);\n      let overflowY = computedStyles ? computedStyles.getPropertyValue('overflow-y') : '';\n\n      if (overflowY && (overflowY === 'scroll' || overflowY === 'auto')) {\n        return el;\n      }\n    }\n\n    el = el.parentElement;\n  }\n\n  // Fall back to window scroll.\n  if (!el || el === doc.body) {\n    el = getWindow(startingElement);\n  }\n\n  return el;\n}\n", "import { EventGroup } from './EventGroup';\nimport { findScrollableParent } from './scroll';\nimport { getRect } from './dom/getRect';\nimport type { IRectangle } from './IRectangle';\nimport { getWindow } from './dom';\n\ndeclare function setTimeout(cb: Function, delay: number): number;\n\nconst SCROLL_ITERATION_DELAY = 16;\nconst SCROLL_GUTTER = 100;\nconst MAX_SCROLL_VELOCITY = 15;\n\n/**\n * AutoScroll simply hooks up mouse events given a parent element, and scrolls the container\n * up/down depending on how close the mouse is to the top/bottom of the container.\n *\n * Once you don't want autoscroll any more, just dispose the helper and it will unhook events.\n *\n * @public\n * {@docCategory AutoScroll}\n */\nexport class AutoScroll {\n  private _events: EventGroup;\n  private _scrollableParent: HTMLElement | null;\n  private _scrollRect: IRectangle | undefined;\n  private _scrollVelocity!: number;\n  private _isVerticalScroll!: boolean;\n  private _timeoutId?: number;\n\n  constructor(element: HTMLElement, win?: Window) {\n    const theWin = win ?? getWindow(element)!;\n    this._events = new EventGroup(this);\n    this._scrollableParent = findScrollableParent(element) as HTMLElement;\n\n    this._incrementScroll = this._incrementScroll.bind(this);\n    this._scrollRect = getRect(this._scrollableParent, theWin);\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (this._scrollableParent === (theWin as any)) {\n      this._scrollableParent = theWin.document.body;\n    }\n\n    if (this._scrollableParent) {\n      this._events.on(theWin, 'mousemove', this._onMouseMove, true);\n      this._events.on(theWin, 'touchmove', this._onTouchMove, true);\n    }\n  }\n\n  public dispose(): void {\n    this._events.dispose();\n    this._stopScroll();\n  }\n\n  private _onMouseMove(ev: MouseEvent): void {\n    this._computeScrollVelocity(ev);\n  }\n\n  private _onTouchMove(ev: TouchEvent): void {\n    if (ev.touches.length > 0) {\n      this._computeScrollVelocity(ev);\n    }\n  }\n\n  private _computeScrollVelocity(ev: MouseEvent | TouchEvent): void {\n    if (!this._scrollRect) {\n      return;\n    }\n\n    let clientX: number;\n    let clientY: number;\n    if ('clientX' in ev) {\n      clientX = ev.clientX;\n      clientY = ev.clientY;\n    } else {\n      clientX = ev.touches[0].clientX;\n      clientY = ev.touches[0].clientY;\n    }\n\n    let scrollRectTop = this._scrollRect.top;\n    let scrollRectLeft = this._scrollRect.left;\n    let scrollClientBottom = scrollRectTop + this._scrollRect.height - SCROLL_GUTTER;\n    let scrollClientRight = scrollRectLeft + this._scrollRect.width - SCROLL_GUTTER;\n\n    // variables to use for alternating scroll direction\n    let scrollRect;\n    let clientDirection;\n    let scrollClient;\n\n    // if either of these conditions are met we are scrolling vertically else horizontally\n    if (clientY < scrollRectTop + SCROLL_GUTTER || clientY > scrollClientBottom) {\n      clientDirection = clientY;\n      scrollRect = scrollRectTop;\n      scrollClient = scrollClientBottom;\n      this._isVerticalScroll = true;\n    } else {\n      clientDirection = clientX;\n      scrollRect = scrollRectLeft;\n      scrollClient = scrollClientRight;\n      this._isVerticalScroll = false;\n    }\n\n    // calculate scroll velocity and direction\n    if (clientDirection! < scrollRect + SCROLL_GUTTER) {\n      this._scrollVelocity = Math.max(\n        -MAX_SCROLL_VELOCITY,\n        -MAX_SCROLL_VELOCITY * ((SCROLL_GUTTER - (clientDirection - scrollRect)) / SCROLL_GUTTER),\n      );\n    } else if (clientDirection > scrollClient) {\n      this._scrollVelocity = Math.min(\n        MAX_SCROLL_VELOCITY,\n        MAX_SCROLL_VELOCITY * ((clientDirection - scrollClient) / SCROLL_GUTTER),\n      );\n    } else {\n      this._scrollVelocity = 0;\n    }\n\n    if (this._scrollVelocity) {\n      this._startScroll();\n    } else {\n      this._stopScroll();\n    }\n  }\n\n  private _startScroll(): void {\n    if (!this._timeoutId) {\n      this._incrementScroll();\n    }\n  }\n\n  private _incrementScroll(): void {\n    if (this._scrollableParent) {\n      if (this._isVerticalScroll) {\n        this._scrollableParent.scrollTop += Math.round(this._scrollVelocity);\n      } else {\n        this._scrollableParent.scrollLeft += Math.round(this._scrollVelocity);\n      }\n    }\n\n    this._timeoutId = setTimeout(this._incrementScroll, SCROLL_ITERATION_DELAY);\n  }\n\n  private _stopScroll(): void {\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId);\n      delete this._timeoutId;\n    }\n  }\n}\n", "import * as React from 'react';\nimport { Async } from './Async';\nimport { EventGroup } from './EventGroup';\nimport { warnConditionallyRequiredProps } from './warn/warnConditionallyRequiredProps';\nimport { warnMutuallyExclusive } from './warn/warnMutuallyExclusive';\nimport { warnDeprecations } from './warn/warnDeprecations';\nimport type { IDisposable } from './IDisposable';\nimport type { ISettingsMap } from './warn/warn';\nimport type { IRefObject } from './createRef';\nimport type { IBaseProps } from './BaseComponent.types';\n\n/**\n * BaseComponent class, which provides basic helpers for all components.\n *\n * @public\n * {@docCategory BaseComponent}\n *\n * @deprecated Do not use. We are moving away from class component.\n */\nexport class BaseComponent<TProps extends IBaseProps = {}, TState extends {} = {}> extends React.Component<\n  TProps,\n  TState\n> {\n  /**\n   * @deprecated Use React's error boundaries instead.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public static onError: (errorMessage?: string, ex?: any) => void;\n\n  /**\n   * Controls whether the componentRef prop will be resolved by this component instance. If you are\n   * implementing a passthrough (higher-order component), you would set this to false and pass through\n   * the props to the inner component, allowing it to resolve the componentRef.\n   */\n  protected _skipComponentRefResolution!: boolean;\n\n  private __async!: Async;\n  private __events!: EventGroup;\n  private __disposables!: IDisposable[] | null;\n  private __resolves!: { [name: string]: (ref: React.ReactNode) => React.ReactNode };\n  private __className!: string;\n\n  /**\n   * BaseComponent constructor\n   * @param props - The props for the component.\n   * @param context - The context for the component.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(props: TProps, context?: any) {\n    super(props, context);\n\n    // eslint-disable-next-line deprecation/deprecation\n    _makeAllSafe(this, BaseComponent.prototype, [\n      'componentDidMount',\n      'shouldComponentUpdate',\n      'getSnapshotBeforeUpdate',\n      'render',\n      'componentDidUpdate',\n      'componentWillUnmount',\n    ]);\n  }\n\n  /**\n   * When the component receives props, make sure the componentRef is updated.\n   */\n  public componentDidUpdate(prevProps: TProps, prevState: TState): void {\n    this._updateComponentRef(prevProps, this.props);\n  }\n\n  /**\n   * When the component has mounted, update the componentRef.\n   */\n  public componentDidMount(): void {\n    this._setComponentRef(this.props.componentRef, this);\n  }\n\n  /**\n   * If we have disposables, dispose them automatically on unmount.\n   */\n  public componentWillUnmount(): void {\n    this._setComponentRef(this.props.componentRef, null);\n\n    if (this.__disposables) {\n      for (let i = 0, len = this._disposables.length; i < len; i++) {\n        let disposable = this.__disposables[i];\n\n        if (disposable.dispose) {\n          disposable.dispose();\n        }\n      }\n      this.__disposables = null;\n    }\n  }\n\n  /**\n   * Gets the object's class name.\n   */\n  public get className(): string {\n    if (!this.__className) {\n      let funcNameRegex = /function (.{1,})\\(/;\n      let results = funcNameRegex.exec(this.constructor.toString());\n\n      this.__className = results && results.length > 1 ? results[1] : '';\n    }\n\n    return this.__className;\n  }\n\n  /**\n   * Allows subclasses to push things to this._disposables to be auto disposed.\n   */\n  protected get _disposables(): IDisposable[] {\n    if (!this.__disposables) {\n      this.__disposables = [];\n    }\n    return this.__disposables;\n  }\n\n  /**\n   * Gets the async instance associated with the component, created on demand. The async instance gives\n   * subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks\n   * will be cleared/ignored automatically after unmounting. The helpers within the async object also\n   * preserve the this pointer so that you don't need to \"bind\" the callbacks.\n   */\n  protected get _async(): Async {\n    if (!this.__async) {\n      this.__async = new Async(this);\n      this._disposables.push(this.__async);\n    }\n\n    return this.__async;\n  }\n\n  /**\n   * Gets the event group instance assocaited with the component, created on demand. The event instance\n   * provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks\n   * will be automatically disconnected after unmounting. The helpers within the events object also\n   * preserve the this reference so that you don't need to \"bind\" the callbacks.\n   */\n  protected get _events(): EventGroup {\n    if (!this.__events) {\n      this.__events = new EventGroup(this);\n      this._disposables.push(this.__events);\n    }\n\n    return this.__events;\n  }\n\n  /**\n   * Helper to return a memoized ref resolver function.\n   * @param refName - Name of the member to assign the ref to.\n   * @returns A function instance keyed from the given refname.\n   * @deprecated Use `createRef` from React.createRef.\n   */\n  protected _resolveRef(refName: string): (ref: React.ReactNode) => React.ReactNode {\n    if (!this.__resolves) {\n      this.__resolves = {};\n    }\n\n    if (!this.__resolves[refName]) {\n      this.__resolves[refName] = (ref: React.ReactNode) => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return ((this as any)[refName] = ref);\n      };\n    }\n\n    return this.__resolves[refName];\n  }\n\n  /**\n   * Updates the componentRef (by calling it with \"this\" when necessary.)\n   */\n  protected _updateComponentRef(currentProps: IBaseProps, newProps: IBaseProps = {}): void {\n    // currentProps *should* always be defined, but verify that just in case a subclass is manually\n    // calling a lifecycle method with no parameters (which has happened) or other odd usage.\n    if (currentProps && newProps && currentProps.componentRef !== newProps.componentRef) {\n      this._setComponentRef(currentProps.componentRef, null);\n      this._setComponentRef(newProps.componentRef, this);\n    }\n  }\n\n  /**\n   * Warns when a deprecated props are being used.\n   *\n   * @param deprecationMap - The map of deprecations, where key is the prop name and the value is\n   * either null or a replacement prop name.\n   */\n  protected _warnDeprecations(deprecationMap: ISettingsMap<TProps>): void {\n    warnDeprecations(this.className, this.props, deprecationMap);\n  }\n\n  /**\n   * Warns when props which are mutually exclusive with each other are both used.\n   *\n   * @param mutuallyExclusiveMap - The map of mutually exclusive props.\n   */\n  protected _warnMutuallyExclusive(mutuallyExclusiveMap: ISettingsMap<TProps>): void {\n    warnMutuallyExclusive(this.className, this.props, mutuallyExclusiveMap);\n  }\n\n  /**\n   * Warns when props are required if a condition is met.\n   *\n   * @param requiredProps - The name of the props that are required when the condition is met.\n   * @param conditionalPropName - The name of the prop that the condition is based on.\n   * @param condition - Whether the condition is met.\n   */\n  protected _warnConditionallyRequiredProps(\n    requiredProps: string[],\n    conditionalPropName: string,\n    condition: boolean,\n  ): void {\n    warnConditionallyRequiredProps(this.className, this.props, requiredProps, conditionalPropName, condition);\n  }\n\n  private _setComponentRef<TRefInterface>(\n    ref: IRefObject<TRefInterface> | undefined,\n    value: TRefInterface | null,\n  ): void {\n    if (!this._skipComponentRefResolution && ref) {\n      if (typeof ref === 'function') {\n        ref(value);\n      }\n\n      if (typeof ref === 'object') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (ref as any).current = value;\n      }\n    }\n  }\n}\n\n/**\n * Helper to override a given method with a wrapper method that can try/catch the original, but also\n * ensures that the BaseComponent's methods are called before the subclass's. This ensures that\n * componentWillUnmount in the base is called and that things in the _disposables array are disposed.\n */\n// eslint-disable-next-line deprecation/deprecation\nfunction _makeAllSafe(obj: BaseComponent<{}, {}>, prototype: Object, methodNames: string[]): void {\n  for (let i = 0, len = methodNames.length; i < len; i++) {\n    _makeSafe(obj, prototype, methodNames[i]);\n  }\n}\n\n// eslint-disable-next-line deprecation/deprecation\nfunction _makeSafe(obj: BaseComponent<{}, {}>, prototype: Object, methodName: string): void {\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  let classMethod = (obj as any)[methodName];\n  let prototypeMethod = (prototype as any)[methodName];\n\n  if (classMethod || prototypeMethod) {\n    (obj as any)[methodName] = function (...args: any[]): any {\n      /* eslint-enable @typescript-eslint/no-explicit-any */\n      let retVal;\n\n      if (prototypeMethod) {\n        retVal = prototypeMethod.apply(this, args);\n      }\n      if (classMethod !== prototypeMethod) {\n        retVal = classMethod.apply(this, args);\n      }\n\n      return retVal;\n    };\n  }\n}\n\n/**\n * Simple constant function for returning null, used to render empty templates in JSX.\n *\n * @public\n */\nexport function nullRender(): JSX.Element | null {\n  return null;\n}\n", "/* eslint-disable no-console */\n\nlet _warningCallback: ((message: string) => void) | undefined = undefined;\n\nexport type ISettingsMap<T> = { [P in keyof T]?: string };\n\n/**\n * Sends a warning to console, if the api is present.\n *\n * @public\n * @param message - Warning message.\n */\nexport function warn(message: string): void {\n  if (_warningCallback && process.env.NODE_ENV !== 'production') {\n    _warningCallback(message);\n  } else if (console && console.warn) {\n    console.warn(message);\n  }\n}\n\n/**\n * Configures the warning callback. Passing in undefined will reset it to use the default\n * console.warn function.\n *\n * @public\n * @param warningCallback - Callback to override the generated warnings.\n */\nexport function setWarningCallback(warningCallback?: (message: string) => void): void {\n  _warningCallback = warningCallback;\n}\n", "import { warn } from './warn';\n/**\n * Warns when props are required if a condition is met.\n *\n * @public\n * @param componentName - The name of the component being used.\n * @param props - The props passed into the component.\n * @param requiredProps - The name of the props that are required when the condition is met.\n * @param conditionalPropName - The name of the prop that the condition is based on.\n * @param condition - Whether the condition is met.\n */\nexport function warnConditionallyRequiredProps<P extends {}>(\n  componentName: string,\n  props: P,\n  requiredProps: string[],\n  conditionalPropName: string,\n  condition: boolean,\n): void {\n  if (condition === true && process.env.NODE_ENV !== 'production') {\n    for (const requiredPropName of requiredProps) {\n      if (!(requiredPropName in props)) {\n        warn(`${componentName} property '${requiredPropName}' is required when '${conditionalPropName}' is used.'`);\n      }\n    }\n  }\n}\n", "import { warn } from './warn';\nimport type { ISettingsMap } from './warn';\n\n/**\n * Warns when two props which are mutually exclusive are both being used.\n *\n * @public\n * @param componentName - The name of the component being used.\n * @param props - The props passed into the component.\n * @param exclusiveMap - A map where the key is a parameter, and the value is the other parameter.\n */\nexport function warnMutuallyExclusive<P>(componentName: string, props: P, exclusiveMap: ISettingsMap<P>): void {\n  if (process.env.NODE_ENV !== 'production') {\n    for (const propName in exclusiveMap) {\n      if (props && props[propName] !== undefined) {\n        let propInExclusiveMapValue = exclusiveMap[propName];\n        if (propInExclusiveMapValue && props[propInExclusiveMapValue as keyof P] !== undefined) {\n          warn(\n            `${componentName} property '${propName}' is mutually exclusive with '${exclusiveMap[propName]}'. ` +\n              `Use one or the other.`,\n          );\n        }\n      }\n    }\n  }\n}\n", "import { warn } from './warn';\nimport type { ISettingsMap } from './warn';\n\n/**\n * Warns when a deprecated props are being used.\n *\n * @public\n * @param componentName - The name of the component being used.\n * @param props - The props passed into the component.\n * @param deprecationMap - The map of deprecations, where key is the prop name and the value is\n * either null or a replacement prop name.\n */\nexport function warnDeprecations<P extends {}>(componentName: string, props: P, deprecationMap: ISettingsMap<P>): void {\n  if (process.env.NODE_ENV !== 'production') {\n    for (const propName in deprecationMap) {\n      if (props && propName in props) {\n        let deprecationMessage = `${componentName} property '${propName}' was used but has been deprecated.`;\n        const replacementPropName = deprecationMap[propName];\n        if (replacementPropName) {\n          deprecationMessage += ` Use '${replacementPropName}' instead.`;\n        }\n        warn(deprecationMessage);\n      }\n    }\n  }\n}\n", "import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { IReactProps } from './React.types';\n\n/**\n * DelayedRender component props.\n *\n * @public\n */\nexport interface IDelayedRenderProps extends IReactProps<{}> {\n  /**\n   * Number of milliseconds to delay rendering children.\n   */\n  delay?: number;\n}\n\n/**\n * DelayedRender component state.\n *\n * @internal\n */\nexport interface IDelayedRenderState {\n  /**\n   * Whether the component is rendered or not.\n   */\n  isRendered: boolean;\n}\n\n/**\n * Utility component for delaying the render of a child component after a given delay. This component\n * requires a single child component; don't pass in many components. Wrap multiple components in a DIV\n * if necessary.\n *\n * @public\n * {@docCategory DelayedRender}\n */\nexport class DelayedRender extends React.Component<IDelayedRenderProps, IDelayedRenderState> {\n  public static defaultProps = {\n    delay: 0,\n  };\n\n  private _timeoutId: number | undefined;\n\n  constructor(props: IDelayedRenderProps) {\n    super(props);\n    this.state = {\n      isRendered: getWindow() === undefined,\n    };\n  }\n\n  public componentDidMount(): void {\n    let { delay } = this.props;\n    // eslint-disable-next-line no-restricted-globals\n    this._timeoutId = window.setTimeout(() => {\n      this.setState({\n        isRendered: true,\n      });\n    }, delay);\n  }\n\n  public componentWillUnmount(): void {\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId);\n    }\n  }\n\n  public render(): React.ReactElement<{}> | null {\n    return this.state.isRendered ? (React.Children.only(this.props.children) as React.ReactElement<{}>) : null;\n  }\n}\n", "declare const setTimeout: (cb: () => void, delay: number) => number;\n\n/**\n * PerfData interface.\n *\n * @internal\n */\nexport interface IPerfData {\n  duration: number;\n  timeStamp: number;\n}\n\n/**\n * PerfMeasurement interface.\n *\n * @internal\n */\nexport interface IPerfMeasurement {\n  totalDuration: number;\n  count: number;\n  all: IPerfData[];\n}\n\n/**\n * PerfSummary interface.\n *\n * @internal\n */\nexport interface IPerfSummary {\n  [key: string]: IPerfMeasurement;\n}\n\nconst now: () => number = () =>\n  typeof performance !== 'undefined' && !!performance.now ? performance.now() : Date.now();\n\nconst RESET_INTERVAL = 3 * 60 * 1000; // auto reset every 3 minutes\n\n/**\n * Performance helper class for measuring things.\n *\n * @public\n * {@docCategory FabricPerformance}\n */\nexport class FabricPerformance {\n  public static summary: IPerfSummary = {};\n  private static _timeoutId: number;\n\n  /**\n   * Measures execution time of the given syncronous function. If the same logic is executed multiple times,\n   * each individual measurement will be collected as well the overall numbers.\n   * @param name - The name of this measurement\n   * @param func - The logic to be measured for execution time\n   */\n  public static measure(name: string, func: () => void): void {\n    if (FabricPerformance._timeoutId) {\n      FabricPerformance.setPeriodicReset();\n    }\n    const start = now();\n    func();\n    const end = now();\n    const measurement: IPerfMeasurement = FabricPerformance.summary[name] || {\n      totalDuration: 0,\n      count: 0,\n      all: [],\n    };\n    const duration = end - start;\n    measurement.totalDuration += duration;\n    measurement.count++;\n    measurement.all.push({\n      duration,\n      timeStamp: end,\n    });\n    FabricPerformance.summary[name] = measurement;\n  }\n\n  public static reset(): void {\n    FabricPerformance.summary = {};\n    clearTimeout(FabricPerformance._timeoutId);\n    FabricPerformance._timeoutId = NaN;\n  }\n\n  public static setPeriodicReset(): void {\n    FabricPerformance._timeoutId = setTimeout(() => FabricPerformance.reset(), RESET_INTERVAL);\n  }\n}\n", "import { getWindow } from './dom/getWindow';\n\n/**\n * Storing global state in local module variables has issues when more than one copy\n * if the module gets loaded on the page (due to a bundling error or simply by consuming\n * a prebundled script.)\n *\n * This file contains helpers to deal with the getting and setting local state, and allows\n * callers to get called back when it mutates.\n */\n\nconst GLOBAL_SETTINGS_PROP_NAME = '__globalSettings__';\nconst CALLBACK_STATE_PROP_NAME = '__callbacks__';\n\nlet _counter = 0;\n\n/**\n * Change description used for change callbacks in GlobalSettings.\n *\n * @public\n * {@docCategory IChangeDescription}\n */\nexport interface IChangeDescription {\n  key: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  oldValue: any;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any;\n}\n\n/**\n * Change event callback.\n *\n * @public\n * {@docCategory IChangeEventCallback}\n */\nexport interface IChangeEventCallback {\n  __id__?: string;\n  (changeDescription?: IChangeDescription): void;\n}\n\n/**\n * Global settings helper, which stores settings in the global (window) namespace.\n * If window is not provided, it will store settings in module scope. Provides a\n * way to observe changes as well when their values change.\n *\n * @public\n * {@docCategory GlobalSettings}\n */\nexport class GlobalSettings {\n  public static getValue<T>(key: string, defaultValue?: T | (() => T)): T {\n    const globalSettings = _getGlobalSettings();\n\n    if (globalSettings[key] === undefined) {\n      globalSettings[key] = typeof defaultValue === 'function' ? (defaultValue as Function)() : defaultValue;\n    }\n\n    return globalSettings[key];\n  }\n\n  public static setValue<T>(key: string, value: T): T {\n    const globalSettings = _getGlobalSettings();\n    const callbacks = globalSettings[CALLBACK_STATE_PROP_NAME];\n    let oldValue = globalSettings[key];\n\n    if (value !== oldValue) {\n      globalSettings[key] = value;\n\n      let changeDescription = {\n        oldValue,\n        value,\n        key,\n      };\n\n      for (let id in callbacks) {\n        if (callbacks.hasOwnProperty(id)) {\n          callbacks[id](changeDescription);\n        }\n      }\n    }\n\n    return value;\n  }\n\n  public static addChangeListener(cb: IChangeEventCallback): void {\n    // Note: we use generated ids on the callbacks to create a map of the callbacks, which optimizes removal.\n    // (It's faster to delete a key than it is to look up the index of an object and splice an array.)\n    let id = cb.__id__;\n    const callbacks = _getCallbacks();\n\n    if (!id) {\n      id = cb.__id__ = String(_counter++);\n    }\n\n    callbacks[id] = cb;\n  }\n\n  public static removeChangeListener(cb: IChangeEventCallback): void {\n    const callbacks = _getCallbacks();\n    delete callbacks[cb.__id__ as string];\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _getGlobalSettings(): { [key: string]: any } {\n  const win = getWindow();\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const globalObj: { [key: string]: any } = win || {};\n\n  if (!globalObj[GLOBAL_SETTINGS_PROP_NAME]) {\n    globalObj[GLOBAL_SETTINGS_PROP_NAME] = {\n      [CALLBACK_STATE_PROP_NAME]: {},\n    };\n  }\n\n  return globalObj[GLOBAL_SETTINGS_PROP_NAME];\n}\n\nfunction _getCallbacks(): { [key: string]: () => void } {\n  const globalSettings = _getGlobalSettings();\n  return globalSettings[CALLBACK_STATE_PROP_NAME];\n}\n", "/**\n * Simulated enum for keycodes. These will get inlined by uglify when used much like an enum\n *\n * @public\n * {@docCategory KeyCodes}\n */\nexport const KeyCodes = {\n  backspace: 8 as 8,\n  tab: 9 as 9,\n  enter: 13 as 13,\n  shift: 16 as 16,\n  ctrl: 17 as 17,\n  alt: 18 as 18,\n  pauseBreak: 19 as 19,\n  capslock: 20 as 20,\n  escape: 27 as 27,\n  space: 32 as 32,\n  pageUp: 33 as 33,\n  pageDown: 34 as 34,\n  end: 35 as 35,\n  home: 36 as 36,\n  left: 37 as 37,\n  up: 38 as 38,\n  right: 39 as 39,\n  down: 40 as 40,\n  insert: 45 as 45,\n  del: 46 as 46,\n  zero: 48 as 48,\n  one: 49 as 49,\n  two: 50 as 50,\n  three: 51 as 51,\n  four: 52 as 52,\n  five: 53 as 53,\n  six: 54 as 54,\n  seven: 55 as 55,\n  eight: 56 as 56,\n  nine: 57 as 57,\n  colon: 58 as 58,\n  a: 65 as 65,\n  b: 66 as 66,\n  c: 67 as 67,\n  d: 68 as 68,\n  e: 69 as 69,\n  f: 70 as 70,\n  g: 71 as 71,\n  h: 72 as 72,\n  i: 73 as 73,\n  j: 74 as 74,\n  k: 75 as 75,\n  l: 76 as 76,\n  m: 77 as 77,\n  n: 78 as 78,\n  o: 79 as 79,\n  p: 80 as 80,\n  q: 81 as 81,\n  r: 82 as 82,\n  s: 83 as 83,\n  t: 84 as 84,\n  u: 85 as 85,\n  v: 86 as 86,\n  w: 87 as 87,\n  x: 88 as 88,\n  y: 89 as 89,\n  z: 90 as 90,\n  leftWindow: 91 as 91,\n  rightWindow: 92 as 92,\n  select: 93 as 93,\n  /* eslint-disable @typescript-eslint/naming-convention */\n  zero_numpad: 96 as 96,\n  one_numpad: 97 as 97,\n  two_numpad: 98 as 98,\n  three_numpad: 99 as 99,\n  four_numpad: 100 as 100,\n  five_numpad: 101 as 101,\n  six_numpad: 102 as 102,\n  seven_numpad: 103 as 103,\n  eight_numpad: 104 as 104,\n  nine_numpad: 105 as 105,\n  /* eslint-enable @typescript-eslint/naming-convention */\n  multiply: 106 as 106,\n  add: 107 as 107,\n  subtract: 109 as 109,\n  decimalPoint: 110 as 110,\n  divide: 111 as 111,\n  f1: 112 as 112,\n  f2: 113 as 113,\n  f3: 114 as 114,\n  f4: 115 as 115,\n  f5: 116 as 116,\n  f6: 117 as 117,\n  f7: 118 as 118,\n  f8: 119 as 119,\n  f9: 120 as 120,\n  f10: 121 as 121,\n  f11: 122 as 122,\n  f12: 123 as 123,\n  numlock: 144 as 144,\n  scrollLock: 145 as 145,\n  semicolon: 186 as 186,\n  equalSign: 187 as 187,\n  comma: 188 as 188,\n  dash: 189 as 189,\n  period: 190 as 190,\n  forwardSlash: 191 as 191,\n  graveAccent: 192 as 192,\n  openBracket: 219 as 219,\n  backSlash: 220 as 220,\n  closeBracket: 221 as 221,\n  singleQuote: 222 as 222,\n};\nexport type KeyCodes = number;\n", "/**\n * Rectangle helper class.\n *\n * @public\n * {@docCategory Rectangle}\n */\nexport class Rectangle {\n  public top: number;\n  public bottom: number;\n  public left: number;\n  public right: number;\n\n  constructor(left: number = 0, right: number = 0, top: number = 0, bottom: number = 0) {\n    this.top = top;\n    this.bottom = bottom;\n    this.left = left;\n    this.right = right;\n  }\n\n  /**\n   * Calculated automatically by subtracting the right from left\n   */\n  public get width(): number {\n    return this.right - this.left;\n  }\n\n  /**\n   * Calculated automatically by subtracting the bottom from top.\n   */\n  public get height(): number {\n    return this.bottom - this.top;\n  }\n\n  /**\n   * Tests if another rect is approximately equal to this rect (within 4 decimal places.)\n   */\n  public equals(rect: Rectangle): boolean {\n    // Fixing to 4 decimal places because it allows enough precision and will handle cases when something\n    // should be rounded, like .999999 should round to 1.\n    return (\n      parseFloat(this.top.toFixed(4)) === parseFloat(rect.top.toFixed(4)) &&\n      parseFloat(this.bottom.toFixed(4)) === parseFloat(rect.bottom.toFixed(4)) &&\n      parseFloat(this.left.toFixed(4)) === parseFloat(rect.left.toFixed(4)) &&\n      parseFloat(this.right.toFixed(4)) === parseFloat(rect.right.toFixed(4))\n    );\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Returns a single function which will call each of the given functions in the context of the\n * parent.\n */\nexport function appendFunction(parent: any, ...functions: any[]): () => void {\n  if (functions.length < 2) {\n    return functions[0] as () => void;\n  }\n\n  return (...args: any[]): void => {\n    functions.forEach((f: () => void) => f && f.apply(parent, args));\n  };\n}\n", "/**\n * ARIA helper to concatenate attributes, returning undefined if all attributes\n * are undefined. (Empty strings are not a valid ARIA attribute value.)\n *\n * @param ariaAttributes - ARIA attributes to merge\n */\nexport function mergeAriaAttributeValues(...ariaAttributes: (string | undefined | false)[]): string | undefined {\n  const mergedAttribute = ariaAttributes\n    .filter((arg: string | undefined | false) => arg)\n    .join(' ')\n    .trim();\n  return mergedAttribute === '' ? undefined : mergedAttribute;\n}\n", "/**\n * Helper to find the index of an item within an array, using a callback to\n * determine the match.\n *\n * @public\n * @param array - Array to search.\n * @param cb - Callback which returns true on matches.\n * @param fromIndex - Optional index to start from (defaults to 0)\n */\nexport function findIndex<T>(array: T[], cb: (item: T, index: number) => boolean, fromIndex: number = 0): number {\n  let index = -1;\n\n  for (let i = fromIndex; array && i < array.length; i++) {\n    if (cb(array[i], i)) {\n      index = i;\n      break;\n    }\n  }\n\n  return index;\n}\n\n/**\n * Helper to find the first item within an array that satisfies the callback.\n * @param array - Array to search\n * @param cb - Callback which returns true on matches\n */\nexport function find<T>(array: T[], cb: (item: T, index: number) => boolean): T | undefined {\n  let index = findIndex(array, cb);\n\n  if (index < 0) {\n    return undefined;\n  }\n\n  return array[index];\n}\n\n/**\n * Creates an array of a given size and helper method to populate.\n *\n * @public\n * @param size - Size of array.\n * @param getItem - Callback to populate given cell index.\n */\nexport function createArray<T>(size: number, getItem: (index: number) => T): T[] {\n  let array: T[] = [];\n\n  for (let i = 0; i < size; i++) {\n    array.push(getItem(i));\n  }\n\n  return array;\n}\n\n/**\n * Convert the given array to a matrix with columnCount number\n * of columns.\n *\n * @public\n * @param items - The array to convert\n * @param columnCount - The number of columns for the resulting matrix\n * @returns A matrix of items\n */\nexport function toMatrix<T>(items: T[], columnCount: number): T[][] {\n  return items.reduce((rows: T[][], currentValue: T, index: number) => {\n    if (index % columnCount === 0) {\n      rows.push([currentValue]);\n    } else {\n      rows[rows.length - 1].push(currentValue);\n    }\n    return rows;\n  }, [] as T[][]);\n}\n\n/**\n * Given an array, it returns a new array that does not contain the item at the given index.\n * @param array - The array to operate on\n * @param index - The index of the element to remove\n */\nexport function removeIndex<T>(array: T[], index: number): T[] {\n  return array.filter((_: T, i: number) => index !== i);\n}\n\n/**\n * Given an array, this function returns a new array where the element at a given index has been replaced.\n * @param array - The array to operate on\n * @param newElement - The element that will be placed in the new array\n * @param index - The index of the element that should be replaced\n */\nexport function replaceElement<T>(array: T[], newElement: T, index: number): T[] {\n  const copy = array.slice();\n  copy[index] = newElement;\n  return copy;\n}\n\n/**\n * Given an array, this function returns a new array where an element has been inserted at the given index.\n * @param array - The array to operate on\n * @param index - The index where an element should be inserted\n * @param itemToAdd - The element to insert\n */\nexport function addElementAtIndex<T>(array: T[], index: number, itemToAdd: T): T[] {\n  const copy = array.slice();\n  copy.splice(index, 0, itemToAdd);\n  return copy;\n}\n\n/**\n * Given an array where each element is of type T or T[], flatten it into an array of T\n * @param array - The array where each element can optionally also be an array\n */\nexport function flatten<T>(array: (T | T[])[]): T[] {\n  let result: T[] = [];\n  array.forEach((item: T | T[]): T[] => (result = result.concat(item)));\n  return result;\n}\n\n/**\n * Returns a boolean indicating if the two given arrays are equal in length and values.\n *\n * @param array1 - First array to compare\n * @param array2 - Second array to compare\n * @returns True if the arrays are the same length and have the same values in the same positions, false otherwise.\n */\nexport function arraysEqual<T>(array1: T[], array2: T[]): boolean {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n  for (let i = 0; i < array1.length; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n", "/**\n * asAsync - a HOC for async loading components.\n *\n * Usage:\n *\n * const AsyncDialog = asAsync({\n *   load: () => import('Dialog').then(result => result.default),\n * });\n *\n * React.render(domElement, <AsyncDialog asyncPlaceholder={ () => <Spinner/> } { ...dialogProps } />);\n *\n * Note the `asyncPlaceholder` prop will be respected when rendering the async component and it hasn't\n * been loaded yet.\n */\n\nimport * as React from 'react';\n\nexport interface IAsAsyncOptions<TProps> {\n  /**\n   * Callback which returns a promise resolving an object which exports the component.\n   */\n  load: () => Promise<React.ElementType<TProps>>;\n\n  /**\n   * Callback executed when async loading is complete.\n   */\n  onLoad?: () => void;\n\n  /**\n   * Callback when async loading fails.\n   */\n  onError?: (error: Error) => void;\n}\n\n/**\n * If possible, use a WeakMap to maintain a cache of loaded components.\n * This can be used to synchronously render components that have already been loaded,\n * rather than having to wait for at least one async tick.\n */\nconst _syncModuleCache =\n  typeof WeakMap !== 'undefined'\n    ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      new WeakMap<() => Promise<React.ElementType<any>>, React.ElementType<any> | undefined>()\n    : undefined;\n\n/**\n * Produces a component which internally loads the target component before first mount.\n * The component passes all props through to the loaded component.\n *\n * This overload accepts a module with a default export for the component.\n */\nexport function asAsync<TProps extends {}>(options: IAsAsyncOptions<TProps>) {\n  class Async extends React.Component<\n    TProps & {\n      asyncPlaceholder?: React.ElementType;\n      forwardedRef: React.Ref<React.ElementType<TProps>>;\n    },\n    { Component?: React.ElementType<TProps> }\n  > {\n    public state = {\n      Component: _syncModuleCache ? (_syncModuleCache.get(options.load) as React.ElementType<TProps>) : undefined,\n    };\n\n    public render(): JSX.Element | null {\n      // Typescript issue: the rest can't be pulled without the any cast, as TypeScript fails with rest on generics.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const { forwardedRef, asyncPlaceholder: Placeholder, ...rest } = this.props as any;\n      const { Component } = this.state;\n      return Component ? (\n        React.createElement(Component, { ...rest, ref: forwardedRef })\n      ) : Placeholder ? (\n        <Placeholder />\n      ) : null;\n    }\n\n    public componentDidMount(): void {\n      let { Component } = this.state;\n\n      if (!Component) {\n        options\n          .load()\n          .then((LoadedComponent: React.ElementType<TProps>) => {\n            if (LoadedComponent) {\n              // Cache component for future reference.\n              _syncModuleCache && _syncModuleCache.set(options.load, LoadedComponent);\n\n              // Set state.\n              this.setState(\n                {\n                  Component: LoadedComponent,\n                },\n                options.onLoad,\n              );\n            }\n          })\n          .catch(options.onError);\n      }\n    }\n  }\n\n  return React.forwardRef<React.ElementType<TProps>, TProps & { asyncPlaceholder?: React.ElementType }>(\n    (props, ref) => <Async {...props} forwardedRef={ref} />,\n  );\n}\n", "/**\n * AssertNever is a utility function that can be used for exhaustiveness checks in switch statements.\n *\n * @public\n */\nexport function assertNever(x: never): never {\n  throw new Error('Unexpected object: ' + x);\n}\n", "import { getWindow } from './dom/getWindow';\n\n/**\n * Fetches an item from session storage without throwing an exception\n * @param key The key of the item to fetch from session storage\n */\nexport function getItem(key: string): string | null {\n  let result = null;\n  try {\n    const win = getWindow();\n    result = win ? win.sessionStorage.getItem(key) : null;\n  } catch (e) {\n    /* Eat the exception */\n  }\n  return result;\n}\n\n/**\n * Inserts an item into session storage without throwing an exception\n * @param key The key of the item to add to session storage\n * @param data The data to put into session storage\n */\nexport function setItem(key: string, data: string): void {\n  try {\n    getWindow()?.sessionStorage.setItem(key, data);\n  } catch (e) {\n    /* Eat the exception */\n  }\n}\n", "import { KeyCodes } from './KeyCodes';\nimport { getDocument } from './dom/getDocument';\nimport { getItem, setItem } from './sessionStorage';\nimport { setRTL as mergeStylesSetRTL } from '@fluentui/merge-styles';\n\nconst RTL_LOCAL_STORAGE_KEY = 'isRTL';\n\n// Default to undefined so that we initialize on first read.\nlet _isRTL: boolean | undefined;\n\n/**\n * Gets the rtl state of the page (returns true if in rtl.)\n */\nexport function getRTL(theme: { rtl?: boolean } = {}): boolean {\n  if (theme.rtl !== undefined) {\n    return theme.rtl;\n  }\n  if (_isRTL === undefined) {\n    // Fabric supports persisting the RTL setting between page refreshes via session storage\n    let savedRTL = getItem(RTL_LOCAL_STORAGE_KEY);\n    if (savedRTL !== null) {\n      _isRTL = savedRTL === '1';\n      setRTL(_isRTL);\n    }\n\n    let doc = getDocument();\n    if (_isRTL === undefined && doc) {\n      _isRTL = ((doc.body && doc.body.getAttribute('dir')) || doc.documentElement.getAttribute('dir')) === 'rtl';\n      mergeStylesSetRTL(_isRTL);\n    }\n  }\n\n  return !!_isRTL;\n}\n\n/**\n * Sets the rtl state of the page (by adjusting the dir attribute of the html element.)\n */\nexport function setRTL(isRTL: boolean, persistSetting: boolean = false): void {\n  let doc = getDocument();\n  if (doc) {\n    doc.documentElement.setAttribute('dir', isRTL ? 'rtl' : 'ltr');\n  }\n\n  if (persistSetting) {\n    setItem(RTL_LOCAL_STORAGE_KEY, isRTL ? '1' : '0');\n  }\n\n  _isRTL = isRTL;\n  mergeStylesSetRTL(_isRTL);\n}\n\n/**\n * Returns the given key, but flips right/left arrows if necessary.\n */\nexport function getRTLSafeKeyCode(key: number, theme: { rtl?: boolean } = {}): number {\n  if (getRTL(theme)) {\n    if (key === KeyCodes.left) {\n      key = KeyCodes.right;\n    } else if (key === KeyCodes.right) {\n      key = KeyCodes.left;\n    }\n  }\n\n  return key;\n}\n", "import { mergeCssSets, Stylesheet } from '@fluentui/merge-styles';\nimport { getRTL } from './rtl';\nimport { getWindow } from './dom';\nimport type { IStyleSet, IStyleSetBase, IProcessedStyleSet, IStyleFunctionOrObject } from '@fluentui/merge-styles';\nimport type { StyleFunction } from './styled';\n\nconst MAX_CACHE_COUNT = 50;\nconst DEFAULT_SPECIFICITY_MULTIPLIER = 5;\n\nlet _memoizedClassNames = 0;\n\nconst stylesheet = Stylesheet.getInstance();\n\nif (stylesheet && stylesheet.onReset) {\n  stylesheet.onReset(() => _memoizedClassNames++);\n}\n\n// Note that because of the caching nature within the classNames memoization,\n// I've disabled this rule to simply be able to work with any types.\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// This represents a prop we attach to each Map to indicate the cached return value\n// associated with the graph node.\nconst retVal = '__retval__';\n\ninterface IRecursiveMemoNode extends Map<any, IRecursiveMemoNode> {\n  [retVal]?: string;\n}\n\ntype AppWindow = (Window & { FabricConfig?: { enableClassNameCacheFullWarning?: boolean } }) | undefined;\n\nexport interface IClassNamesFunctionOptions {\n  /**\n   * Disables class caching for scenarios where styleProp parts mutate frequently.\n   */\n  disableCaching?: boolean;\n\n  /**\n   * Size of the cache. It overwrites default cache size when defined.\n   */\n  cacheSize?: number;\n\n  /**\n   * Set to true if component base styles are implemented in scss instead of css-in-js.\n   */\n  useStaticStyles?: boolean;\n}\n\n/**\n * Creates a getClassNames function which calls getStyles given the props, and injects them\n * into mergeStyleSets.\n *\n * Note that the props you pass in on every render should be in the same order and\n * immutable (numbers, strings, and booleans). This will allow the results to be memoized. Violating\n * these will cause extra recalcs to occur.\n */\nexport function classNamesFunction<TStyleProps extends {}, TStyleSet extends IStyleSetBase>(\n  options: IClassNamesFunctionOptions = {},\n): (\n  getStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined,\n  styleProps?: TStyleProps,\n) => IProcessedStyleSet<TStyleSet> {\n  // We build a trie where each node is a Map. The map entry key represents an argument\n  // value, and the entry value is another node (Map). Each node has a `__retval__`\n  // property which is used to hold the cached response.\n\n  // To derive the response, we can simply ensure the arguments are added or already\n  // exist in the trie. At the last node, if there is a `__retval__` we return that. Otherwise\n  // we call the `getStyles` api to evaluate, cache on the property, and return that.\n  // let map: IRecursiveMemoNode = new Map();\n  let windowMap: Map<'__default__' | Window, IRecursiveMemoNode> = new Map();\n  let styleCalcCount = 0;\n  let getClassNamesCount = 0;\n  let currentMemoizedClassNames = _memoizedClassNames;\n\n  const getClassNames = (\n    styleFunctionOrObject: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined,\n    styleProps: TStyleProps = {} as TStyleProps,\n  ): IProcessedStyleSet<TStyleSet> => {\n    // If useStaticStyles is true, styleFunctionOrObject returns slot to classname mappings.\n    // If there is also no style overrides, we can skip merge styles completely and\n    // simply return the result from the style funcion.\n    if (\n      options.useStaticStyles &&\n      typeof styleFunctionOrObject === 'function' &&\n      (styleFunctionOrObject as StyleFunction<TStyleProps, TStyleSet>).__noStyleOverride__\n    ) {\n      return styleFunctionOrObject(styleProps) as IProcessedStyleSet<TStyleSet>;\n    }\n\n    getClassNamesCount++;\n    const shadowConfig = styleFunctionOrObject\n      ? (styleFunctionOrObject as StyleFunction<TStyleProps, TStyleSet>).__shadowConfig__\n      : undefined;\n    const key = shadowConfig && shadowConfig.window ? shadowConfig.window : '__default__';\n\n    if (!windowMap.has(key)) {\n      windowMap.set(key, new Map());\n    }\n    let current: Map<any, any> = windowMap.get(key)!;\n\n    // let current: Map<any, any> = map;\n    const { theme } = styleProps as any;\n    const rtl = theme && theme.rtl !== undefined ? theme.rtl : getRTL();\n\n    const disableCaching = options.disableCaching;\n\n    // On reset of our stylesheet, reset memoized cache.\n    if (currentMemoizedClassNames !== _memoizedClassNames) {\n      currentMemoizedClassNames = _memoizedClassNames;\n      // map = new Map();\n      windowMap.set(key, new Map());\n      current = windowMap.get(key)!;\n      styleCalcCount = 0;\n    }\n\n    if (!options.disableCaching) {\n      current = _traverseMap(windowMap.get(key)!, styleFunctionOrObject as any);\n      current = _traverseMap(current, styleProps);\n    }\n\n    if (disableCaching || !(current as any)[retVal]) {\n      if (styleFunctionOrObject === undefined) {\n        (current as any)[retVal] = {} as IProcessedStyleSet<TStyleSet>;\n      } else {\n        (current as any)[retVal] = mergeCssSets(\n          [\n            (typeof styleFunctionOrObject === 'function'\n              ? styleFunctionOrObject(styleProps)\n              : styleFunctionOrObject) as IStyleSet<TStyleSet>,\n          ],\n          {\n            shadowConfig: (styleFunctionOrObject as StyleFunction<TStyleProps, TStyleSet>).__shadowConfig__,\n            rtl: !!rtl,\n            specificityMultiplier: options.useStaticStyles ? DEFAULT_SPECIFICITY_MULTIPLIER : undefined,\n          },\n        );\n      }\n\n      if (!disableCaching) {\n        styleCalcCount++;\n      }\n    }\n\n    if (styleCalcCount > (options.cacheSize || MAX_CACHE_COUNT)) {\n      const win = getWindow() as AppWindow;\n      if (win?.FabricConfig?.enableClassNameCacheFullWarning) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Styles are being recalculated too frequently. Cache miss rate is ${styleCalcCount}/${getClassNamesCount}.`,\n        );\n        // eslint-disable-next-line no-console\n        console.trace();\n      }\n\n      windowMap.get(key)!.clear();\n      styleCalcCount = 0;\n\n      // Mutate the options passed in, that's all we can do.\n      options.disableCaching = true;\n    }\n\n    // Note: the retVal is an attached property on the Map; not a key in the Map. We use this attached property to\n    // cache the return value for this branch of the graph.\n    return (current as any)[retVal];\n  };\n\n  return getClassNames;\n}\n\nfunction _traverseEdge(current: Map<any, any>, value: any): Map<any, any> {\n  value = _normalizeValue(value);\n\n  if (!current.has(value)) {\n    current.set(value, new Map<any, any>());\n  }\n\n  return current.get(value);\n}\n\nfunction _traverseMap(current: Map<any, any>, inputs: any[] | Object): Map<any, any> {\n  if (typeof inputs === 'function') {\n    const cachedInputsFromStyled = (inputs as StyleFunction<any, any>).__cachedInputs__;\n    if (cachedInputsFromStyled) {\n      // The styled helper will generate the styles function and will attach the cached\n      // inputs (consisting of the default styles, customzied styles, and user provided styles.)\n      // These should be used as cache keys for deriving the memoized value.\n      for (const input of (inputs as any).__cachedInputs__) {\n        current = _traverseEdge(current, input);\n      }\n    } else {\n      current = _traverseEdge(current, inputs);\n    }\n  } else if (typeof inputs === 'object') {\n    for (const propName in inputs) {\n      if (inputs.hasOwnProperty(propName)) {\n        current = _traverseEdge(current, (inputs as any)[propName]);\n      }\n    }\n  }\n\n  return current;\n}\n\nfunction _normalizeValue(value: any): string {\n  switch (value) {\n    case undefined:\n      return '__undefined__';\n    case null:\n      return '__null__';\n    default:\n      return value;\n  }\n}\n", "import * as React from 'react';\nimport { createMemoizer } from '../memoize';\nimport type { IComponentAs, IComponentAsProps } from '../IComponentAs';\n\ninterface IComposeComponentAs {\n  <TProps extends {}>(outer: IComponentAs<TProps>): (inner: IComponentAs<TProps>) => IComponentAs<TProps>;\n}\n\nfunction createComposedComponent<TProps extends {}>(\n  outer: IComponentAs<TProps>,\n): (inner: IComponentAs<TProps>) => IComponentAs<TProps> {\n  const Outer = outer;\n\n  const outerMemoizer = createMemoizer((inner: IComponentAs<TProps>) => {\n    if (outer === inner) {\n      throw new Error('Attempted to compose a component with itself.');\n    }\n\n    const Inner = inner;\n\n    const innerMemoizer = createMemoizer((defaultRender: IComponentAs<TProps>) => {\n      const InnerWithDefaultRender: React.ComponentType<IComponentAsProps<TProps>> = (\n        innerProps: IComponentAsProps<TProps>,\n      ): JSX.Element => {\n        return <Inner {...innerProps} defaultRender={defaultRender} />;\n      };\n\n      return InnerWithDefaultRender;\n    });\n\n    const OuterWithDefaultRender: React.ComponentType<IComponentAsProps<TProps>> = (\n      outerProps: IComponentAsProps<TProps>,\n    ): JSX.Element => {\n      const { defaultRender } = outerProps;\n\n      return <Outer {...outerProps} defaultRender={defaultRender ? innerMemoizer(defaultRender) : Inner} />;\n    };\n\n    return OuterWithDefaultRender;\n  });\n\n  return outerMemoizer;\n}\n\nconst componentAsMemoizer = createMemoizer<IComposeComponentAs>(createComposedComponent);\n\n/**\n * Composes two components which conform to the `IComponentAs` specification; that is, two\n * components which accept a `defaultRender` prop, which is a 'default' implementation of\n * a component which accepts the same overall props.\n *\n * @public\n */\nexport function composeComponentAs<TProps extends {}>(\n  outer: IComponentAs<TProps>,\n  inner: IComponentAs<TProps>,\n): IComponentAs<TProps> {\n  return componentAsMemoizer(outer)(inner);\n}\n", "import { Stylesheet } from '@fluentui/merge-styles';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\ndeclare class WeakMap {\n  public get(key: any): any;\n  public set(key: any, value: any): void;\n  public has(key: any): boolean;\n}\n\nlet _initializedStylesheetResets = false;\nlet _resetCounter = 0;\nconst _emptyObject = { empty: true };\nconst _dictionary: any = {};\nlet _weakMap = typeof WeakMap === 'undefined' ? null : WeakMap;\n\ninterface IMemoizeNode {\n  map: WeakMap | null;\n  value?: any;\n}\n\n/**\n *  Test utility for providing a custom weakmap.\n *\n * @internal\n * */\nexport function setMemoizeWeakMap(weakMap: any): void {\n  _weakMap = weakMap;\n}\n\n/**\n * Reset memoizations.\n */\nexport function resetMemoizations(): void {\n  _resetCounter++;\n}\n\n/**\n * Memoize decorator to be used on class methods. WARNING: the `this` reference\n * will be inaccessible within a memoized method, given that a cached method's `this`\n * would not be instance-specific.\n *\n * @public\n */\nexport function memoize<T extends Function>(\n  _target: any,\n  _key: string,\n  descriptor: TypedPropertyDescriptor<T>,\n): {\n  configurable: boolean;\n  get(): T;\n} {\n  // We bind to \"null\" to prevent people from inadvertently pulling values from \"this\",\n  // rather than passing them in as input values which can be memoized.\n  let fn = memoizeFunction(descriptor.value && descriptor.value.bind(null));\n\n  return {\n    configurable: true,\n    get(): T {\n      return fn;\n    },\n  };\n}\n\n/**\n * Memoizes a function; when you pass in the same parameters multiple times, it returns a cached result.\n * Be careful when passing in objects, you need to pass in the same INSTANCE for caching to work. Otherwise\n * it will grow the cache unnecessarily. Also avoid using default values that evaluate functions; passing in\n * undefined for a value and relying on a default function will execute it the first time, but will not\n * re-evaluate subsequent times which may have been unexpected.\n *\n * By default, the cache will reset after 100 permutations, to avoid abuse cases where the function is\n * unintendedly called with unique objects. Without a reset, the cache could grow infinitely, so we safeguard\n * by resetting. To override this behavior, pass a value of 0 to the maxCacheSize parameter.\n *\n * @public\n * @param cb - The function to memoize.\n * @param maxCacheSize - Max results to cache. If the cache exceeds this value, it will reset on the next call.\n * @param ignoreNullOrUndefinedResult - Flag to decide whether to cache callback result if it is undefined/null.\n * If the flag is set to true, the callback result is recomputed every time till the callback result is\n * not undefined/null for the first time, and then the non-undefined/null version gets cached.\n * @returns A memoized version of the function.\n */\nexport function memoizeFunction<T extends (...args: any[]) => RetType, RetType>(\n  cb: T,\n  maxCacheSize: number = 100,\n  ignoreNullOrUndefinedResult: boolean = false,\n): T {\n  // Avoid breaking scenarios which don't have weak map.\n  if (!_weakMap) {\n    return cb;\n  }\n\n  if (!_initializedStylesheetResets) {\n    const stylesheet = Stylesheet.getInstance();\n\n    if (stylesheet && (stylesheet as { onReset?: unknown }).onReset) {\n      Stylesheet.getInstance().onReset(resetMemoizations);\n    }\n    _initializedStylesheetResets = true;\n  }\n\n  let rootNode: any;\n  let cacheSize = 0;\n  let localResetCounter = _resetCounter;\n\n  return function memoizedFunction(...args: any[]): RetType {\n    let currentNode: any = rootNode;\n\n    if (\n      rootNode === undefined ||\n      localResetCounter !== _resetCounter ||\n      (maxCacheSize > 0 && cacheSize > maxCacheSize)\n    ) {\n      rootNode = _createNode();\n      cacheSize = 0;\n      localResetCounter = _resetCounter;\n    }\n\n    currentNode = rootNode;\n\n    // Traverse the tree until we find the match.\n    for (let i = 0; i < args.length; i++) {\n      let arg = _normalizeArg(args[i]);\n\n      if (!currentNode.map.has(arg)) {\n        currentNode.map.set(arg, _createNode());\n      }\n\n      currentNode = currentNode.map.get(arg);\n    }\n\n    if (!currentNode.hasOwnProperty('value')) {\n      currentNode.value = cb(...args);\n      cacheSize++;\n    }\n\n    if (ignoreNullOrUndefinedResult && (currentNode.value === null || currentNode.value === undefined)) {\n      currentNode.value = cb(...args);\n    }\n\n    return currentNode.value;\n  } as any;\n}\n\n/**\n * Creates a memoizer for a single-value function, backed by a WeakMap.\n * With a WeakMap, the memoized values are only kept as long as the source objects,\n * ensuring that there is no memory leak.\n *\n * This function assumes that the input values passed to the wrapped function will be\n * `function` or `object` types. To memoize functions which accept other inputs, use\n * `memoizeFunction`, which memoizes against arbitrary inputs using a lookup cache.\n *\n * @public\n */\nexport function createMemoizer<F extends (input: any) => any>(getValue: F): F {\n  if (!_weakMap) {\n    // Without a `WeakMap` implementation, memoization is not possible.\n    return getValue;\n  }\n\n  const cache = new _weakMap();\n\n  function memoizedGetValue(input: any): any {\n    if (!input || (typeof input !== 'function' && typeof input !== 'object')) {\n      // A WeakMap can only be used to test against reference values, i.e. 'function' and 'object'.\n      // All other inputs cannot be memoized against in this manner.\n      return getValue(input);\n    }\n\n    if (cache.has(input)) {\n      return cache.get(input)!;\n    }\n\n    const value = getValue(input);\n\n    cache.set(input, value);\n\n    return value;\n  }\n\n  return memoizedGetValue as F;\n}\n\nfunction _normalizeArg(val: null | undefined): { empty: boolean } | any;\nfunction _normalizeArg(val: object): any;\nfunction _normalizeArg(val: any): any {\n  if (!val) {\n    return _emptyObject;\n  } else if (typeof val === 'object' || typeof val === 'function') {\n    return val;\n  } else if (!_dictionary[val]) {\n    _dictionary[val] = { val };\n  }\n\n  return _dictionary[val];\n}\n\nfunction _createNode(): IMemoizeNode {\n  return {\n    map: _weakMap ? new _weakMap() : null,\n  };\n}\n", "/**\n * Determines whether a component is controlled.\n * @param props - Component props\n * @param valueProp - Prop containing the controlled value\n * @returns true if controlled, false if uncontrolled\n */\nexport function isControlled<P>(props: P, valueProp: keyof P): boolean {\n  // React's built-in <input> considers a prop to be provided if its value is non-null/undefined.\n  // Mirror that behavior here (rather than checking for just undefined).\n  return props[valueProp] !== undefined && props[valueProp] !== null;\n}\n", "/**\n * Dictionary of booleans.\n *\n * @internal\n */\nexport interface IDictionary {\n  [className: string]: boolean;\n}\n\n/**\n * Serializable object.\n *\n * @internal\n */\nexport interface ISerializableObject {\n  toString?: () => string;\n}\n\n/**\n * css input type.\n *\n * @internal\n */\nexport type ICssInput = string | ISerializableObject | IDictionary | null | undefined | boolean;\n\n/**\n * Concatination helper, which can merge class names together. Skips over falsey values.\n *\n * @public\n */\nexport function css(...args: ICssInput[]): string {\n  let classes = [];\n\n  for (let arg of args) {\n    if (arg) {\n      if (typeof arg === 'string') {\n        classes.push(arg);\n      } else if (arg.hasOwnProperty('toString') && typeof arg.toString === 'function') {\n        classes.push(arg.toString());\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        for (let key in arg as any) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          if ((arg as any)[key]) {\n            classes.push(key);\n          }\n        }\n      }\n    }\n  }\n\n  return classes.join(' ');\n}\n", "import { GlobalSettings } from '../GlobalSettings';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ISettings = { [key: string]: any };\nexport type ISettingsFunction = (settings: ISettings) => ISettings;\n\n/**\n * @deprecated Use ISettings.\n */\nexport type Settings = ISettings;\n\n/**\n * @deprecated Use ISettingsFunction.\n */\nexport type SettingsFunction = ISettingsFunction;\n\nexport interface ICustomizations {\n  settings: ISettings;\n  scopedSettings: { [key: string]: ISettings };\n  inCustomizerContext?: boolean;\n}\n\nconst CustomizationsGlobalKey = 'customizations';\nconst NO_CUSTOMIZATIONS = { settings: {}, scopedSettings: {}, inCustomizerContext: false };\n\nlet _allSettings = GlobalSettings.getValue<ICustomizations>(CustomizationsGlobalKey, {\n  settings: {},\n  scopedSettings: {},\n  inCustomizerContext: false,\n});\n\nlet _events: (() => void)[] = [];\n\nexport class Customizations {\n  private static _suppressUpdates: boolean;\n\n  public static reset(): void {\n    _allSettings.settings = {};\n    _allSettings.scopedSettings = {};\n  }\n\n  /** Apply global Customization settings.\n   * @example Customizations.applySettings(\\{ theme: \\{...\\} \\});\n   */\n  public static applySettings(settings: ISettings): void {\n    _allSettings.settings = { ..._allSettings.settings, ...settings };\n    Customizations._raiseChange();\n  }\n\n  /** Apply Customizations to a particular named scope, like a component.\n   * @example Customizations.applyScopedSettings('Nav', \\{ styles: () =\\> \\{\\} \\});\n   */\n  public static applyScopedSettings(scopeName: string, settings: ISettings): void {\n    _allSettings.scopedSettings[scopeName] = { ..._allSettings.scopedSettings[scopeName], ...settings };\n    Customizations._raiseChange();\n  }\n\n  public static getSettings(\n    properties: string[],\n    scopeName?: string,\n    localSettings: ICustomizations = NO_CUSTOMIZATIONS,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): any {\n    const settings: ISettings = {};\n    const localScopedSettings = (scopeName && localSettings.scopedSettings[scopeName]) || {};\n    const globalScopedSettings = (scopeName && _allSettings.scopedSettings[scopeName]) || {};\n\n    for (let property of properties) {\n      settings[property] =\n        localScopedSettings[property] ||\n        localSettings.settings[property] ||\n        globalScopedSettings[property] ||\n        _allSettings.settings[property];\n    }\n\n    return settings;\n  }\n\n  /** Used to run some code that sets Customizations without triggering an update until the end.\n   * Useful for applying Customizations that don't affect anything currently rendered, or for\n   * applying many customizations at once.\n   * @param suppressUpdate - Do not raise the change event at the end, preventing all updates\n   */\n  public static applyBatchedUpdates(code: () => void, suppressUpdate?: boolean): void {\n    Customizations._suppressUpdates = true;\n    try {\n      code();\n    } catch {\n      /* do nothing */\n    }\n    Customizations._suppressUpdates = false;\n    if (!suppressUpdate) {\n      Customizations._raiseChange();\n    }\n  }\n\n  public static observe(onChange: () => void): void {\n    _events.push(onChange);\n  }\n\n  public static unobserve(onChange: () => void): void {\n    _events = _events.filter((cb: () => void) => cb !== onChange);\n  }\n\n  private static _raiseChange(): void {\n    if (!Customizations._suppressUpdates) {\n      _events.forEach((cb: () => void) => cb());\n    }\n  }\n}\n", "import * as React from 'react';\nimport { Customizations } from './Customizations';\nimport { CustomizerContext } from './CustomizerContext';\nimport { mergeCustomizations } from './mergeCustomizations';\nimport type { ICustomizerContext } from './CustomizerContext';\nimport type { ICustomizerProps } from './Customizer.types';\n\n/**\n * The Customizer component allows for default props to be mixed into components which\n * are decorated with the customizable() decorator, or use the styled HOC. This enables\n * injection scenarios like:\n *\n * 1. render svg icons instead of the icon font within all buttons\n * 2. inject a custom theme object into a component\n *\n * Props are provided via the settings prop which should be one of the following:\n * - A json map which contains 1 or more name/value pairs representing injectable props.\n * - A function that receives the current settings and returns the new ones that apply to the scope\n *\n * @public\n *\n * @deprecated This component is deprecated for purpose of applying theme to components\n * as of `@fluentui/react` version 8. Use `ThemeProvider` for applying theme instead.\n */\nexport class Customizer extends React.Component<ICustomizerProps> {\n  public componentDidMount(): void {\n    Customizations.observe(this._onCustomizationChange);\n  }\n\n  public componentWillUnmount(): void {\n    Customizations.unobserve(this._onCustomizationChange);\n  }\n\n  public render(): React.ReactElement<{}> {\n    const { contextTransform } = this.props;\n    return (\n      <CustomizerContext.Consumer>\n        {(parentContext: ICustomizerContext) => {\n          let newContext = mergeCustomizations(this.props, parentContext);\n\n          if (contextTransform) {\n            newContext = contextTransform(newContext);\n          }\n\n          return <CustomizerContext.Provider value={newContext}>{this.props.children}</CustomizerContext.Provider>;\n        }}\n      </CustomizerContext.Consumer>\n    );\n  }\n\n  private _onCustomizationChange = () => this.forceUpdate();\n}\n", "import * as React from 'react';\nimport type { ICustomizations } from './Customizations';\n\nexport interface ICustomizerContext {\n  customizations: ICustomizations;\n}\n\nexport const CustomizerContext = React.createContext<ICustomizerContext>({\n  customizations: {\n    inCustomizerContext: false,\n    settings: {},\n    scopedSettings: {},\n  },\n});\n", "import type { ISettings, ISettingsFunction } from './Customizations';\n\n/**\n * Merge new and old settings, giving priority to new settings.\n * New settings is optional in which case oldSettings is returned as-is.\n * @param oldSettings - Old settings to fall back to.\n * @param newSettings - New settings that will be merged over oldSettings.\n * @returns Merged settings.\n */\nexport function mergeSettings(oldSettings: ISettings = {}, newSettings?: ISettings | ISettingsFunction): ISettings {\n  const mergeSettingsWith = _isSettingsFunction(newSettings) ? newSettings : _settingsMergeWith(newSettings);\n\n  return mergeSettingsWith(oldSettings);\n}\n\nexport function mergeScopedSettings(\n  oldSettings: ISettings = {},\n  newSettings?: ISettings | ISettingsFunction,\n): ISettings {\n  const mergeSettingsWith = _isSettingsFunction(newSettings) ? newSettings : _scopedSettingsMergeWith(newSettings);\n\n  return mergeSettingsWith(oldSettings);\n}\n\nfunction _isSettingsFunction(settings?: ISettings | ISettingsFunction): settings is ISettingsFunction {\n  return typeof settings === 'function';\n}\n\nfunction _settingsMergeWith(newSettings?: object): (settings: ISettings) => ISettings {\n  return (settings: ISettings) => (newSettings ? { ...settings, ...newSettings } : settings);\n}\n\nfunction _scopedSettingsMergeWith(scopedSettingsFromProps: ISettings = {}): (scopedSettings: ISettings) => ISettings {\n  return (oldScopedSettings: ISettings): ISettings => {\n    const newScopedSettings: ISettings = { ...oldScopedSettings };\n\n    for (let scopeName in scopedSettingsFromProps) {\n      if (scopedSettingsFromProps.hasOwnProperty(scopeName)) {\n        newScopedSettings[scopeName] = { ...oldScopedSettings[scopeName], ...scopedSettingsFromProps[scopeName] };\n      }\n    }\n\n    return newScopedSettings;\n  };\n}\n", "import { mergeSettings, mergeScopedSettings } from './mergeSettings';\nimport type { ICustomizerProps } from './Customizer.types';\nimport type { ICustomizerContext } from './CustomizerContext';\n\n/**\n * Merge props and customizations giving priority to props over context.\n * NOTE: This function will always perform multiple merge operations. Use with caution.\n * @param props - New settings to merge in.\n * @param parentContext - Context containing current settings.\n * @returns Merged customizations.\n */\nexport function mergeCustomizations(props: ICustomizerProps, parentContext: ICustomizerContext): ICustomizerContext {\n  const { customizations = { settings: {}, scopedSettings: {} } } = parentContext || {};\n\n  return {\n    customizations: {\n      settings: mergeSettings(customizations.settings, props.settings),\n      scopedSettings: mergeScopedSettings(customizations.scopedSettings, props.scopedSettings),\n      inCustomizerContext: true,\n    },\n  };\n}\n", "import * as React from 'react';\nimport { Customizations } from './Customizations';\nimport { hoistStatics } from '../hoistStatics';\nimport { CustomizerContext } from './CustomizerContext';\nimport { concatStyleSets, makeShadowConfig } from '@fluentui/merge-styles';\nimport { MergeStylesShadowRootConsumer } from '../shadowDom/contexts/MergeStylesShadowRootConsumer';\nimport { getWindow } from '../dom/getWindow';\nimport { WindowContext } from '@fluentui/react-window-provider';\nimport type { ICustomizerContext } from './CustomizerContext';\nimport type { ShadowConfig } from '@fluentui/merge-styles';\n\nimport { memoizeFunction } from '../memoize';\n\nconst memoizedMakeShadowConfig = memoizeFunction(makeShadowConfig);\nconst mergeComponentStyles = memoizeFunction(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (defaultStyles: any, componentStyles: any, shadowConfig: ShadowConfig): any => {\n    const styles = componentStyles ?? defaultStyles ?? {};\n    styles.__shadowConfig__ = shadowConfig;\n\n    return styles;\n  },\n);\n\nexport function customizable(\n  scope: string,\n  fields: string[],\n  concatStyles?: boolean,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): <P>(ComposedComponent: React.ComponentType<P>) => any {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function customizableFactory<P>(ComposedComponent: React.ComponentType<P>): any {\n    const resultClass = class ComponentWithInjectedProps extends React.Component<P, {}> {\n      public static displayName: string = 'Customized' + scope;\n      public static contextType = WindowContext;\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      private _styleCache: { default?: any; component?: any; merged?: any } = {};\n\n      constructor(props: P) {\n        super(props);\n\n        this._onSettingChanged = this._onSettingChanged.bind(this);\n      }\n\n      public componentDidMount(): void {\n        Customizations.observe(this._onSettingChanged);\n      }\n\n      public componentWillUnmount(): void {\n        Customizations.unobserve(this._onSettingChanged);\n      }\n\n      public render(): JSX.Element {\n        return (\n          <MergeStylesShadowRootConsumer stylesheetKey={scope}>\n            {(inShadow: boolean) => {\n              return (\n                <CustomizerContext.Consumer>\n                  {(context: ICustomizerContext) => {\n                    const defaultProps = Customizations.getSettings(fields, scope, context.customizations);\n\n                    const win = this.context.window ?? getWindow();\n                    const shadowConfig = memoizedMakeShadowConfig(scope, inShadow, win);\n\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const componentProps = this.props as any;\n\n                    // If defaultProps.styles is a function, evaluate it before calling concatStyleSets\n                    if (defaultProps.styles && typeof defaultProps.styles === 'function') {\n                      defaultProps.styles = defaultProps.styles({ ...defaultProps, ...componentProps });\n                    }\n\n                    // If concatStyles is true and custom styles have been defined compute those styles\n                    if (concatStyles && defaultProps.styles) {\n                      if (\n                        this._styleCache.default !== defaultProps.styles ||\n                        this._styleCache.component !== componentProps.styles\n                      ) {\n                        const mergedStyles = concatStyleSets(defaultProps.styles, componentProps.styles);\n                        mergedStyles.__shadowConfig__ = shadowConfig;\n                        this._styleCache.default = defaultProps.styles;\n                        this._styleCache.component = componentProps.styles;\n                        this._styleCache.merged = mergedStyles;\n                      }\n\n                      return (\n                        <ComposedComponent {...defaultProps} {...componentProps} styles={this._styleCache.merged} />\n                      );\n                    }\n\n                    const styles = mergeComponentStyles(defaultProps.styles, componentProps.styles, shadowConfig);\n\n                    return <ComposedComponent {...defaultProps} {...componentProps} styles={styles} />;\n                  }}\n                </CustomizerContext.Consumer>\n              );\n            }}\n          </MergeStylesShadowRootConsumer>\n        );\n      }\n\n      private _onSettingChanged(): void {\n        this.forceUpdate();\n      }\n    };\n\n    return hoistStatics(ComposedComponent, resultClass);\n  };\n}\n", "/**\n * Allows you to hoist static functions in components.\n * Created for the purpose of fixing broken static functions in classes\n * that utilize decorators.\n *\n * @public\n * @param source - The object where the methods are hoisted from.\n * @param dest - The object to hoist the methods onto.\n * @returns The dest object with methods added\n */\n\nexport function hoistStatics<TSource extends Object, TDest>(source: TSource, dest: TDest): TDest {\n  for (const name in source) {\n    if (source.hasOwnProperty(name)) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (dest as any)[name] = source[name];\n    }\n  }\n\n  return dest;\n}\n", "import * as React from 'react';\nimport { MergeStylesDefaultContext } from '../contexts/MergeStylesDefaultContext';\n\nexport const useMergeStylesHooks = () => {\n  const ctx = React.useContext(MergeStylesDefaultContext);\n  return {\n    useAdoptedStylesheet: ctx.useAdoptedStylesheet,\n    useAdoptedStylesheetEx: ctx.useAdoptedStylesheetEx,\n    useShadowConfig: ctx.useShadowConfig,\n    useMergeStylesShadowRootContext: ctx.useMergeStylesShadowRootContext,\n    useHasMergeStylesShadowRootContext: ctx.useHasMergeStylesShadowRootContext,\n    useMergeStylesRootStylesheets: ctx.useMergeStylesRootStylesheets,\n    useWindow: ctx.useWindow,\n    useStyled: ctx.useStyled,\n  };\n};\n", "import { DEFAULT_SHADOW_CONFIG, ExtendedCSSStyleSheet } from '@fluentui/merge-styles';\nimport * as React from 'react';\n\nimport type { AdoptedStylesheetExHook, AdoptedStylesheetHook } from '../hooks/useAdoptedStylesheet';\nimport type { ShadowConfigHook } from '../hooks/useShadowConfig';\nimport type {\n  HasMergeStylesShadowRootContextHook,\n  MergeStylesShadowRootContextHook,\n} from '../hooks/useMergeStylesShadowRoot';\nimport type { MergeStylesRootStylesheetsHook } from '../hooks/useMergeStylesRootStylesheets';\nimport type { UseStyledHook } from '../hooks/useStyled';\n\nexport const noop = () => false;\nexport const noopShadow = () => DEFAULT_SHADOW_CONFIG;\nexport const noopRootStylesheets = () => new Map();\nexport const noopUndefined = () => undefined;\n\nexport const getNewContext = (): MergeStylesDefaultContextValue => {\n  return {\n    stylesheets: new Map(),\n    useAdoptedStylesheetEx: noop,\n    useAdoptedStylesheet: noop,\n    useShadowConfig: noopShadow,\n    useMergeStylesShadowRootContext: noopUndefined,\n    useHasMergeStylesShadowRootContext: noop,\n    useMergeStylesRootStylesheets: noopRootStylesheets,\n    useWindow: noopUndefined,\n    useStyled: noopUndefined,\n  };\n};\n\nexport type UseWindowHook = () => Window | undefined;\n\nexport type MergeStylesDefaultContextValue = {\n  stylesheets: Map<string, ExtendedCSSStyleSheet>;\n  useAdoptedStylesheetEx: AdoptedStylesheetExHook;\n  useAdoptedStylesheet: AdoptedStylesheetHook;\n  useShadowConfig: ShadowConfigHook;\n  useMergeStylesShadowRootContext: MergeStylesShadowRootContextHook;\n  useHasMergeStylesShadowRootContext: HasMergeStylesShadowRootContextHook;\n  useMergeStylesRootStylesheets: MergeStylesRootStylesheetsHook;\n  useWindow: UseWindowHook;\n  useStyled: UseStyledHook;\n};\n\nexport const MergeStylesDefaultContext = React.createContext<MergeStylesDefaultContextValue>(getNewContext());\n", "import * as React from 'react';\nimport {\n  MergeStylesShadowRootContext,\n  MergeStylesShadowRootContextValue,\n} from '../contexts/MergeStylesShadowRootContext';\n\nexport type HasMergeStylesShadowRootContextHook = () => boolean;\nexport type MergeStylesShadowRootContextHook = () => MergeStylesShadowRootContextValue | undefined;\n\n/**\n * Test if a context is available.\n * @returns true if there is a context.\n */\nexport const useHasMergeStylesShadowRootContext: HasMergeStylesShadowRootContextHook = () => {\n  return !!useMergeStylesShadowRootContext();\n};\n\n/**\n * Get a reference to the shadow root context.\n * @returns The context for the shadow root.\n */\nexport const useMergeStylesShadowRootContext: MergeStylesShadowRootContextHook = () => {\n  return React.useContext(MergeStylesShadowRootContext);\n};\n", "import * as React from 'react';\nimport { GLOBAL_STYLESHEET_KEY } from '@fluentui/merge-styles';\nimport { useMergeStylesHooks } from '../hooks/useMergeStylesHooks';\n\nexport type MergeStylesShadowRootContextValue = {\n  /**\n   * Map of stylesheets available in the context.\n   */\n  stylesheets: Map<string, CSSStyleSheet>;\n\n  /**\n   * Shadow root for this context.\n   */\n  shadowRoot?: ShadowRoot | null;\n};\n\nexport const MergeStylesShadowRootContext = React.createContext<MergeStylesShadowRootContextValue | undefined>(\n  undefined,\n);\n\nexport type MergeStylesShadowRootProviderProps = {\n  /**\n   * Shadow root for this context.\n   */\n  shadowRoot?: ShadowRoot | null;\n};\n\n/**\n * Context for a shadow root.\n */\nexport const MergeStylesShadowRootProvider: React.FC<MergeStylesShadowRootProviderProps> = ({\n  shadowRoot,\n  ...props\n}) => {\n  const value = React.useMemo(() => {\n    return {\n      stylesheets: new Map(),\n      shadowRoot,\n    };\n  }, [shadowRoot]);\n\n  return (\n    <MergeStylesShadowRootContext.Provider value={value} {...props}>\n      <GlobalStyles />\n      {props.children}\n    </MergeStylesShadowRootContext.Provider>\n  );\n};\n\nconst GlobalStyles: React.FC = props => {\n  const { useAdoptedStylesheet } = useMergeStylesHooks();\n  useAdoptedStylesheet(GLOBAL_STYLESHEET_KEY);\n  return null;\n};\n", "import type * as React from 'react';\nimport { GLOBAL_STYLESHEET_KEY } from '@fluentui/merge-styles';\nimport { useMergeStylesHooks } from '../hooks/useMergeStylesHooks';\nimport { useMergeStylesShadowRootContext } from '../hooks/useMergeStylesShadowRoot';\n\nexport type MergeStylesContextConsumerProps = {\n  stylesheetKey: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  children: (inShadow: boolean) => React.ReactElement<any, any>;\n};\n\nexport const MergeStylesShadowRootConsumer: React.FC<MergeStylesContextConsumerProps> = ({\n  stylesheetKey,\n  children,\n}) => {\n  const { useAdoptedStylesheetEx, useMergeStylesRootStylesheets, useWindow } = useMergeStylesHooks();\n  const shadowCtx = useMergeStylesShadowRootContext();\n  const rootMergeStyles = useMergeStylesRootStylesheets();\n  const win = useWindow();\n\n  useAdoptedStylesheetEx(GLOBAL_STYLESHEET_KEY, shadowCtx, rootMergeStyles, win);\n  useAdoptedStylesheetEx(stylesheetKey, shadowCtx, rootMergeStyles, win);\n\n  return children(!!shadowCtx);\n};\n", null, null, "import * as React from 'react';\nimport { Customizations } from './Customizations';\nimport { CustomizerContext } from './CustomizerContext';\nimport type { ISettings } from './Customizations';\n\n/**\n * Hook to get Customizations settings from Customizations singleton or CustomizerContext.\n * It will trigger component state update on settings change observed.\n */\nexport function useCustomizationSettings(properties: string[], scopeName?: string): ISettings {\n  const forceUpdate = useForceUpdate();\n  const { customizations } = React.useContext(CustomizerContext);\n  const { inCustomizerContext } = customizations;\n  React.useEffect(() => {\n    if (!inCustomizerContext) {\n      Customizations.observe(forceUpdate);\n    }\n    return () => {\n      if (!inCustomizerContext) {\n        Customizations.unobserve(forceUpdate);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- exclude forceUpdate\n  }, [inCustomizerContext]);\n\n  return Customizations.getSettings(properties, scopeName, customizations);\n}\n\nfunction useForceUpdate() {\n  const [, setValue] = React.useState(0);\n  return () => setValue(value => ++value);\n}\n", "import * as React from 'react';\nimport { appendFunction } from './appendFunction';\n\n/**\n * Extends a component's lifetime methods by appending new functions to the existing lifetime functions.\n */\nexport function extendComponent<T extends React.Component>(parent: T, methods: { [key in keyof T]?: T[key] }): void {\n  for (let name in methods) {\n    if (methods.hasOwnProperty(name)) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      parent[name] = appendFunction(parent, parent[name], methods[name]) as any;\n    }\n  }\n}\n", "import { getWindow } from './dom/getWindow';\nimport { Stylesheet } from '@fluentui/merge-styles';\n\n// Initialize global window id.\nconst CURRENT_ID_PROPERTY = '__currentId__';\nconst DEFAULT_ID_STRING = 'id__';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet _global: any = getWindow() || {};\n\nif (_global[CURRENT_ID_PROPERTY] === undefined) {\n  _global[CURRENT_ID_PROPERTY] = 0;\n}\n\nlet _initializedStylesheetResets = false;\n\n/**\n * Generates a unique id in the global scope (this spans across duplicate copies of the same library.)\n *\n * @public\n */\nexport function getId(prefix?: string): string {\n  if (!_initializedStylesheetResets) {\n    // Configure ids to reset on stylesheet resets.\n    const stylesheet = Stylesheet.getInstance();\n\n    if (stylesheet && stylesheet.onReset) {\n      stylesheet.onReset(resetIds);\n    }\n    _initializedStylesheetResets = true;\n  }\n\n  let index = _global[CURRENT_ID_PROPERTY]++;\n\n  return (prefix === undefined ? DEFAULT_ID_STRING : prefix) + index;\n}\n\n/**\n * Resets id counter to an (optional) number.\n *\n * @public\n */\nexport function resetIds(counter: number = 0): void {\n  _global[CURRENT_ID_PROPERTY] = counter;\n}\n", "const toObjectMap = (...items: (string[] | Record<string, number>)[]) => {\n  const result: Record<string, number> = {};\n\n  for (const item of items) {\n    const keys = Array.isArray(item) ? item : Object.keys(item);\n\n    for (const key of keys) {\n      result[key] = 1;\n    }\n  }\n\n  return result;\n};\n\n/**\n * An array of events that are allowed on every html element type.\n *\n * @public\n */\nexport const baseElementEvents = toObjectMap([\n  'onCopy',\n  'onCut',\n  'onPaste',\n  'onCompositionEnd',\n  'onCompositionStart',\n  'onCompositionUpdate',\n  'onFocus',\n  'onFocusCapture',\n  'onBlur',\n  'onBlurCapture',\n  'onChange',\n  'onInput',\n  'onSubmit',\n  'onLoad',\n  'onError',\n  'onKeyDown',\n  'onKeyDownCapture',\n  'onKeyPress',\n  'onKeyUp',\n  'onAbort',\n  'onCanPlay',\n  'onCanPlayThrough',\n  'onDurationChange',\n  'onEmptied',\n  'onEncrypted',\n  'onEnded',\n  'onLoadedData',\n  'onLoadedMetadata',\n  'onLoadStart',\n  'onPause',\n  'onPlay',\n  'onPlaying',\n  'onProgress',\n  'onRateChange',\n  'onSeeked',\n  'onSeeking',\n  'onStalled',\n  'onSuspend',\n  'onTimeUpdate',\n  'onVolumeChange',\n  'onWaiting',\n  'onClick',\n  'onClickCapture',\n  'onContextMenu',\n  'onDoubleClick',\n  'onDrag',\n  'onDragEnd',\n  'onDragEnter',\n  'onDragExit',\n  'onDragLeave',\n  'onDragOver',\n  'onDragStart',\n  'onDrop',\n  'onMouseDown',\n  'onMouseDownCapture',\n  'onMouseEnter',\n  'onMouseLeave',\n  'onMouseMove',\n  'onMouseOut',\n  'onMouseOver',\n  'onMouseUp',\n  'onMouseUpCapture',\n  'onSelect',\n  'onTouchCancel',\n  'onTouchEnd',\n  'onTouchMove',\n  'onTouchStart',\n  'onScroll',\n  'onWheel',\n  'onPointerCancel',\n  'onPointerDown',\n  'onPointerEnter',\n  'onPointerLeave',\n  'onPointerMove',\n  'onPointerOut',\n  'onPointerOver',\n  'onPointerUp',\n  'onGotPointerCapture',\n  'onLostPointerCapture',\n]);\n\n/**\n * An array of element attributes which are allowed on every html element type.\n *\n * @public\n */\nexport const baseElementProperties = toObjectMap([\n  'accessKey', // global\n  'children', // global\n  'className', // global\n  'contentEditable', // global\n  'dir', // global\n  'draggable', // global\n  'hidden', // global\n  'htmlFor', // global\n  'id', // global\n  'lang', // global\n  'ref', // global\n  'role', // global\n  'style', // global\n  'tabIndex', // global\n  'title', // global\n  'translate', // global\n  'spellCheck', // global\n  'name', // global\n]);\n\n/**\n * An array of HTML element properties and events.\n *\n * @public\n */\nexport const htmlElementProperties = toObjectMap(baseElementProperties, baseElementEvents);\n\n/**\n * An array of LABEL tag properties and events.\n *\n * @public\n */\nexport const labelProperties = toObjectMap(htmlElementProperties, [\n  'form', // button, fieldset, input, label, meter, object, output, select, textarea\n]);\n\n/**\n * An array of AUDIO tag properties and events.\n\n * @public\n */\nexport const audioProperties = toObjectMap(htmlElementProperties, [\n  'height', // canvas, embed, iframe, img, input, object, video\n  'loop', // audio, video\n  'muted', // audio, video\n  'preload', // audio, video\n  'src', // audio, embed, iframe, img, input, script, source, track, video\n  'width', // canvas, embed, iframe, img, input, object, video\n]);\n\n/**\n * An array of VIDEO tag properties and events.\n *\n * @public\n */\nexport const videoProperties = toObjectMap(audioProperties, [\n  'poster', // video\n]);\n\n/**\n * An array of OL tag properties and events.\n *\n * @public\n */\nexport const olProperties = toObjectMap(htmlElementProperties, [\n  'start', // ol\n]);\n\n/**\n * An array of LI tag properties and events.\n *\n * @public\n */\nexport const liProperties = toObjectMap(htmlElementProperties, [\n  'value', // button, input, li, option, meter, progress, param\n]);\n\n/**\n * An array of A tag properties and events.\n *\n * @public\n */\nexport const anchorProperties = toObjectMap(htmlElementProperties, [\n  'download', // a, area\n  'href', // a, area, base, link\n  'hrefLang', // a, area, link\n  'media', // a, area, link, source, style\n  'rel', // a, area, link\n  'target', // a, area, base, form\n  'type', // a, button, input, link, menu, object, script, source, style\n]);\n\n/**\n * An array of BUTTON tag properties and events.\n *\n * @public\n */\nexport const buttonProperties = toObjectMap(htmlElementProperties, [\n  'autoFocus', // button, input, select, textarea\n  'disabled', // button, fieldset, input, optgroup, option, select, textarea\n  'form', // button, fieldset, input, label, meter, object, output, select, textarea\n  'formAction', // input, button\n  'formEncType', // input, button\n  'formMethod', // input, button\n  'formNoValidate', // input, button\n  'formTarget', // input, button\n  'type', // a, button, input, link, menu, object, script, source, style\n  'value', // button, input, li, option, meter, progress, param,\n]);\n\n/**\n * An array of INPUT tag properties and events.\n *\n * @public\n */\nexport const inputProperties = toObjectMap(buttonProperties, [\n  'accept', // input\n  'alt', // area, img, input\n  'autoCapitalize', // input, textarea\n  'autoComplete', // form, input\n  'checked', // input\n  'dirname', // input, textarea\n  'form', // button, fieldset, input, label, meter, object, output, select, textarea\n  'height', // canvas, embed, iframe, img, input, object, video\n  'inputMode', // input\n  'list', // input\n  'max', // input, meter\n  'maxLength', // input, textarea\n  'min', // input, meter\n  'minLength', // input, textarea\n  'multiple', // input, select\n  'pattern', // input\n  'placeholder', // input, textarea\n  'readOnly', // input, textarea\n  'required', // input, select, textarea\n  'src', // audio, embed, iframe, img, input, script, source, track, video\n  'step', // input\n  'size', // input\n  'type', // a, button, input, link, menu, object, script, source, style\n  'value', // button, input, li, option, meter, progress, param\n  'width', // canvas, embed, iframe, img, input, object, video\n]);\n\n/**\n * An array of TEXTAREA tag properties and events.\n *\n * @public\n */\nexport const textAreaProperties = toObjectMap(buttonProperties, [\n  'autoCapitalize', // input, textarea\n  'cols', // textarea\n  'dirname', // input, textarea\n  'form', // button, fieldset, input, label, meter, object, output, select, textarea\n  'maxLength', // input, textarea\n  'minLength', // input, textarea\n  'placeholder', // input, textarea\n  'readOnly', // input, textarea\n  'required', // input, select, textarea\n  'rows', // textarea\n  'wrap', // textarea\n]);\n\n/**\n * An array of SELECT tag properties and events.\n *\n * @public\n */\nexport const selectProperties = toObjectMap(buttonProperties, [\n  'form', // button, fieldset, input, label, meter, object, output, select, textarea\n  'multiple', // input, select\n  'required', // input, select, textarea\n]);\n\nexport const optionProperties = toObjectMap(htmlElementProperties, [\n  'selected', // option\n  'value', // button, input, li, option, meter, progress, param\n]);\n\n/**\n * An array of TABLE tag properties and events.\n *\n * @public\n */\nexport const tableProperties = toObjectMap(htmlElementProperties, [\n  'cellPadding', // table\n  'cellSpacing', // table\n]);\n\n/**\n * An array of TR tag properties and events.\n *\n * @public\n */\nexport const trProperties = htmlElementProperties;\n\n/**\n * An array of TH tag properties and events.\n *\n * @public\n */\nexport const thProperties = toObjectMap(htmlElementProperties, [\n  'rowSpan', // td, th\n  'scope', // th\n]);\n\n/**\n * An array of TD tag properties and events.\n *\n * @public\n */\nexport const tdProperties = toObjectMap(htmlElementProperties, [\n  'colSpan', // td\n  'headers', // td\n  'rowSpan', // td, th\n  'scope', // th\n]);\n\nexport const colGroupProperties = toObjectMap(htmlElementProperties, [\n  'span', // col, colgroup\n]);\n\nexport const colProperties = toObjectMap(htmlElementProperties, [\n  'span', // col, colgroup\n]);\n\n/**\n * An array of FORM tag properties and events.\n *\n * @public\n */\nexport const formProperties = toObjectMap(htmlElementProperties, [\n  'acceptCharset', // form\n  'action', // form\n  'encType', // form\n  'encType', // form\n  'method', // form\n  'noValidate', // form\n  'target', // form\n]);\n\n/**\n * An array of IFRAME tag properties and events.\n *\n * @public\n */\nexport const iframeProperties = toObjectMap(htmlElementProperties, [\n  'allow', // iframe\n  'allowFullScreen', // iframe\n  'allowPaymentRequest', // iframe\n  'allowTransparency', // iframe\n  'csp', // iframe\n  'height', // canvas, embed, iframe, img, input, object, video\n  'importance', // iframe\n  'referrerPolicy', // iframe\n  'sandbox', // iframe\n  'src', // audio, embed, iframe, img, input, script, source, track, video\n  'srcDoc', // iframe\n  'width', // canvas, embed, iframe, img, input, object, video,\n]);\n\n/**\n * An array of IMAGE tag properties and events.\n *\n * @public\n */\nexport const imgProperties = toObjectMap(htmlElementProperties, [\n  'alt', // area, img, input\n  'crossOrigin', // img\n  'height', // canvas, embed, iframe, img, input, object, video\n  'src', // audio, embed, iframe, img, input, script, source, track, video\n  'srcSet', // img, source\n  'useMap', // img, object,\n  'width', // canvas, embed, iframe, img, input, object, video\n]);\n\n/**\n * @deprecated Use imgProperties for img elements.\n */\nexport const imageProperties = imgProperties;\n\n/**\n * An array of DIV tag properties and events.\n *\n * @public\n */\nexport const divProperties = htmlElementProperties;\n\n/**\n * Gets native supported props for an html element provided the allowance set. Use one of the property\n * sets defined (divProperties, buttonPropertes, etc) to filter out supported properties from a given\n * props set. Note that all data- and aria- prefixed attributes will be allowed.\n * NOTE: getNativeProps should always be applied first when adding props to a react component. The\n * non-native props should be applied second. This will prevent getNativeProps from overriding your custom props.\n * For example, if props passed to getNativeProps has an onClick function and getNativeProps is added to\n * the component after an onClick function is added, then the getNativeProps onClick will override it.\n *\n * @public\n * @param props - The unfiltered input props\n * @param allowedPropsNames - The array or record of allowed prop names.\n * @returns The filtered props\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getNativeProps<T extends Record<string, any>>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  props: Record<string, any>,\n  allowedPropNames: string[] | Record<string, number>,\n  excludedPropNames?: string[],\n): T {\n  // It'd be great to properly type this while allowing 'aria-` and 'data-' attributes like TypeScript does for\n  // JSX attributes, but that ability is hardcoded into the TS compiler with no analog in TypeScript typings.\n  // Then we'd be able to enforce props extends native props (including aria- and data- attributes), and then\n  // return native props.\n  // We should be able to do this once this PR is merged: https://github.com/microsoft/TypeScript/pull/26797\n\n  const isArray = Array.isArray(allowedPropNames);\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const result: Record<string, any> = {};\n  const keys = Object.keys(props);\n\n  for (const key of keys) {\n    const isNativeProp =\n      (!isArray && (allowedPropNames as Record<string, number>)[key]) ||\n      (isArray && (allowedPropNames as string[]).indexOf(key) >= 0) ||\n      key.indexOf('data-') === 0 ||\n      key.indexOf('aria-') === 0;\n\n    if (isNativeProp && (!excludedPropNames || excludedPropNames?.indexOf(key) === -1)) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      result[key] = props![key] as any;\n    }\n  }\n\n  return result as T;\n}\n", "import {\n  labelProperties,\n  audioProperties,\n  videoProperties,\n  olProperties,\n  liProperties,\n  anchorProperties,\n  buttonProperties,\n  inputProperties,\n  textAreaProperties,\n  selectProperties,\n  optionProperties,\n  tableProperties,\n  trProperties,\n  thProperties,\n  tdProperties,\n  colGroupProperties,\n  colProperties,\n  formProperties,\n  iframeProperties,\n  imgProperties,\n  htmlElementProperties,\n  getNativeProps,\n} from './properties';\nimport * as React from 'react';\n\nconst nativeElementMap: Record<string, Record<string, number>> = {\n  label: labelProperties,\n  audio: audioProperties,\n  video: videoProperties,\n  ol: olProperties,\n  li: liProperties,\n  a: anchorProperties,\n  button: buttonProperties,\n  input: inputProperties,\n  textarea: textAreaProperties,\n  select: selectProperties,\n  option: optionProperties,\n  table: tableProperties,\n  tr: trProperties,\n  th: thProperties,\n  td: tdProperties,\n  colGroup: colGroupProperties,\n  col: colProperties,\n  form: formProperties,\n  iframe: iframeProperties,\n  img: imgProperties,\n};\n\n/**\n * Given an element tagname and user props, filters the props to only allowed props for the given\n * element type.\n * @param tagName - Tag name (e.g. \"div\")\n * @param props - Props object\n * @param excludedPropNames - List of props to disallow\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getNativeElementProps<TAttributes extends React.HTMLAttributes<any>>(\n  tagName: string,\n  props: {},\n  excludedPropNames?: string[],\n): TAttributes {\n  const allowedPropNames = (tagName && nativeElementMap[tagName]) || htmlElementProperties;\n\n  return getNativeProps(props, allowedPropNames, excludedPropNames);\n}\n", "const REACT_LIFECYCLE_EXCLUSIONS = [\n  'setState',\n  'render',\n  'componentWillMount',\n  'UNSAFE_componentWillMount',\n  'componentDidMount',\n  'componentWillReceiveProps',\n  'UNSAFE_componentWillReceiveProps',\n  'shouldComponentUpdate',\n  'componentWillUpdate',\n  'getSnapshotBeforeUpdate',\n  'UNSAFE_componentWillUpdate',\n  'componentDidUpdate',\n  'componentWillUnmount',\n];\n\n/**\n * Allows you to hoist methods, except those in an exclusion set from a source object into a destination object.\n *\n * @public\n * @param destination - The instance of the object to hoist the methods onto.\n * @param source - The instance of the object where the methods are hoisted from.\n * @param exclusions - (Optional) What methods to exclude from being hoisted.\n * @returns An array of names of methods that were hoisted.\n */\nexport function hoistMethods(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  destination: any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  source: any,\n  exclusions: string[] = REACT_LIFECYCLE_EXCLUSIONS,\n): string[] {\n  let hoisted: string[] = [];\n  for (let methodName in source) {\n    if (\n      typeof source[methodName] === 'function' &&\n      destination[methodName] === undefined &&\n      (!exclusions || exclusions.indexOf(methodName) === -1)\n    ) {\n      hoisted.push(methodName);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      destination[methodName] = function (...args: any[]): void {\n        source[methodName](...args);\n      };\n    }\n  }\n\n  return hoisted;\n}\n\n/**\n * Provides a method for convenience to unhoist hoisted methods.\n *\n * @public\n * @param source - The source object upon which methods were hoisted.\n * @param methodNames - An array of method names to unhoist.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function unhoistMethods(source: any, methodNames: string[]): void {\n  methodNames.forEach((methodName: string) => delete source[methodName]);\n}\n", "import * as React from 'react';\nimport { extendComponent } from './extendComponent';\nimport type { IBaseProps } from './BaseComponent.types';\n\n/**\n * Helper to manage componentRef resolution. Internally appends logic to\n * lifetime methods to resolve componentRef to the passed in object.\n *\n * Usage: call initializeComponentRef(this) in the constructor,\n */\nexport function initializeComponentRef<TProps extends IBaseProps, TState>(obj: React.Component<TProps, TState>): void {\n  extendComponent(obj, {\n    componentDidMount: _onMount,\n    componentDidUpdate: _onUpdate,\n    componentWillUnmount: _onUnmount,\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _onMount(this: any): void {\n  _setComponentRef(this.props.componentRef, this);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _onUpdate(this: any, prevProps: IBaseProps): void {\n  if (prevProps.componentRef !== this.props.componentRef) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _setComponentRef((prevProps as any).componentRef, null);\n    _setComponentRef(this.props.componentRef, this);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _onUnmount(this: any): void {\n  _setComponentRef(this.props.componentRef, null);\n}\n\nfunction _setComponentRef<TInterface>(componentRef: React.RefObject<TInterface>, value: TInterface | null): void {\n  if (componentRef) {\n    if (typeof componentRef === 'object') {\n      (componentRef as { current: TInterface | null }).current = value;\n    } else if (typeof componentRef === 'function') {\n      (componentRef as Function)(value);\n    }\n  }\n}\n", "import { KeyCodes } from './KeyCodes';\n\nconst DirectionalKeyCodes: { [key: number]: number } = {\n  [KeyCodes.up]: 1,\n  [KeyCodes.down]: 1,\n  [KeyCodes.left]: 1,\n  [KeyCodes.right]: 1,\n  [KeyCodes.home]: 1,\n  [KeyCodes.end]: 1,\n  [KeyCodes.tab]: 1,\n  [KeyCodes.pageUp]: 1,\n  [KeyCodes.pageDown]: 1,\n};\n\n/**\n * Returns true if the keycode is a directional keyboard key.\n */\nexport function isDirectionalKeyCode(which: number): boolean {\n  return !!DirectionalKeyCodes[which];\n}\n\n/**\n * Adds a keycode to the list of keys that, when pressed, should cause the focus outlines to be visible.\n * This can be used to add global shortcut keys that directionally move from section to section within\n * an app or between focus trap zones.\n */\nexport function addDirectionalKeyCode(which: number): void {\n  DirectionalKeyCodes[which] = 1;\n}\n\n/**\n * Removes a keycode to the list of keys that, when pressed, should cause the focus outlines to be visible.\n * This can be used to remove global shortcut keys that directionally move from section to section within\n * an app or between focus trap zones.\n */\nexport function removeDirectionalKeyCode(which: number): void {\n  delete DirectionalKeyCodes[which];\n}\n", "import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nexport const IsFocusVisibleClassName = 'ms-Fabric--isFocusVisible';\nexport const IsFocusHiddenClassName = 'ms-Fabric--isFocusHidden';\n\nfunction updateClassList(el: HTMLElement | null | undefined, enabled: boolean) {\n  if (el) {\n    el.classList.add(enabled ? IsFocusVisibleClassName : IsFocusHiddenClassName);\n    el.classList.remove(enabled ? IsFocusHiddenClassName : IsFocusVisibleClassName);\n  }\n}\n\n/**\n * Sets the visibility of focus styling.\n *\n * By default, focus styles (the box surrounding a focused Button, for example) only show up when navigational\n * keypresses occur (through Tab, arrows, PgUp/PgDn, Home and End), and are hidden when mouse interactions occur.\n * This API provides an imperative way to turn them on/off.\n *\n * A use case might be when you have a keypress like ctrl-f6 navigate to a particular region on the page,\n * and want focus to show up.\n *\n * @param enabled - Whether to turn focus visibility on or off.\n * @param target - Optional target from which to get window in case no `providerElem` has been specified.\n * @param registeredProviders - Array of provider refs that are associated with a FocusRectsProvider. If no array\n *                              is passed in, the classnames are attached to the document body that contains `target`.\n */\nexport function setFocusVisibility(\n  enabled: boolean,\n  target?: Element,\n  registeredProviders?: React.RefObject<HTMLElement>[],\n): void {\n  if (registeredProviders) {\n    registeredProviders.forEach(ref => updateClassList(ref.current, enabled));\n  } else {\n    updateClassList(getWindow(target)?.document.body, enabled);\n  }\n}\n", "import { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n\ntype AppWindow =\n  | (Window & {\n      __hasInitializeFocusRects__: boolean;\n      FabricConfig?: { disableFocusRects?: boolean };\n    })\n  | undefined;\n\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown and mousedown events. (It will only do it once per window,\n *    so it's safe to call this method multiple times.)\n * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname\n *    to the document body, removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user clicks a mouse button, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    document body, removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param window - the window used to add the event listeners\n * @deprecated Use useFocusRects hook or FocusRects component instead.\n */\nexport function initializeFocusRects(window?: Window): void {\n  const win = (window || getWindow()) as AppWindow;\n  if (!win || win.FabricConfig?.disableFocusRects === true) {\n    return;\n  }\n\n  if (!win.__hasInitializeFocusRects__) {\n    win.__hasInitializeFocusRects__ = true;\n    win.addEventListener('mousedown', _onMouseDown, true);\n    win.addEventListener('pointerdown', _onPointerDown, true);\n    win.addEventListener('keydown', _onKeyDown as () => void, true);\n  }\n}\n\nfunction _onMouseDown(ev: MouseEvent): void {\n  setFocusVisibility(false, ev.target as Element);\n}\n\nfunction _onPointerDown(ev: PointerEvent): void {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target as Element);\n  }\n}\n\nfunction _onKeyDown(ev: KeyboardEvent): void {\n  // eslint-disable-next-line deprecation/deprecation\n  isDirectionalKeyCode(ev.which) && setFocusVisibility(true, ev.target as Element);\n}\n", "import * as React from 'react';\nimport { FocusRectsContext } from './useFocusRects';\n\nexport type FocusRectsProviderProps = {\n  /**\n   * Ref to the root element that this is providing focus rects for.\n   */\n  providerRef: React.RefObject<HTMLElement>;\n\n  /**\n   * Indicates that this is the root of a layer, and should not inherit the providerRef from a parent context.\n   */\n  layerRoot?: boolean;\n};\n\nexport const FocusRectsProvider: React.FC<FocusRectsProviderProps> = props => {\n  const { providerRef, layerRoot } = props;\n  const [registeredProviders] = React.useState<React.RefObject<HTMLElement>[]>([]);\n  const parentContext = React.useContext(FocusRectsContext);\n\n  // Inherit the parent context if it exists, unless this is a layer root.\n  // This allows the topmost provider element in the DOM tree to handle the focus events.\n  // Since layers are in a separate HTML tree from their parent, they shouldn't use the parent's providerRef.\n  const inheritParentContext = parentContext !== undefined && !layerRoot;\n\n  const context = React.useMemo(\n    () =>\n      inheritParentContext\n        ? undefined\n        : {\n            providerRef,\n            registeredProviders,\n            registerProvider: (ref: React.RefObject<HTMLElement>) => {\n              // Register this child provider with the current context, and any parent contexts\n              registeredProviders.push(ref);\n              parentContext?.registerProvider(ref);\n            },\n            unregisterProvider: (ref: React.RefObject<HTMLElement>) => {\n              parentContext?.unregisterProvider(ref);\n              const i = registeredProviders.indexOf(ref);\n              if (i >= 0) {\n                registeredProviders.splice(i, 1);\n              }\n            },\n          },\n    [providerRef, registeredProviders, parentContext, inheritParentContext],\n  );\n\n  React.useEffect(() => {\n    if (context) {\n      context.registerProvider(context.providerRef);\n      return () => context.unregisterProvider(context.providerRef);\n    }\n  }, [context]);\n\n  // Create a new context provider if this is not inheriting from the parent.\n  if (context) {\n    return <FocusRectsContext.Provider value={context}>{props.children}</FocusRectsContext.Provider>;\n  } else {\n    return <>{props.children}</>;\n  }\n};\n", "import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n\n/**\n * Counter for mounted component that uses focus rectangles.\n * We want to cleanup the listeners before the last component that uses focus rectangles unmounts.\n */\nexport type ListenerCallbacks = {\n  onMouseDown: (ev: MouseEvent) => void;\n  onPointerDown: (ev: PointerEvent) => void;\n  onKeyDown: (ev: KeyboardEvent) => void;\n  onKeyUp: (ev: KeyboardEvent) => void;\n};\nlet mountCounters = new WeakMap<Window | HTMLElement, number>();\nlet callbackMap = new WeakMap<IFocusRectsContext, ListenerCallbacks>();\n\nfunction setMountCounters(key: Window | HTMLElement, delta: number): number {\n  let newValue;\n  const currValue = mountCounters.get(key);\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n\nfunction setCallbackMap(context: IFocusRectsContext): ListenerCallbacks {\n  let callbacks = callbackMap.get(context);\n  if (callbacks) {\n    return callbacks;\n  }\n\n  const onMouseDown = (ev: MouseEvent) => _onMouseDown(ev, context.registeredProviders);\n  const onPointerDown = (ev: PointerEvent) => _onPointerDown(ev, context.registeredProviders);\n  const onKeyDown = (ev: KeyboardEvent) => _onKeyDown(ev, context.registeredProviders);\n  const onKeyUp = (ev: KeyboardEvent) => _onKeyUp(ev, context.registeredProviders);\n  callbacks = { onMouseDown, onPointerDown, onKeyDown, onKeyUp };\n\n  callbackMap.set(context, callbacks);\n  return callbacks;\n}\n\ntype AppWindow = (Window & { FabricConfig?: { disableFocusRects?: boolean } }) | undefined;\n\nexport type IFocusRectsContext = {\n  /**\n   * Ref to the root element of the provider\n   */\n  readonly providerRef: React.RefObject<HTMLElement>;\n\n  /**\n   * Array of this and all child provider elements under this one in the React tree.\n   *\n   * Tracking all child providers will allow a focus event in the parent to also set focus styling in its descendants.\n   * This is needed for Combobox, for example, because the focus events happen on the parent context, but the visual\n   * focus indicator is in the combobox callout. The callout needs to be notified on focus events from the parent.\n   */\n  readonly registeredProviders: React.RefObject<HTMLElement>[];\n\n  /**\n   * Used by child FocusRectsProviders to register their element with the parent provider.\n   */\n  readonly registerProvider: (ref: React.RefObject<HTMLElement>) => void;\n\n  /**\n   * Used by child FocusRectsProviders to unregister their element from the parent provider.\n   */\n  readonly unregisterProvider: (ref: React.RefObject<HTMLElement>) => void;\n};\n\nexport const FocusRectsContext = React.createContext<IFocusRectsContext | undefined>(undefined);\n\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown, keyup, mousedown and pointerdown events. (It will only do it once for the current element of\n *    the FocusRectsContext providerRef or once per window if no such element is provided via context, so it's safe to\n *    call this method multiple times.)\n * 2. When the user presses triggers a keydown or keyup event via directional keyboard keys, adds the\n *    'ms-Fabric--isFocusVisible' classname to the current element of the FocusRectsContext providerRef or the document\n *    body if no such element is provided via context, and removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user triggers a mousedown or pointerdown event, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    current element of the FocusRectsContext providerRef or the document body if no such element is provided via\n *    context, and removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\nexport function useFocusRects(rootRef?: React.RefObject<HTMLElement>): void {\n  const context = React.useContext(FocusRectsContext);\n\n  React.useEffect(() => {\n    const win = getWindow(rootRef?.current) as AppWindow;\n\n    if (!win || win.FabricConfig?.disableFocusRects === true) {\n      return undefined;\n    }\n\n    let el: Window | HTMLElement = win;\n    let onMouseDown: (ev: MouseEvent) => void;\n    let onPointerDown: (ev: PointerEvent) => void;\n    let onKeyDown: (ev: KeyboardEvent) => void;\n    let onKeyUp: (ev: KeyboardEvent) => void;\n    if (\n      context?.providerRef?.current &&\n      (context?.providerRef?.current as Partial<Pick<HTMLElement, 'addEventListener'>>)?.addEventListener\n    ) {\n      el = context.providerRef.current;\n      // The NOINLINE directive tells terser not to move the setCallbackMap implementation into the call site during\n      // minification.\n      // This prevents the function from capturing additional variables in the closure, which can cause memory leaks.\n      const callbacks = /*@__NOINLINE__*/ setCallbackMap(context);\n      onMouseDown = callbacks.onMouseDown;\n      onPointerDown = callbacks.onPointerDown;\n      onKeyDown = callbacks.onKeyDown;\n      onKeyUp = callbacks.onKeyUp;\n    } else {\n      onMouseDown = _onMouseDown;\n      onPointerDown = _onPointerDown;\n      onKeyDown = _onKeyDown;\n      onKeyUp = _onKeyUp;\n    }\n\n    let count = setMountCounters(el, 1);\n    if (count <= 1) {\n      el.addEventListener('mousedown', onMouseDown, true);\n      el.addEventListener('pointerdown', onPointerDown, true);\n      el.addEventListener('keydown', onKeyDown, true);\n      el.addEventListener('keyup', onKeyUp, true);\n    }\n\n    return () => {\n      if (!win || win.FabricConfig?.disableFocusRects === true) {\n        return;\n      }\n      count = setMountCounters(el, -1);\n      if (count === 0) {\n        el.removeEventListener('mousedown', onMouseDown, true);\n        el.removeEventListener('pointerdown', onPointerDown, true);\n        el.removeEventListener('keydown', onKeyDown, true);\n        el.removeEventListener('keyup', onKeyUp, true);\n      }\n    };\n  }, [context, rootRef]);\n}\n\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\nexport const FocusRects: React.FunctionComponent<{ rootRef?: React.RefObject<HTMLElement> }> = props => {\n  useFocusRects(props.rootRef);\n  return null;\n};\n\nfunction _onMouseDown(ev: MouseEvent, registeredProviders?: React.RefObject<HTMLElement>[]): void {\n  setFocusVisibility(false, ev.target as Element, registeredProviders);\n}\n\nfunction _onPointerDown(ev: PointerEvent, registeredProviders?: React.RefObject<HTMLElement>[]): void {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target as Element, registeredProviders);\n  }\n}\n\n// You need both a keydown and a keyup listener that sets focus visibility to true to handle two distinct scenarios when\n// attaching the listeners and classnames to the provider instead of the document body.\n// If you only have a keydown listener, then the focus rectangles will not show when moving from outside of the provider\n// to inside it. That is why a keyup listener is needed, since it will always trigger after the focus event is fired.\n// If you only have a keyup listener, then the focus rectangles will not show moving between different tabbable elements\n// if the tab key is pressed without being released. That's is why we need a keydown listener, since it will trigger for\n// every element that is being tabbed into.\n// This works because `classList.add` is smart and will not duplicate a classname that already exists on the classList\n// when focus visibility is turned on.\nfunction _onKeyDown(ev: KeyboardEvent, registeredProviders?: React.RefObject<HTMLElement>[]): void {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target as Element, registeredProviders);\n  }\n}\n\nfunction _onKeyUp(ev: KeyboardEvent, registeredProviders?: React.RefObject<HTMLElement>[]): void {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target as Element, registeredProviders);\n  }\n}\n", "/**\n * Regular expressions matching characters to ignore when calculating the initials.\n */\n\n/**\n * Regular expression matching characters within various types of enclosures, including the enclosures themselves\n *  so for example, (xyz) [xyz] {xyz} <xyz> all would be ignored\n */\nconst UNWANTED_ENCLOSURES_REGEX: RegExp = /[\\(\\[\\{\\<][^\\)\\]\\}\\>]*[\\)\\]\\}\\>]/g;\n\n/**\n * Regular expression matching special ASCII characters except space, plus some unicode special characters.\n * Applies after unwanted enclosures have been removed\n */\nconst UNWANTED_CHARS_REGEX: RegExp = /[\\0-\\u001F\\!-/:-@\\[-`\\{-\\u00BF\\u0250-\\u036F\\uD800-\\uFFFF]/g;\n\n/**\n * Regular expression matching phone numbers. Applied after chars matching UNWANTED_CHARS_REGEX have been removed\n * and number has been trimmed for whitespaces\n */\nconst PHONENUMBER_REGEX: RegExp = /^\\d+[\\d\\s]*(:?ext|x|)\\s*\\d+$/i;\n\n/** Regular expression matching one or more spaces. */\nconst MULTIPLE_WHITESPACES_REGEX: RegExp = /\\s+/g;\n\n/**\n * Regular expression matching languages for which we currently don't support initials.\n * Arabic:   Arabic, Arabic Supplement, Arabic Extended-A.\n * Korean:   Hangul Jamo, Hangul Compatibility Jamo, Hangul Jamo Extended-A, Hangul Syllables, Hangul Jamo Extended-B.\n * Japanese: Hiragana, Katakana.\n * CJK:      CJK Unified Ideographs Extension A, CJK Unified Ideographs, CJK Compatibility Ideographs,\n *             CJK Unified Ideographs Extension B\n */\nconst UNSUPPORTED_TEXT_REGEX: RegExp =\n  // eslint-disable-next-line @fluentui/max-len\n  /[\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\u1100-\\u11FF\\u3130-\\u318F\\uA960-\\uA97F\\uAC00-\\uD7AF\\uD7B0-\\uD7FF\\u3040-\\u309F\\u30A0-\\u30FF\\u3400-\\u4DBF\\u4E00-\\u9FFF\\uF900-\\uFAFF]|[\\uD840-\\uD869][\\uDC00-\\uDED6]/;\n\nfunction getInitialsLatin(displayName: string, isRtl: boolean): string {\n  let initials = '';\n\n  const splits: string[] = displayName.split(' ');\n\n  if (splits.length === 2) {\n    initials += splits[0].charAt(0).toUpperCase();\n    initials += splits[1].charAt(0).toUpperCase();\n  } else if (splits.length === 3) {\n    initials += splits[0].charAt(0).toUpperCase();\n    initials += splits[2].charAt(0).toUpperCase();\n  } else if (splits.length !== 0) {\n    initials += splits[0].charAt(0).toUpperCase();\n  }\n\n  if (isRtl && initials.length > 1) {\n    return initials.charAt(1) + initials.charAt(0);\n  }\n\n  return initials;\n}\n\nfunction cleanupDisplayName(displayName: string): string {\n  displayName = displayName.replace(UNWANTED_ENCLOSURES_REGEX, '');\n  displayName = displayName.replace(UNWANTED_CHARS_REGEX, '');\n  displayName = displayName.replace(MULTIPLE_WHITESPACES_REGEX, ' ');\n  displayName = displayName.trim();\n\n  return displayName;\n}\n\n/**\n * Get (up to 2 characters) initials based on display name of the persona.\n *\n * @public\n */\nexport function getInitials(\n  displayName: string | undefined | null,\n  isRtl: boolean,\n  allowPhoneInitials?: boolean,\n): string {\n  if (!displayName) {\n    return '';\n  }\n\n  displayName = cleanupDisplayName(displayName);\n\n  // For names containing CJK characters, and phone numbers, we don't display initials\n  if (UNSUPPORTED_TEXT_REGEX.test(displayName) || (!allowPhoneInitials && PHONENUMBER_REGEX.test(displayName))) {\n    return '';\n  }\n\n  return getInitialsLatin(displayName, isRtl);\n}\n", "import { getWindow } from './dom/getWindow';\n\n/**\n * Fetches an item from local storage without throwing an exception\n * @param key The key of the item to fetch from local storage\n */\nexport function getItem(key: string): string | null {\n  let result = null;\n  try {\n    const win = getWindow();\n    result = win ? win.localStorage.getItem(key) : null;\n  } catch (e) {\n    /* Eat the exception */\n  }\n  return result;\n}\n\n/**\n * Inserts an item into local storage without throwing an exception\n * @param key The key of the item to add to local storage\n * @param data The data to put into local storage\n */\nexport function setItem(key: string, data: string): void {\n  try {\n    const win = getWindow();\n\n    win && win.localStorage.setItem(key, data);\n  } catch (e) {\n    /* Eat the exception */\n  }\n}\n", "import { getDocument } from './dom/getDocument';\nimport * as localStorage from './localStorage';\nimport * as sessionStorage from './sessionStorage';\n\n// Default to undefined so that we initialize on first read.\nlet _language: string | null;\n\nconst STORAGE_KEY = 'language';\n\n/**\n * Gets the language set for the page.\n * @param persistenceType - Where to persist the value. Default is `sessionStorage` if available.\n */\nexport function getLanguage(\n  persistenceType: 'localStorage' | 'sessionStorage' | 'none' = 'sessionStorage',\n): string | null {\n  if (_language === undefined) {\n    let doc = getDocument();\n    const savedLanguage =\n      persistenceType === 'localStorage'\n        ? localStorage.getItem(STORAGE_KEY)\n        : persistenceType === 'sessionStorage'\n        ? sessionStorage.getItem(STORAGE_KEY)\n        : undefined;\n\n    if (savedLanguage) {\n      _language = savedLanguage;\n    }\n\n    if (_language === undefined && doc) {\n      _language = doc.documentElement.getAttribute('lang');\n    }\n\n    if (_language === undefined) {\n      _language = 'en';\n    }\n  }\n\n  return _language;\n}\n\n/**\n * Sets the language for the page (by adjusting the lang attribute of the html element).\n * @param language - Language to set.\n * @param persistenceType - Where to persist the value. Default is `sessionStorage` if available.\n */\nexport function setLanguage(language: string, persistenceType?: 'localStorage' | 'sessionStorage' | 'none'): void;\n/**\n * Sets the language for the page (by adjusting the lang attribute of the html element).\n * @deprecated Use string parameter version.\n * @param language - Language to set.\n * @param avoidPersisting - If true, don't store the value.\n */\nexport function setLanguage(language: string, avoidPersisting?: boolean): void;\nexport function setLanguage(\n  language: string,\n  persistenceParam?: 'localStorage' | 'sessionStorage' | 'none' | boolean,\n): void {\n  let doc = getDocument();\n\n  if (doc) {\n    doc.documentElement.setAttribute('lang', language);\n  }\n\n  const persistenceType = persistenceParam === true ? 'none' : !persistenceParam ? 'sessionStorage' : persistenceParam;\n  if (persistenceType === 'localStorage') {\n    localStorage.setItem(STORAGE_KEY, language);\n  } else if (persistenceType === 'sessionStorage') {\n    sessionStorage.setItem(STORAGE_KEY, language);\n  }\n\n  _language = language;\n}\n", "import type { Point } from './Point';\nimport type { ISize } from './ISize';\n\n/**\n * Determines the distance between two points.\n *\n * @public\n */\n/* eslint-disable deprecation/deprecation */\nexport function getDistanceBetweenPoints(point1: Point, point2: Point): number {\n  const left1 = point1.left || point1.x || 0;\n  const top1 = point1.top || point1.y || 0;\n  const left2 = point2.left || point2.x || 0;\n  const top2 = point2.top || point2.y || 0;\n  /* eslint-enable deprecation/deprecation */\n\n  let distance = Math.sqrt(Math.pow(left1 - left2, 2) + Math.pow(top1 - top2, 2));\n\n  return distance;\n}\n\n/**\n * The available fit modes. These should match the fit modes for CSS.\n */\nexport type FitMode = 'contain' | 'cover';\n\n/**\n * Options for fitting content sizes into bounding sizes.\n */\nexport interface IFitContentToBoundsOptions {\n  /**\n   * The size of the content to fit to the bounds.\n   * The output will be proportional to this value.\n   */\n  contentSize: ISize;\n  /**\n   * The size of the bounds.\n   */\n  boundsSize: ISize;\n  /**\n   * The fit mode to apply, either 'contain' or 'cover'.\n   */\n  mode: FitMode;\n  /**\n   * An optional maximum scale factor to apply. The default is 1.\n   * Use Infinity for an unbounded resize.\n   */\n  maxScale?: number;\n}\n\n/**\n * Produces a proportionally-scaled version of an input content size when fit to a bounding size.\n * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally\n * using either `contain` or `cover` fit behaviors.\n * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.\n * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.\n * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.\n * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.\n *\n * @param options - the options for the bounds fit operation\n */\nexport function fitContentToBounds(options: IFitContentToBoundsOptions): ISize {\n  const { contentSize, boundsSize, mode = 'contain', maxScale = 1 } = options;\n\n  const contentAspectRatio = contentSize.width / contentSize.height;\n  const boundsAspectRatio = boundsSize.width / boundsSize.height;\n\n  let scale: number;\n\n  if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {\n    scale = boundsSize.width / contentSize.width;\n  } else {\n    scale = boundsSize.height / contentSize.height;\n  }\n\n  const finalScale = Math.min(maxScale, scale);\n\n  return {\n    width: contentSize.width * finalScale,\n    height: contentSize.height * finalScale,\n  };\n}\n\n/**\n * Calculates a number's precision based on the number of trailing\n * zeros if the number does not have a decimal indicated by a negative\n * precision. Otherwise, it calculates the number of digits after\n * the decimal point indicated by a positive precision.\n * @param value - the value to determine the precision of\n */\nexport function calculatePrecision(value: number | string): number {\n  /**\n   * Group 1:\n   * [1-9]([0]+$) matches trailing zeros\n   * Group 2:\n   * \\.([0-9]*) matches all digits after a decimal point.\n   */\n  const groups = /[1-9]([0]+$)|\\.([0-9]*)/.exec(String(value));\n  if (!groups) {\n    return 0;\n  }\n  if (groups[1]) {\n    return -groups[1].length;\n  }\n  if (groups[2]) {\n    return groups[2].length;\n  }\n  return 0;\n}\n\n/**\n * Rounds a number to a certain level of precision. Accepts negative precision.\n * @param value - The value that is being rounded.\n * @param precision - The number of decimal places to round the number to\n */\nexport function precisionRound(value: number, precision: number, base: number = 10): number {\n  const exp = Math.pow(base, precision);\n  return Math.round(value * exp) / exp;\n}\n", "/**\n * Simple deep merge function. Takes all arguments and returns a deep copy of the objects merged\n * together in the order provided. If an object creates a circular reference, it will assign the\n * original reference.\n */\nexport function merge<T = {}>(target: Partial<T>, ...args: (Partial<T> | null | undefined | false)[]): T {\n  for (const arg of args) {\n    _merge(target || {}, arg as Partial<T>);\n  }\n\n  return target as T;\n}\n\n/**\n * The _merge helper iterates through all props on source and assigns them to target.\n * When the value is an object, we will create a deep clone of the object. However if\n * there is a circular reference, the value will not be deep cloned and will persist\n * the reference.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _merge<T extends Object>(target: T, source: T, circularReferences: any[] = []): T {\n  circularReferences.push(source);\n\n  for (let name in source) {\n    if (source.hasOwnProperty(name)) {\n      if (name !== '__proto__' && name !== 'constructor' && name !== 'prototype') {\n        const value: T[Extract<keyof T, string>] = source[name];\n        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n          const isCircularReference = circularReferences.indexOf(value) > -1;\n          target[name] = (\n            isCircularReference ? value : _merge(target[name] || {}, value, circularReferences)\n          ) as T[Extract<keyof T, string>];\n        } else {\n          target[name] = value;\n        }\n      }\n    }\n  }\n\n  circularReferences.pop();\n\n  return target;\n}\n", "/**\n * Returns true if and only if the user is on a iOS device.\n * Used to determine whether iOS-specific behavior should be applied.\n */\nexport const isIOS = (): boolean => {\n  // eslint-disable-next-line no-restricted-globals\n  if (!window || !window.navigator || !window.navigator.userAgent) {\n    return false;\n  }\n  // eslint-disable-next-line no-restricted-globals\n  return /iPad|iPhone|iPod/i.test(window.navigator.userAgent);\n};\n", "/**\n * The helper functions here will make the target element as modal to screen readers, by placing aria-hidden on elements\n * that are siblings to the target element and the target element's ancestors (because aria-hidden gets inherited).\n * That way, all other elements on the page are hidden to the screen reader.\n */\n\nimport { getDocument } from './dom/getDocument';\n\n/** Tag names to ignore when modalizing */\nconst tagsToIgnore = ['TEMPLATE', 'STYLE', 'SCRIPT'];\n\n/**\n * Call this on a target element to make it modal to screen readers.\n * Returns a function that undoes the changes it made.\n */\nexport function modalize(target: HTMLElement): () => void {\n  const targetDocument = getDocument(target);\n  if (!targetDocument) {\n    // can't do this in SSR\n    return () => undefined;\n  }\n\n  let affectedNodes: [HTMLElement, string | null][] = [];\n\n  // start at target, then recurse and do the same for parent, until we reach <body>\n  while (target !== targetDocument.body && target.parentElement) {\n    // grab all siblings of current element\n    for (const sibling of target.parentElement.children as unknown as HTMLElement[]) {\n      // but ignore elements that are already aria-hidden\n      const ariaHidden = sibling.getAttribute('aria-hidden');\n      if (sibling !== target && ariaHidden?.toLowerCase() !== 'true' && tagsToIgnore.indexOf(sibling.tagName) === -1) {\n        affectedNodes.push([sibling, ariaHidden]);\n      }\n    }\n\n    target = target.parentElement;\n  }\n\n  // take all those elements and set aria-hidden=true on them\n  affectedNodes.forEach(([node]) => {\n    node.setAttribute('aria-hidden', 'true');\n  });\n\n  return () => {\n    unmodalize(affectedNodes);\n    affectedNodes = []; // dispose\n  };\n}\n\n/**\n * Undoes the changes that modalize() did.\n */\nfunction unmodalize(affectedNodes: [HTMLElement, string | null][]) {\n  affectedNodes.forEach(([node, originalValue]) => {\n    // Restore the original value (false or unset)\n    if (originalValue) {\n      node.setAttribute('aria-hidden', originalValue);\n    } else {\n      node.removeAttribute('aria-hidden');\n    }\n  });\n}\n", "import { getWindow } from './dom/getWindow';\n\nlet isMacResult: boolean | undefined;\n\n/**\n * Returns true if the user is on a Mac. Caches the result value.\n * @param reset - Reset the cached result value (mainly for testing).\n */\nexport function isMac(reset?: boolean): boolean {\n  if (typeof isMacResult === 'undefined' || reset) {\n    const win = getWindow();\n    // In certain SSR frameworks, `window` will be defined even on the server but `navigator` will be undefined\n    const userAgent = win?.navigator?.userAgent;\n    isMacResult = !!userAgent && userAgent.indexOf('Macintosh') !== -1;\n  }\n  return !!isMacResult;\n}\n", "/**\n * Detects whether an element's content has horizontal overflow\n *\n * @public\n * @param element - Element to check for overflow\n * @returns True if element's content overflows\n */\nexport function hasHorizontalOverflow(element: HTMLElement): boolean {\n  return element.clientWidth < element.scrollWidth;\n}\n\n/**\n * Detects whether an element's content has vertical overflow\n *\n * @public\n * @param element - Element to check for overflow\n * @returns True if element's content overflows\n */\nexport function hasVerticalOverflow(element: HTMLElement): boolean {\n  return element.clientHeight < element.scrollHeight;\n}\n\n/**\n * Detects whether an element's content has overflow in any direction\n *\n * @public\n * @param element - Element to check for overflow\n * @returns True if element's content overflows\n */\nexport function hasOverflow(element: HTMLElement): boolean {\n  return hasHorizontalOverflow(element) || hasVerticalOverflow(element);\n}\n", "import { createMemoizer } from '../memoize';\nimport type { IRenderFunction } from '../IRenderFunction';\n\ninterface IRenderFunctionComposer {\n  <TProps>(outer: IRenderFunction<TProps>): (inner: IRenderFunction<TProps>) => IRenderFunction<TProps>;\n}\n\nfunction createComposedRenderFunction<TProps>(\n  outer: IRenderFunction<TProps>,\n): (inner: IRenderFunction<TProps>) => IRenderFunction<TProps> {\n  const outerMemoizer = createMemoizer((inner: IRenderFunction<TProps>) => {\n    const innerMemoizer = createMemoizer((defaultRender: IRenderFunction<TProps>) => {\n      return (innerProps?: TProps) => {\n        return inner(innerProps, defaultRender);\n      };\n    });\n\n    return (outerProps?: TProps, defaultRender?: IRenderFunction<TProps>) => {\n      return outer(outerProps, defaultRender ? innerMemoizer(defaultRender) : inner);\n    };\n  });\n\n  return outerMemoizer;\n}\n\nconst memoizer = createMemoizer<IRenderFunctionComposer>(createComposedRenderFunction);\n\n/**\n * Composes two 'render functions' to produce a final render function that renders\n * the outer function, passing the inner function as 'default render'. The inner function\n * is then passed the original 'default render' prop.\n * @public\n */\nexport function composeRenderFunction<TProps>(\n  outer: IRenderFunction<TProps>,\n  inner: IRenderFunction<TProps>,\n): IRenderFunction<TProps> {\n  return memoizer(outer)(inner);\n}\n", "let _baseUrl = '';\n\n/**\n * @deprecated Unused as of version 8\n */\nexport function getResourceUrl(url: string): string {\n  return _baseUrl + url;\n}\n\n/**\n * @deprecated Unused as of version 8\n */\nexport function setBaseUrl(baseUrl: string): void {\n  _baseUrl = baseUrl;\n}\n", "import * as React from 'react';\nimport { extendComponent } from './extendComponent';\n\n/**\n * Generates a function to be attached to a React component, which can be called\n * as a replacement to RAF. In-flight async calls will be auto canceled if the component\n * is unmounting before the async code is executed, preventing bugs where code\n * accesses things within the component after being unmounted.\n */\nexport const safeRequestAnimationFrame = (component: React.Component): ((cb: Function) => void) => {\n  let activeTimeouts: Set<number>;\n\n  return (cb: Function) => {\n    if (!activeTimeouts) {\n      activeTimeouts = new Set<number>();\n\n      extendComponent(component, {\n        componentWillUnmount: () => {\n          activeTimeouts.forEach((id: number) => cancelAnimationFrame(id));\n        },\n      });\n    }\n\n    const timeoutId = requestAnimationFrame(() => {\n      activeTimeouts.delete(timeoutId);\n      cb();\n    });\n\n    activeTimeouts.add(timeoutId);\n  };\n};\n", "import * as React from 'react';\nimport { extendComponent } from './extendComponent';\n\n/**\n * Generates a function to be attached to a React component, which can be called\n * as a replacement to setTimeout. In-flight async calls will be auto canceled if the component\n * is unmounting before the async code is executed, preventing bugs where code\n * accesses things within the component after being unmounted.\n */\nexport const safeSetTimeout = (component: React.Component) => {\n  let activeTimeouts: Set<ReturnType<typeof setTimeout>>;\n\n  return (cb: Function, duration: number) => {\n    if (!activeTimeouts) {\n      activeTimeouts = new Set();\n\n      extendComponent(component, {\n        componentWillUnmount: () => {\n          activeTimeouts.forEach(id => clearTimeout(id));\n        },\n      });\n    }\n\n    const timeoutId = setTimeout(() => {\n      activeTimeouts.delete(timeoutId);\n      cb();\n    }, duration);\n    activeTimeouts.add(timeoutId);\n  };\n};\n", "/**\n * {@docCategory Selection}\n */\nexport interface IObjectWithKey {\n  key?: string | number;\n}\n\nexport const SELECTION_CHANGE = 'change';\nexport const SELECTION_ITEMS_CHANGE = 'items-change';\n\n/**\n * {@docCategory Selection}\n */\nexport enum SelectionMode {\n  none = 0,\n  single = 1,\n  multiple = 2,\n}\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelection<TItem = IObjectWithKey> {\n  count: number;\n  mode: SelectionMode;\n\n  canSelectItem: (item: TItem, index?: number) => boolean;\n\n  // Obesrvable methods.\n  setChangeEvents(isEnabled: boolean, suppressChange?: boolean): void;\n\n  // Initialization methods.\n\n  setItems(items: TItem[], shouldClear: boolean): void;\n  getItems(): TItem[];\n\n  // Item utility methods.\n  getItemIndex?(key: string): number;\n\n  // Read selection methods.\n\n  getSelection(): TItem[];\n  getSelectedIndices(): number[];\n  getSelectedCount(): number;\n  isRangeSelected(fromIndex: number, count: number): boolean;\n\n  isAllSelected(): boolean;\n  isKeySelected(key: string): boolean;\n  isIndexSelected(index: number): boolean;\n\n  isModal?(): boolean;\n\n  // Write selection methods.\n\n  setAllSelected(isAllSelected: boolean): void;\n  setKeySelected(key: string, isSelected: boolean, shouldAnchor: boolean): void;\n  setIndexSelected(index: number, isSelected: boolean, shouldAnchor: boolean): void;\n  setRangeSelected?(fromIndex: number, count: number, isSelected: boolean, shouldAnchor: boolean): void;\n\n  setModal?(isModal: boolean): void; // TODO make non-optional on next breaking change\n\n  // Write range selection methods.\n\n  selectToKey(key: string, clearSelection?: boolean): void;\n  selectToIndex(index: number, clearSelection?: boolean): void;\n  selectToRange?(index: number, count: number, clearSelection?: boolean): void;\n\n  // Toggle helpers.\n\n  toggleAllSelected(): void;\n  toggleKeySelected(key: string): void;\n  toggleIndexSelected(index: number): void;\n  toggleRangeSelected(fromIndex: number, count: number): void;\n}\n\n/**\n * {@docCategory Selection}\n */\nexport enum SelectionDirection {\n  horizontal = 0,\n  vertical = 1,\n}\n", "import { SELECTION_CHANGE, SelectionMode, SELECTION_ITEMS_CHANGE } from './Selection.types';\nimport { EventGroup } from '../EventGroup';\nimport type { IObjectWithKey, ISelection } from './Selection.types';\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionOptions<TItem = IObjectWithKey> {\n  onSelectionChanged?: () => void;\n  onItemsChanged?: () => void;\n  /** Custom logic to generate item keys. Required if `TItem` does not have a `key` property. */\n  getKey?: (item: TItem, index?: number) => string | number;\n  canSelectItem?: (item: TItem, index?: number) => boolean;\n  selectionMode?: SelectionMode;\n  items?: TItem[];\n}\n\n/**\n * Selection options with required `getKey` property.\n * {@docCategory Selection}\n */\nexport type ISelectionOptionsWithRequiredGetKey<TItem> = ISelectionOptions<TItem> &\n  Required<Pick<ISelectionOptions<TItem>, 'getKey'>>;\n\n/**\n * {@docCategory Selection}\n */\nexport class Selection<TItem = IObjectWithKey> implements ISelection<TItem> {\n  /** Number of items selected. Do not modify. */\n  public count!: number;\n  public readonly mode!: SelectionMode;\n\n  private _getKey!: (item: TItem, index?: number) => string | number;\n  private _canSelectItem!: (item: TItem, index?: number) => boolean;\n\n  private _changeEventSuppressionCount: number;\n  private _items!: TItem[];\n  private _selectedItems!: TItem[] | null;\n  private _selectedIndices: number[] | undefined;\n  private _isAllSelected!: boolean;\n  private _exemptedIndices!: { [index: string]: boolean };\n  private _exemptedCount: number;\n  private _keyToIndexMap!: { [key: string]: number };\n  private _anchoredIndex: number;\n  private _onSelectionChanged: (() => void) | undefined;\n  private _onItemsChanged: (() => void) | undefined;\n  private _hasChanged!: boolean;\n  private _unselectableIndices!: { [index: string]: boolean };\n  private _unselectableCount: number;\n  private _isModal: boolean;\n\n  /**\n   * Create a new Selection. If `TItem` does not have a `key` property, you must provide an options\n   * object with a `getKey` implementation. Providing options is optional otherwise.\n   * (At most one `options` object is accepted.)\n   */\n  constructor(\n    ...options: TItem extends IObjectWithKey // If the item type has a built-in key...\n      ? [] | [ISelectionOptions<TItem>] // Then the arguments can be empty or have the options without `getKey`\n      : [ISelectionOptionsWithRequiredGetKey<TItem>] // Otherwise, arguments require options with `getKey`.\n  ) {\n    const {\n      onSelectionChanged,\n      onItemsChanged,\n      getKey,\n      canSelectItem = () => true,\n      items,\n      selectionMode = SelectionMode.multiple,\n    } = options[0] || ({} as ISelectionOptions<TItem>);\n\n    this.mode = selectionMode;\n\n    this._getKey = getKey || defaultGetKey;\n\n    this._changeEventSuppressionCount = 0;\n    this._exemptedCount = 0;\n    this._anchoredIndex = 0;\n    this._unselectableCount = 0;\n\n    this._onSelectionChanged = onSelectionChanged;\n    this._onItemsChanged = onItemsChanged;\n    this._canSelectItem = canSelectItem;\n    this._keyToIndexMap = {};\n\n    this._isModal = false;\n\n    this.setItems(items || [], true);\n\n    this.count = this.getSelectedCount();\n  }\n\n  public canSelectItem(item: TItem, index?: number): boolean {\n    if (typeof index === 'number' && index < 0) {\n      return false;\n    }\n\n    return this._canSelectItem(item, index);\n  }\n\n  public getKey(item: TItem, index?: number): string {\n    const key = this._getKey(item, index);\n\n    return typeof key === 'number' || key ? `${key}` : '';\n  }\n\n  public setChangeEvents(isEnabled: boolean, suppressChange?: boolean): void {\n    this._changeEventSuppressionCount += isEnabled ? -1 : 1;\n\n    if (this._changeEventSuppressionCount === 0 && this._hasChanged) {\n      this._hasChanged = false;\n\n      if (!suppressChange) {\n        this._change();\n      }\n    }\n  }\n\n  public isModal(): boolean {\n    return this._isModal;\n  }\n\n  public setModal(isModal: boolean): void {\n    if (this._isModal !== isModal) {\n      this.setChangeEvents(false);\n\n      this._isModal = isModal;\n\n      if (!isModal) {\n        this.setAllSelected(false);\n      }\n\n      this._change();\n\n      this.setChangeEvents(true);\n    }\n  }\n\n  /**\n   * Selection needs the items, call this method to set them. If the set\n   * of items is the same, this will re-evaluate selection and index maps.\n   * Otherwise, shouldClear should be set to true, so that selection is\n   * cleared.\n   */\n  public setItems(items: TItem[], shouldClear: boolean = true): void {\n    const newKeyToIndexMap: { [key: string]: number } = {};\n    const newUnselectableIndices: { [key: string]: boolean } = {};\n    let hasSelectionChanged = false;\n\n    this.setChangeEvents(false);\n\n    // Reset the unselectable count.\n    this._unselectableCount = 0;\n\n    let haveItemsChanged = false;\n\n    // Build lookup table for quick selection evaluation.\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n\n      if (item) {\n        const key = this.getKey(item, i);\n\n        if (key) {\n          if (!haveItemsChanged && (!(key in this._keyToIndexMap) || this._keyToIndexMap[key] !== i)) {\n            haveItemsChanged = true;\n          }\n\n          newKeyToIndexMap[key] = i;\n        }\n      }\n\n      newUnselectableIndices[i] = item && !this.canSelectItem(item);\n      if (newUnselectableIndices[i]) {\n        this._unselectableCount++;\n      }\n    }\n\n    if (shouldClear || items.length === 0) {\n      this._setAllSelected(false, true);\n    }\n\n    // Check the exemption list for discrepencies.\n    const newExemptedIndicies: { [key: string]: boolean } = {};\n    let newExemptedCount = 0;\n\n    for (const indexProperty in this._exemptedIndices) {\n      if (this._exemptedIndices.hasOwnProperty(indexProperty)) {\n        const index = Number(indexProperty);\n        const item = this._items[index];\n        const exemptKey = item ? this.getKey(item, Number(index)) : undefined;\n        const newIndex = exemptKey ? newKeyToIndexMap[exemptKey] : index;\n\n        if (newIndex === undefined) {\n          // The item has likely been replaced or removed.\n          hasSelectionChanged = true;\n        } else {\n          // We know the new index of the item. update the existing exemption table.\n          newExemptedIndicies[newIndex] = true;\n          newExemptedCount++;\n          hasSelectionChanged = hasSelectionChanged || newIndex !== index;\n        }\n      }\n    }\n\n    if (this._items && this._exemptedCount === 0 && items.length !== this._items.length && this._isAllSelected) {\n      // If everything was selected but the number of items has changed, selection has changed.\n      hasSelectionChanged = true;\n    }\n\n    if (!haveItemsChanged) {\n      for (const key of Object.keys(this._keyToIndexMap)) {\n        if (!(key in newKeyToIndexMap)) {\n          haveItemsChanged = true;\n          break;\n        }\n      }\n    }\n\n    this._exemptedIndices = newExemptedIndicies;\n    this._exemptedCount = newExemptedCount;\n    this._keyToIndexMap = newKeyToIndexMap;\n    this._unselectableIndices = newUnselectableIndices;\n    this._items = items;\n    this._selectedItems = null;\n\n    if (hasSelectionChanged) {\n      this._updateCount();\n    }\n\n    if (haveItemsChanged) {\n      EventGroup.raise(this, SELECTION_ITEMS_CHANGE);\n\n      if (this._onItemsChanged) {\n        this._onItemsChanged();\n      }\n    }\n\n    if (hasSelectionChanged) {\n      this._change();\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public getItems(): TItem[] {\n    return this._items;\n  }\n\n  public getSelection(): TItem[] {\n    if (!this._selectedItems) {\n      this._selectedItems = [];\n\n      const items = this._items;\n\n      if (items) {\n        for (let i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedItems.push(items[i]);\n          }\n        }\n      }\n    }\n\n    return this._selectedItems;\n  }\n\n  public getSelectedCount(): number {\n    return this._isAllSelected\n      ? this._items.length - this._exemptedCount - this._unselectableCount\n      : this._exemptedCount;\n  }\n\n  public getSelectedIndices(): number[] {\n    if (!this._selectedIndices) {\n      this._selectedIndices = [];\n\n      const items = this._items;\n\n      if (items) {\n        for (let i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedIndices.push(i);\n          }\n        }\n      }\n    }\n\n    return this._selectedIndices;\n  }\n\n  public getItemIndex(key: string): number {\n    const index = this._keyToIndexMap[key];\n\n    return index ?? -1;\n  }\n\n  public isRangeSelected(fromIndex: number, count: number): boolean {\n    if (count === 0) {\n      return false;\n    }\n\n    const endIndex = fromIndex + count;\n\n    for (let i = fromIndex; i < endIndex; i++) {\n      if (!this.isIndexSelected(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public isAllSelected(): boolean {\n    let selectableCount = this._items.length - this._unselectableCount;\n\n    // In single mode, we can only have a max of 1 item.\n    if (this.mode === SelectionMode.single) {\n      selectableCount = Math.min(selectableCount, 1);\n    }\n\n    return (\n      (this.count > 0 && this._isAllSelected && this._exemptedCount === 0) ||\n      (!this._isAllSelected && this._exemptedCount === selectableCount && selectableCount > 0)\n    );\n  }\n\n  public isKeySelected(key: string): boolean {\n    const index = this._keyToIndexMap[key];\n\n    return this.isIndexSelected(index);\n  }\n\n  public isIndexSelected(index: number): boolean {\n    return !!(\n      (this.count > 0 && this._isAllSelected && !this._exemptedIndices[index] && !this._unselectableIndices[index]) ||\n      (!this._isAllSelected && this._exemptedIndices[index])\n    );\n  }\n\n  public setAllSelected(isAllSelected: boolean): void {\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n\n    const selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n\n    this.setChangeEvents(false);\n\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n        this._change();\n      }\n\n      this._updateCount();\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public setKeySelected(key: string, isSelected: boolean, shouldAnchor: boolean): void {\n    const index = this._keyToIndexMap[key];\n\n    if (index >= 0) {\n      this.setIndexSelected(index, isSelected, shouldAnchor);\n    }\n  }\n\n  public setIndexSelected(index: number, isSelected: boolean, shouldAnchor: boolean): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    // Clamp the index.\n    index = Math.min(Math.max(0, index), this._items.length - 1);\n\n    // No-op on out of bounds selections.\n    if (index < 0 || index >= this._items.length) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n\n    const isExempt = this._exemptedIndices[index];\n    const canSelect = !this._unselectableIndices[index];\n\n    if (canSelect) {\n      if (isSelected && this.mode === SelectionMode.single) {\n        // If this is single-select, the previous selection should be removed.\n        this._setAllSelected(false, true);\n      }\n\n      // Determine if we need to remove the exemption.\n      if (isExempt && ((isSelected && this._isAllSelected) || (!isSelected && !this._isAllSelected))) {\n        delete this._exemptedIndices[index];\n        this._exemptedCount--;\n      }\n\n      // Determine if we need to add the exemption.\n      if (!isExempt && ((isSelected && !this._isAllSelected) || (!isSelected && this._isAllSelected))) {\n        this._exemptedIndices[index] = true;\n        this._exemptedCount++;\n      }\n\n      if (shouldAnchor) {\n        this._anchoredIndex = index;\n      }\n    }\n\n    this._updateCount();\n\n    this.setChangeEvents(true);\n  }\n\n  public setRangeSelected(fromIndex: number, count: number, isSelected: boolean, shouldAnchor: boolean): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    // Clamp the index.\n    fromIndex = Math.min(Math.max(0, fromIndex), this._items.length - 1);\n\n    // Clamp the range.\n    count = Math.min(Math.max(0, count), this._items.length - fromIndex);\n\n    // No-op on out of bounds selections.\n    if (fromIndex < 0 || fromIndex >= this._items.length || count === 0) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n\n    const anchorIndex = this._anchoredIndex || 0;\n    let startIndex = fromIndex;\n    const endIndex = fromIndex + count - 1;\n\n    const newAnchorIndex = anchorIndex >= endIndex ? startIndex : endIndex;\n\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, isSelected, shouldAnchor ? startIndex === newAnchorIndex : false);\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public selectToKey(key: string, clearSelection?: boolean): void {\n    this.selectToIndex(this._keyToIndexMap[key], clearSelection);\n  }\n\n  public selectToRange(fromIndex: number, count: number, clearSelection?: boolean): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    if (this.mode === SelectionMode.single) {\n      if (count === 1) {\n        this.setIndexSelected(fromIndex, true, true);\n      }\n      return;\n    }\n\n    const anchorIndex = this._anchoredIndex || 0;\n    let startIndex = Math.min(fromIndex, anchorIndex);\n    const endIndex = Math.max(fromIndex + count - 1, anchorIndex);\n\n    this.setChangeEvents(false);\n\n    if (clearSelection) {\n      this._setAllSelected(false, true);\n    }\n\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, true, false);\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public selectToIndex(index: number, clearSelection?: boolean): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    if (this.mode === SelectionMode.single) {\n      this.setIndexSelected(index, true, true);\n      return;\n    }\n\n    const anchorIndex = this._anchoredIndex || 0;\n    let startIndex = Math.min(index, anchorIndex);\n    const endIndex = Math.max(index, anchorIndex);\n\n    this.setChangeEvents(false);\n\n    if (clearSelection) {\n      this._setAllSelected(false, true);\n    }\n\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, true, false);\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public toggleAllSelected(): void {\n    this.setAllSelected(!this.isAllSelected());\n  }\n\n  public toggleKeySelected(key: string): void {\n    this.setKeySelected(key, !this.isKeySelected(key), true);\n  }\n\n  public toggleIndexSelected(index: number): void {\n    this.setIndexSelected(index, !this.isIndexSelected(index), true);\n  }\n\n  public toggleRangeSelected(fromIndex: number, count: number): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    const isRangeSelected = this.isRangeSelected(fromIndex, count);\n    const endIndex = fromIndex + count;\n\n    if (this.mode === SelectionMode.single && count > 1) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n    for (let i = fromIndex; i < endIndex; i++) {\n      this.setIndexSelected(i, !isRangeSelected, false);\n    }\n    this.setChangeEvents(true);\n  }\n\n  private _updateCount(preserveModalState: boolean = false): void {\n    const count = this.getSelectedCount();\n\n    if (count !== this.count) {\n      this.count = count;\n      this._change();\n    }\n\n    if (!this.count && !preserveModalState) {\n      this.setModal(false);\n    }\n  }\n\n  private _setAllSelected(isAllSelected: boolean, preserveModalState: boolean = false): void {\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n\n    const selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n\n    this.setChangeEvents(false);\n\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n        this._change();\n      }\n\n      this._updateCount(preserveModalState);\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  private _change(): void {\n    if (this._changeEventSuppressionCount === 0) {\n      this._selectedItems = null;\n      this._selectedIndices = undefined;\n\n      EventGroup.raise(this, SELECTION_CHANGE);\n\n      if (this._onSelectionChanged) {\n        this._onSelectionChanged();\n      }\n    } else {\n      this._hasChanged = true;\n    }\n  }\n}\n\nfunction defaultGetKey<TItem = IObjectWithKey>(item: TItem, index?: number): string | number {\n  // 0 may be used as a key\n  const { key = `${index}` } = (item || {}) as IObjectWithKey;\n  return key;\n}\n", "// Regex that finds { and } so they can be removed on a lookup for string format\nconst FORMAT_ARGS_REGEX = /[\\{\\}]/g;\n\n// Regex that finds {#} so it can be replaced by the arguments in string format\nconst FORMAT_REGEX = /\\{\\d+\\}/g;\n\n/**\n * String format method, used for scenarios where at runtime you\n * need to evaluate a formatted string given a tokenized string. This\n * usually only is needed in localization scenarios.\n\n * @example\n * ```tsx\n * \"I love {0} every {1}\".format(\"CXP\")\n * ```\n * will result in a Debug Exception.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function format(s: string, ...values: any[]): string {\n  let args = values;\n  // Callback match function\n  function replaceFunc(match: string): string {\n    // looks up in the args\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let replacement = args[match.replace(FORMAT_ARGS_REGEX, '') as any];\n\n    // catches undefined in nondebug and null in debug and nondebug\n    if (replacement === null || replacement === undefined) {\n      replacement = '';\n    }\n\n    return replacement;\n  }\n  return s.replace(FORMAT_REGEX, replaceFunc);\n}\n", "import * as React from 'react';\nimport { concatStyleSetsWithProps } from '@fluentui/merge-styles';\nimport { useMergeStylesHooks } from './shadowDom/index';\nimport { useCustomizationSettings } from './customizations/useCustomizationSettings';\nimport type { IStyleSetBase, IStyleFunctionOrObject, ShadowConfig } from '@fluentui/merge-styles';\n\nexport interface IPropsWithStyles<TStyleProps, TStyleSet extends IStyleSetBase> {\n  styles?: IStyleFunctionOrObject<TStyleProps, TStyleSet>;\n}\n\nexport interface ICustomizableProps {\n  /**\n   * Name of scope, which can be targeted using the Customizer.\n   */\n  scope: string;\n\n  /**\n   * List of fields which can be customized.\n   * @defaultvalue [ 'theme', 'styles' ]\n   */\n  fields?: string[];\n}\n\nconst DefaultFields = ['theme', 'styles'];\n\nexport type StyleFunction<TStyleProps, TStyleSet extends IStyleSetBase> = IStyleFunctionOrObject<\n  TStyleProps,\n  TStyleSet\n> & {\n  /** Cache for all style functions. */\n  __cachedInputs__: (IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined)[];\n\n  /** True if no styles prop or styles from Customizer is passed to wrapped component. */\n  __noStyleOverride__: boolean;\n\n  /** Shadow DOM configuration object */\n  __shadowConfig__?: ShadowConfig;\n};\n\n/**\n * The styled HOC wrapper allows you to create a functional wrapper around a given component which will resolve\n * getStyles functional props, and mix customized props passed in using concatStyleSets.\n *\n * @example\n * ```tsx\n * export const Toggle = styled(\n *   ToggleBase,\n *   props => ({ root: { background: 'red' }})\n * );\n * ```\n * @param Component - The unstyled base component to render, which receives styles.\n * @param baseStyles - The styles which should be curried with the component.\n * @param getProps - A helper which provides default props.\n * @param customizable - An object which defines which props can be customized using the Customizer.\n * @param pure - A boolean indicating if the component should avoid re-rendering when props haven't changed.\n * Note that pure should not be used on components which allow children, or take in complex objects or\n * arrays as props which could mutate on every render.\n */\nexport function styled<\n  TComponentProps extends IPropsWithStyles<TStyleProps, TStyleSet>,\n  TStyleProps,\n  TStyleSet extends IStyleSetBase,\n>(\n  Component: React.ComponentClass<TComponentProps> | React.FunctionComponent<TComponentProps>,\n  baseStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet>,\n  getProps?: (props: TComponentProps) => Partial<TComponentProps>,\n  customizable?: ICustomizableProps,\n  pure?: boolean,\n): React.FunctionComponent<TComponentProps>;\nexport function styled<\n  TComponentProps extends IPropsWithStyles<TStyleProps, TStyleSet> & React.RefAttributes<TRef>,\n  TStyleProps,\n  TStyleSet extends IStyleSetBase,\n  TRef = unknown,\n>(\n  Component: React.ComponentClass<TComponentProps> | React.FunctionComponent<TComponentProps>,\n  baseStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet>,\n  getProps?: (props: TComponentProps) => Partial<TComponentProps>,\n  customizable?: ICustomizableProps,\n  pure?: boolean,\n): React.ForwardRefExoticComponent<React.PropsWithoutRef<TComponentProps> & React.RefAttributes<TRef>>;\nexport function styled<\n  TComponentProps extends IPropsWithStyles<TStyleProps, TStyleSet> & React.RefAttributes<TRef>,\n  TStyleProps,\n  TStyleSet extends IStyleSetBase,\n  TRef = unknown,\n>(\n  Component: React.ComponentClass<TComponentProps> | React.FunctionComponent<TComponentProps>,\n  baseStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet>,\n  getProps?: (props: TComponentProps) => Partial<TComponentProps>,\n  customizable?: ICustomizableProps,\n  pure?: boolean,\n) {\n  customizable = customizable || { scope: '', fields: undefined };\n\n  const { scope, fields = DefaultFields } = customizable;\n\n  const Wrapped = React.forwardRef((props: TComponentProps, forwardedRef: React.Ref<TRef>) => {\n    const styles = React.useRef<StyleFunction<TStyleProps, TStyleSet>>();\n\n    const settings = useCustomizationSettings(fields, scope);\n    const { styles: customizedStyles, dir, ...rest } = settings;\n    const additionalProps = getProps ? getProps(props) : undefined;\n\n    const { useStyled } = useMergeStylesHooks();\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const cache = (styles.current && (styles.current as any).__cachedInputs__) || [];\n    const propStyles = props.styles;\n    if (!styles.current || customizedStyles !== cache[1] || propStyles !== cache[2]) {\n      // Using styled components as the Component arg will result in nested styling arrays.\n      // The function can be cached and in order to prevent the props from being retained within it's closure\n      // we pass in just the styles and not the entire props\n      const concatenatedStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet> = (styleProps: TStyleProps) =>\n        concatStyleSetsWithProps(styleProps, baseStyles, customizedStyles, propStyles);\n\n      // The __cachedInputs__ array is attached to the function and consumed by the\n      // classNamesFunction as a list of keys to include for memoizing classnames.\n      (concatenatedStyles as StyleFunction<TStyleProps, TStyleSet>).__cachedInputs__ = [\n        baseStyles,\n        customizedStyles,\n        propStyles,\n      ];\n\n      (concatenatedStyles as StyleFunction<TStyleProps, TStyleSet>).__noStyleOverride__ =\n        !customizedStyles && !propStyles;\n\n      styles.current = concatenatedStyles as StyleFunction<TStyleProps, TStyleSet>;\n    }\n\n    styles.current.__shadowConfig__ = useStyled(scope);\n\n    return <Component ref={forwardedRef} {...rest} {...additionalProps} {...props} styles={styles.current} />;\n  });\n  // Function.prototype.name is an ES6 feature, so the cast to any is required until we're\n  // able to drop IE 11 support and compile with ES6 libs\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Wrapped.displayName = `Styled${Component.displayName || (Component as any).name}`;\n\n  // This preserves backwards compatibility.\n  const pureComponent = pure ? React.memo(Wrapped) : Wrapped;\n  // Check if the wrapper has a displayName after it has been memoized. Then assign it to the pure component.\n  if (Wrapped.displayName) {\n    pureComponent.displayName = Wrapped.displayName;\n  }\n\n  return pureComponent;\n}\n", "import * as React from 'react';\nimport { GLOBAL_STYLESHEET_KEY, ShadowDomStylesheet, makeShadowConfig } from '@fluentui/merge-styles';\nimport { getWindow } from '../../dom';\nimport { MergeStylesDefaultContext, getNewContext } from './MergeStylesDefaultContext';\nimport {\n  useAdoptedStylesheet as useAdoptedStylesheetDefault,\n  useAdoptedStylesheetEx as useAdoptedStylesheetExDefault,\n} from '../hooks/useAdoptedStylesheet';\n\nimport { useShadowConfig as useShadowConfigDefault } from '../hooks/useShadowConfig';\nimport {\n  useHasMergeStylesShadowRootContext as useHasMergeStylesShadowRootContextDefault,\n  useMergeStylesShadowRootContext as useMergeStylesShadowRootContextDefault,\n} from '../hooks/useMergeStylesShadowRoot';\nimport { useMergeStylesRootStylesheets as useMergeStylesRootStylesheetsDefault } from '../hooks/useMergeStylesRootStylesheets';\nimport { useStyled as useStyledDefault } from '../hooks/useStyled';\nimport { useWindow as useWindowDefault } from '@fluentui/react-window-provider';\n\nimport type { ExtendedCSSStyleSheet } from '@fluentui/merge-styles';\nimport type { AdoptedStylesheetExHook, AdoptedStylesheetHook } from '../hooks/useAdoptedStylesheet';\nimport type { ShadowConfigHook } from '../hooks/useShadowConfig';\nimport type {\n  HasMergeStylesShadowRootContextHook,\n  MergeStylesShadowRootContextHook,\n} from '../hooks/useMergeStylesShadowRoot';\nimport type { MergeStylesRootStylesheetsHook } from '../hooks/useMergeStylesRootStylesheets';\nimport type { UseStyledHook } from '../hooks/useStyled';\nimport type { UseWindowHook } from './MergeStylesDefaultContext';\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  interface DocumentOrShadowRoot {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/adoptedStyleSheets) */\n    adoptedStyleSheets: CSSStyleSheet[];\n  }\n}\n\nexport type MergeStylesRootContextValue = {\n  stylesheets: Map<string, ExtendedCSSStyleSheet>;\n  useAdoptedStylesheetEx: AdoptedStylesheetExHook;\n  useAdoptedStylesheet: AdoptedStylesheetHook;\n  useShadowConfig: ShadowConfigHook;\n  useMergeStylesShadowRootContext: MergeStylesShadowRootContextHook;\n  useHasMergeStylesShadowRootContext: HasMergeStylesShadowRootContextHook;\n  useMergeStylesRootStylesheets: MergeStylesRootStylesheetsHook;\n  useWindow: UseWindowHook;\n  useStyled: UseStyledHook;\n};\n\nexport const MergeStylesRootContext = React.createContext<MergeStylesRootContextValue>(getNewContext());\n\nexport type MergeStylesRootProviderProps = {\n  /**\n   * Map of stylesheets available in the context.\n   */\n  stylesheets?: Map<string, ExtendedCSSStyleSheet>;\n\n  /**\n   * Optional `window` object to use for reading adopted stylesheets.\n   * Useful for multi-window scenarios.\n   */\n  window?: Window;\n\n  useAdoptedStylesheetEx?: AdoptedStylesheetExHook;\n  useAdoptedStylesheet?: AdoptedStylesheetHook;\n  useShadowConfig?: ShadowConfigHook;\n  useMergeStylesShadowRootContext?: MergeStylesShadowRootContextHook;\n  useHasMergeStylesShadowRootContext?: HasMergeStylesShadowRootContextHook;\n  useMergeStylesRootStylesheets?: MergeStylesRootStylesheetsHook;\n  useWindow?: UseWindowHook;\n  useStyled?: UseStyledHook;\n};\n\n/**\n * Root context provider for mergeStyles shadow DOM.\n * Typically this is placed at the render root of your React application.\n */\nexport const MergeStylesRootProvider: React.FC<MergeStylesRootProviderProps> = ({\n  stylesheets: userSheets,\n  window: userWindow,\n  useAdoptedStylesheet,\n  useAdoptedStylesheetEx,\n  useShadowConfig,\n  useMergeStylesShadowRootContext,\n  useHasMergeStylesShadowRootContext,\n  useMergeStylesRootStylesheets,\n  useWindow,\n  useStyled,\n  ...props\n}) => {\n  const win = userWindow ?? getWindow();\n  const [stylesheets, setStylesheets] = React.useState<Map<string, ExtendedCSSStyleSheet>>(\n    () => userSheets || new Map(),\n  );\n\n  const sheetHandler = React.useCallback(({ key, sheet }) => {\n    setStylesheets(prev => {\n      const next = new Map<string, ExtendedCSSStyleSheet>(prev);\n      next.set(key, sheet);\n      return next;\n    });\n  }, []);\n\n  // Udapte stylesheets based on user style sheet changes\n  React.useEffect(() => {\n    setStylesheets(userSheets || new Map());\n  }, [userSheets]);\n\n  // Wire up listener for adopted stylesheets\n  React.useEffect(() => {\n    if (!win) {\n      return;\n    }\n\n    const sheet = ShadowDomStylesheet.getInstance(makeShadowConfig(GLOBAL_STYLESHEET_KEY, false, win));\n    const off = sheet.onAddSheet(sheetHandler);\n\n    return () => {\n      off();\n    };\n  }, [win, sheetHandler]);\n\n  // Read stylesheets from window on mount\n  React.useEffect(() => {\n    if (!win) {\n      return;\n    }\n\n    let changed = false;\n    const next = new Map<string, ExtendedCSSStyleSheet>(stylesheets);\n    const sheet = ShadowDomStylesheet.getInstance(makeShadowConfig(GLOBAL_STYLESHEET_KEY, false, win));\n\n    const adoptedSheets = sheet.getAdoptedSheets();\n\n    adoptedSheets.forEach((adoptedSheet, key) => {\n      next.set(key, adoptedSheet);\n      changed = true;\n    });\n\n    if (changed) {\n      setStylesheets(next);\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const defaultValues = React.useMemo(() => {\n    return {\n      stylesheets,\n      useAdoptedStylesheet: useAdoptedStylesheet || useAdoptedStylesheetDefault,\n      useAdoptedStylesheetEx: useAdoptedStylesheetEx || useAdoptedStylesheetExDefault,\n      useShadowConfig: useShadowConfig || useShadowConfigDefault,\n      useMergeStylesShadowRootContext: useMergeStylesShadowRootContext || useMergeStylesShadowRootContextDefault,\n      useHasMergeStylesShadowRootContext:\n        useHasMergeStylesShadowRootContext || useHasMergeStylesShadowRootContextDefault,\n      useMergeStylesRootStylesheets: useMergeStylesRootStylesheets || useMergeStylesRootStylesheetsDefault,\n      useWindow: useWindow || useWindowDefault,\n      useStyled: useStyled || useStyledDefault,\n    };\n  }, [\n    stylesheets,\n    useAdoptedStylesheet,\n    useAdoptedStylesheetEx,\n    useShadowConfig,\n    useMergeStylesShadowRootContext,\n    useHasMergeStylesShadowRootContext,\n    useMergeStylesRootStylesheets,\n    useWindow,\n    useStyled,\n  ]);\n\n  return (\n    <MergeStylesDefaultContext.Provider value={defaultValues}>\n      <MergeStylesRootContext.Provider value={defaultValues} {...props} />\n    </MergeStylesDefaultContext.Provider>\n  );\n};\n", "import * as React from 'react';\nimport {\n  SUPPORTS_CONSTRUCTABLE_STYLESHEETS,\n  SUPPORTS_MODIFYING_ADOPTED_STYLESHEETS,\n  Stylesheet,\n  makeShadowConfig,\n  cloneCSSStyleSheet,\n} from '@fluentui/merge-styles';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport { useMergeStylesRootStylesheets } from './useMergeStylesRootStylesheets';\nimport { useMergeStylesShadowRootContext } from './useMergeStylesShadowRoot';\nimport type { ExtendedCSSStyleSheet, InsertRuleCallback } from '@fluentui/merge-styles';\nimport type { MergeStylesShadowRootContextValue } from '../contexts/MergeStylesShadowRootContext';\n\ntype PolyfillInsertListeners = Record<string, Function>;\n\nexport type AdoptedStylesheetHook = (stylesheetKey: string) => boolean;\nexport type AdoptedStylesheetExHook = (\n  stylesheetKey: string,\n  shadowCtx: MergeStylesShadowRootContextValue | undefined,\n  rootMergeStyles: Map<string, ExtendedCSSStyleSheet>,\n  win: Window | undefined,\n) => boolean;\n\n/**\n * Use adopted stylesheets in the parent shadow root.\n */\nexport const useAdoptedStylesheet: AdoptedStylesheetHook = stylesheetKey => {\n  const shadowCtx = useMergeStylesShadowRootContext();\n  const rootMergeStyles = useMergeStylesRootStylesheets();\n  const win = useWindow();\n\n  return useAdoptedStylesheetEx(stylesheetKey, shadowCtx, rootMergeStyles, win);\n};\n\n/**\n * Optimization for specific cases like nested customizables.\n */\nexport const useAdoptedStylesheetEx: AdoptedStylesheetExHook = (stylesheetKey, shadowCtx, rootMergeStyles, win) => {\n  const polyfillInsertListners = React.useRef<PolyfillInsertListeners>({});\n\n  React.useEffect(() => {\n    if (!shadowCtx) {\n      return;\n    }\n    const polyfillListeners = polyfillInsertListners.current;\n    polyfillInsertListners.current = {};\n\n    return () => {\n      Object.keys(polyfillListeners).forEach(key => {\n        polyfillListeners[key]();\n      });\n    };\n  }, [win, stylesheetKey, shadowCtx]);\n\n  if (!shadowCtx) {\n    return false;\n  }\n\n  if (shadowCtx.shadowRoot && !shadowCtx.stylesheets.has(stylesheetKey)) {\n    const adoptableStyleSheet = rootMergeStyles.get(stylesheetKey);\n    if (adoptableStyleSheet && win?.document) {\n      adoptSheet(shadowCtx, win.document, stylesheetKey, adoptableStyleSheet, polyfillInsertListners.current);\n    }\n  }\n\n  return true;\n};\n\nconst updatePolyfillSheet = (shadowCtx: MergeStylesShadowRootContextValue, stylesheetKey: string, rule: string) => {\n  const shadowRoot = shadowCtx.shadowRoot!;\n  const style = shadowRoot.querySelector(`[data-merge-styles-stylesheet-key=\"${stylesheetKey}\"]`) as HTMLStyleElement;\n  if (style?.sheet) {\n    style.sheet.insertRule(rule);\n  }\n};\n\nconst adoptSheet = (\n  shadowCtx: MergeStylesShadowRootContextValue,\n  doc: Document,\n  stylesheetKey: string,\n  stylesheet: ExtendedCSSStyleSheet,\n  listenerRef: PolyfillInsertListeners,\n) => {\n  const shadowRoot = shadowCtx.shadowRoot!;\n\n  shadowCtx.stylesheets.set(stylesheetKey, stylesheet);\n  if (SUPPORTS_CONSTRUCTABLE_STYLESHEETS) {\n    // Maintain the sort order of Fluent style sheets\n    const prevSheets = shadowRoot.adoptedStyleSheets;\n    let i = prevSheets.length;\n    let found = i === 0;\n    while (i >= 0 && !found) {\n      i--;\n\n      const prevSheet = prevSheets[i] as ExtendedCSSStyleSheet;\n      const prevSortOrder = (prevSheet.metadata?.sortOrder as number) ?? 0;\n      const sheetSortOrder = (stylesheet.metadata?.sortOrder as number) ?? 0;\n      if (prevSheet.bucketName === 'merge-styles' && prevSortOrder < sheetSortOrder) {\n        found = true;\n      }\n    }\n\n    if (SUPPORTS_MODIFYING_ADOPTED_STYLESHEETS) {\n      // The current spec allows the `adoptedStyleSheets` array to be modified.\n      // Previous versions of the spec required a new array to be created.\n      // For more details see: https://github.com/microsoft/fast/pull/6703\n      shadowRoot.adoptedStyleSheets.splice(i + 1, 0, stylesheet);\n    } else {\n      shadowRoot.adoptedStyleSheets = [\n        ...shadowRoot.adoptedStyleSheets.slice(0, i + 1),\n        stylesheet,\n        ...shadowRoot.adoptedStyleSheets.slice(i + 1),\n      ];\n    }\n  } else {\n    const style = doc.createElement('style');\n    style.setAttribute('data-merge-styles-stylesheet-key', stylesheetKey);\n\n    const otherStyles = shadowRoot.querySelectorAll('[data-merge-styles-stylesheet-key]');\n    if (otherStyles.length > 0) {\n      shadowRoot.insertBefore(style, otherStyles[otherStyles.length - 1].nextSibling);\n    } else {\n      shadowRoot.insertBefore(style, shadowRoot.firstChild);\n    }\n\n    if (style.sheet) {\n      cloneCSSStyleSheet(stylesheet, style.sheet);\n      if (!listenerRef[stylesheetKey]) {\n        const onInsert: InsertRuleCallback = ({ key, rule }) => {\n          if (key === stylesheetKey) {\n            if (shadowCtx && rule) {\n              updatePolyfillSheet(shadowCtx, key, rule);\n            }\n          }\n        };\n        const polyfillSheet = Stylesheet.getInstance(\n          makeShadowConfig(stylesheetKey, true, doc.defaultView ?? undefined),\n        );\n        listenerRef[stylesheetKey] = polyfillSheet.onInsertRule(onInsert);\n      }\n    }\n  }\n};\n", "import * as React from 'react';\nimport { MergeStylesDefaultContext } from '../contexts/MergeStylesDefaultContext';\nimport type { ExtendedCSSStyleSheet } from '@fluentui/merge-styles';\n\nexport type MergeStylesRootStylesheetsHook = () => Map<string, ExtendedCSSStyleSheet>;\n\n/**\n * Get the map of stylesheets available in the context.\n */\nexport const useMergeStylesRootStylesheets: MergeStylesRootStylesheetsHook = () => {\n  return React.useContext(MergeStylesDefaultContext).stylesheets;\n};\n", "import * as React from 'react';\nimport { makeShadowConfig } from '@fluentui/merge-styles';\nimport type { ShadowConfig } from '@fluentui/merge-styles';\n\nexport type ShadowConfigHook = (stylesheetKey: string, inShadow: boolean, win?: Window) => ShadowConfig;\n\n/**\n * Get a shadow config.\n * @param stylesheetKey - Globally unique key\n * @param win - Reference to the `window` global.\n * @returns ShadowConfig\n */\nexport const useShadowConfig: ShadowConfigHook = (stylesheetKey, inShadow = false, win?) => {\n  return React.useMemo(() => {\n    return makeShadowConfig(stylesheetKey, inShadow, win);\n  }, [stylesheetKey, inShadow, win]);\n};\n", "import { ShadowConfig } from '@fluentui/merge-styles';\nimport { getWindow } from '../../dom';\nimport { useMergeStylesHooks } from './useMergeStylesHooks';\n\nexport type UseStyledHook = (scope: string) => ShadowConfig | undefined;\n\nexport const useStyled: UseStyledHook = (scope = '__global__') => {\n  const {\n    useAdoptedStylesheetEx,\n    useShadowConfig,\n    useMergeStylesShadowRootContext,\n    useMergeStylesRootStylesheets,\n    useWindow,\n  } = useMergeStylesHooks();\n\n  const win = useWindow() || getWindow();\n  const shadowCtx = useMergeStylesShadowRootContext();\n  const inShadow = !!shadowCtx;\n  const rootMergeStyles = useMergeStylesRootStylesheets();\n  const shadowConfig = useShadowConfig(scope, inShadow, win);\n\n  useAdoptedStylesheetEx(scope, shadowCtx, rootMergeStyles, win);\n\n  return shadowConfig;\n};\n", "import { warn } from './warn';\nimport { isControlled as checkIsControlled } from '../controlled';\n\ntype WarningMap = { [id: string]: boolean };\n\nlet warningsMap: {\n  valueOnChange: WarningMap;\n  valueDefaultValue: WarningMap;\n  controlledToUncontrolled: WarningMap;\n  uncontrolledToControlled: WarningMap;\n};\nif (process.env.NODE_ENV !== 'production') {\n  warningsMap = {\n    valueOnChange: {},\n    valueDefaultValue: {},\n    controlledToUncontrolled: {},\n    uncontrolledToControlled: {},\n  };\n}\n\n/** Reset controlled usage warnings for testing purposes. */\nexport function resetControlledWarnings(): void {\n  if (process.env.NODE_ENV !== 'production') {\n    warningsMap.valueOnChange = {};\n    warningsMap.valueDefaultValue = {};\n    warningsMap.controlledToUncontrolled = {};\n    warningsMap.uncontrolledToControlled = {};\n  }\n}\n\nexport interface IWarnControlledUsageParams<P> {\n  /** ID of the component instance. Used to prevent showing warnings repeatedly. */\n  componentId: string;\n  /** Name of the component class. */\n  componentName: string;\n  /** Current props to evaluate. */\n  props: P;\n  /** Previous props to evaluate (undefined if called in the constructor). */\n  oldProps?: P;\n  /** Name of the prop for the controlled value. */\n  valueProp: keyof P;\n  /** Name of the prop for the uncontrolled initial value. */\n  defaultValueProp: keyof P;\n  /** Name of the change handler prop. */\n  onChangeProp: keyof P;\n  /** Name of the read-only prop. */\n  readOnlyProp?: keyof P;\n}\n\n/**\n * Check for and warn on the following error conditions with a form component:\n * - A value prop is provided (indicated it's being used as controlled) without a change handler,\n *    and the component is not read-only\n * - Both the value and defaultValue props are provided\n * - The component is attempting to switch between controlled and uncontrolled\n *\n * The messages mimic the warnings React gives for these error conditions on input elements.\n * The warning will only be displayed once per component ID.\n */\nexport function warnControlledUsage<P>(params: IWarnControlledUsageParams<P>): void {\n  if (process.env.NODE_ENV !== 'production') {\n    const { componentId, componentName, defaultValueProp, props, oldProps, onChangeProp, readOnlyProp, valueProp } =\n      params;\n\n    // This warning logic closely follows what React does for native <input> elements.\n\n    const oldIsControlled = oldProps ? checkIsControlled(oldProps, valueProp) : undefined;\n    const newIsControlled = checkIsControlled(props, valueProp);\n\n    if (newIsControlled) {\n      // onChange (or readOnly) must be provided if value is provided\n      const hasOnChange = !!props[onChangeProp];\n      const isReadOnly = !!(readOnlyProp && props[readOnlyProp]);\n      if (!(hasOnChange || isReadOnly) && !warningsMap.valueOnChange[componentId]) {\n        warningsMap.valueOnChange[componentId] = true;\n        warn(\n          `Warning: You provided a '${String(valueProp)}' prop to a ${String(componentName)} without an '${String(\n            onChangeProp,\n          )}' handler. ` +\n            `This will render a read-only field. If the field should be mutable use '${String(defaultValueProp)}'. ` +\n            `Otherwise, set '${String(onChangeProp)}'${readOnlyProp ? ` or '${String(readOnlyProp)}'` : ''}.`,\n        );\n      }\n\n      // value and defaultValue are mutually exclusive\n      const defaultValue = props[defaultValueProp];\n      if (defaultValue !== undefined && defaultValue !== null && !warningsMap.valueDefaultValue[componentId]) {\n        warningsMap.valueDefaultValue[componentId] = true;\n        warn(\n          `Warning: You provided both '${String(valueProp)}' and '${String(\n            defaultValueProp,\n          )}' to a ${componentName}. ` +\n            `Form fields must be either controlled or uncontrolled (specify either the '${String(valueProp)}' prop, ` +\n            `or the '${String(\n              defaultValueProp,\n            )}' prop, but not both). Decide between using a controlled or uncontrolled ` +\n            `${componentName} and remove one of these props. More info: https://fb.me/react-controlled-components`,\n        );\n      }\n    }\n\n    // Warn if switching between uncontrolled and controlled. (One difference between this implementation\n    // and React's <input> is that if oldIsControlled is indeterminate and newIsControlled true, we don't warn.)\n    if (oldProps && newIsControlled !== oldIsControlled) {\n      const oldType = oldIsControlled ? 'a controlled' : 'an uncontrolled';\n      const newType = oldIsControlled ? 'uncontrolled' : 'controlled';\n      const warnMap = oldIsControlled ? warningsMap.controlledToUncontrolled : warningsMap.uncontrolledToControlled;\n      if (!warnMap[componentId]) {\n        warnMap[componentId] = true;\n        warn(\n          `Warning: A component is changing ${oldType} ${componentName} to be ${newType}. ` +\n            `${componentName}s should not switch from controlled to uncontrolled (or vice versa). ` +\n            `Decide between using controlled or uncontrolled for the lifetime of the component. ` +\n            `More info: https://fb.me/react-controlled-components`,\n        );\n      }\n    }\n  }\n}\n", "import { getWindow } from './dom/getWindow';\n\nexport const isIE11 = (): boolean => {\n  const win = getWindow();\n\n  if (!win?.navigator?.userAgent) {\n    return false;\n  }\n\n  return win.navigator.userAgent.indexOf('rv:11.0') > -1;\n};\n", "/**\n * Function to apply default values to a component props object. This function is intended for function components,\n * to maintain parity with the `defaultProps` feature of class components. It accounts for properties that are\n * specified, but undefined.\n * @param defaultProps- An object with default values for various properties\n * @param propsWithoutDefaults- The props object passed into the component\n */\nexport function getPropsWithDefaults<TProps extends {}>(\n  defaultProps: Partial<TProps>,\n  propsWithoutDefaults: TProps,\n): TProps {\n  const props = { ...propsWithoutDefaults };\n  for (const key of Object.keys(defaultProps) as (keyof TProps)[]) {\n    if (props[key] === undefined) {\n      props[key] = defaultProps[key]!;\n    }\n  }\n\n  return props;\n}\n", "/**\n * @deprecated Use `canUseDOM` from `@fluentui/utilities` instead.\n */\nexport let _isSSR = false;\n\n/**\n * Helper to set ssr mode to simulate no window object returned from getWindow helper.\n *\n * @deprecated Use `canUseDOM` from `@fluentui/utilities` instead.\n */\nexport function setSSR(isEnabled: boolean): void {\n  throw new Error(\n    'setSSR has been deprecated and is not used in any utilities anymore.' +\n      ' Use canUseDOM from @fluentui/utilities instead.',\n  );\n}\n", "import * as React from 'react';\nimport { arraysEqual } from './array';\n\n/**\n * Internal state type for the ref.\n */\ntype LocalState<TType, TValue> = {\n  refs: (React.Ref<TType | null | TValue> | undefined)[];\n  resolver?: (newValue: TType | TValue | null) => void;\n};\n\n/**\n * Set up a ref resolver function given internal state managed for the ref.\n * @param local Set\n */\nconst createResolver =\n  <TType, TValue>(local: LocalState<TType, TValue>) =>\n  (newValue: TType | TValue | null) => {\n    for (const ref of local.refs) {\n      if (typeof ref === 'function') {\n        ref(newValue);\n      } else if (ref) {\n        // work around the immutability of the React.Ref type\n        (ref as unknown as React.MutableRefObject<TType | TValue | null | undefined>).current = newValue;\n      }\n    }\n  };\n\n/**\n * Helper to merge refs from within class components.\n */\nexport const createMergedRef = <TType, TValue = null>(value?: TValue) => {\n  const local: LocalState<TType, TValue> = {\n    refs: [] as LocalState<TType, TValue>['refs'],\n  };\n\n  return (\n    ...newRefs: (React.Ref<TType | null | TValue> | undefined)[]\n  ): ((newValue: TType | TValue | null) => void) => {\n    if (!local.resolver || !arraysEqual(local.refs, newRefs)) {\n      local.resolver = createResolver<TType, TValue>(local);\n    }\n\n    local.refs = newRefs;\n\n    return local.resolver!;\n  };\n};\n", "import * as React from 'react';\nimport { canUseDOM } from './dom/canUseDOM';\n\n/**\n * React currently throws a warning when using `useLayoutEffect` on the server. To get around it,\n * this hook calls `useEffect` on the server (no-op) and `useLayoutEffect` in the browser.\n *\n * Prefer `useEffect` unless you have a specific need to do something after mount and before paint,\n * such as to avoid a render flash for certain operations.\n *\n * Server-side rendering is detected based on `canUseDOM` from `@fluentui/utilities`.\n *\n * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\n * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js\n */\n// eslint-disable-next-line no-restricted-properties\nexport const useIsomorphicLayoutEffect: typeof React.useEffect = canUseDOM() ? React.useLayoutEffect : React.useEffect;\n", "// Do not modify this file; it is generated as part of publish.\n// The checked in version is a placeholder only and will not be updated.\nimport { setVersion } from '@fluentui/set-version';\nsetVersion('@fluentui/utilities', '8.15.19');", "import { Async } from '@fluentui/utilities';\nimport * as React from 'react';\n\n/**\n * Hook to provide an Async instance that is automatically cleaned up on dismount.\n */\nexport function useAsync() {\n  const asyncRef = React.useRef<Async>();\n  if (!asyncRef.current) {\n    asyncRef.current = new Async();\n  }\n  React.useEffect(() => {\n    return () => {\n      asyncRef.current?.dispose();\n      asyncRef.current = undefined;\n    };\n  }, []);\n  return asyncRef.current;\n}\n", "import * as React from 'react';\nimport { useConst } from './useConst';\n\n/** Updater callbacks returned by `useBoolean`. */\nexport interface IUseBooleanCallbacks {\n  /** Set the value to true. Always has the same identity. */\n  setTrue: () => void;\n  /** Set the value to false. Always has the same identity. */\n  setFalse: () => void;\n  /** Toggle the value. Always has the same identity. */\n  toggle: () => void;\n}\n\n/**\n * Hook to store a value and generate callbacks for setting the value to true or false.\n * The identity of the callbacks will always stay the same.\n *\n * @param initialState - Initial value\n * @returns Array with the current value and an object containing the updater callbacks.\n */\nexport function useBoolean(initialState: boolean): [boolean, IUseBooleanCallbacks] {\n  const [value, setValue] = React.useState(initialState);\n\n  const setTrue = useConst(() => () => {\n    setValue(true);\n  });\n  const setFalse = useConst(() => () => {\n    setValue(false);\n  });\n  const toggle = useConst(() => () => {\n    setValue(currentValue => !currentValue);\n  });\n\n  return [value, { setTrue, setFalse, toggle }];\n}\n", "import * as React from 'react';\n\n/**\n * Hook to initialize and return a constant value. Unlike `React.useMemo`, this is guaranteed to\n * always return the same value (and if the initializer is a function, only call it once).\n * This is similar to setting a private member in a class constructor.\n *\n * If the value should ever change based on dependencies, use `React.useMemo` instead.\n *\n * @param initialValue - Initial value, or function to get the initial value. Similar to `useState`,\n * only the value/function passed in the first time this is called is respected.\n * @returns The value. The identity of this value will always be the same.\n */\nexport function useConst<T>(initialValue: T | (() => T)): T {\n  // Use useRef to store the value because it's the least expensive built-in hook that works here\n  // (we could also use `const [value] = React.useState(initialValue)` but that's more expensive\n  // internally due to reducer handling which we don't need)\n  const ref = React.useRef<{ value: T }>();\n  if (ref.current === undefined) {\n    // Box the value in an object so we can tell if it's initialized even if the initializer\n    // returns/is undefined\n    ref.current = {\n      value: typeof initialValue === 'function' ? (initialValue as Function)() : initialValue,\n    };\n  }\n  return ref.current.value;\n}\n", "import * as React from 'react';\n\n/**\n * @deprecated Deprecated due to potential for misuse. Generally, use `React.useCallback` instead.\n * If you need a callback reference that never changes, consider `useEventCallback`.\n *\n * This hook was intended for creating callbacks which have no dependencies, and therefore never\n * need to change. It works fine if everyone using it is extremely mindful of how closures work,\n * but that's not a safe assumption--so in practice, usage of this hook tends to result in bugs\n * like unintentionally capturing the first value of a prop and not respecting updates (when\n * updates should be respected).\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function useConstCallback<T extends (...args: any[]) => any>(callback: T): T {\n  const ref = React.useRef<T>();\n  if (!ref.current) {\n    ref.current = callback;\n  }\n  return ref.current;\n}\n", "import * as React from 'react';\nimport { useConst } from './useConst';\n\nexport type ChangeCallback<\n  TElement extends HTMLElement,\n  TValue,\n  TEvent extends React.SyntheticEvent<TElement> | undefined,\n> = (ev: TEvent, newValue: TValue | undefined) => void;\n\n/**\n * Hook to manage a value that could be either controlled or uncontrolled, such as a checked state or\n * text box string.\n * @param controlledValue - The controlled value passed in the props. This value will always be used if provided,\n * and the internal state will be updated to reflect it.\n * @param defaultUncontrolledValue - Initial value for the internal state in the uncontrolled case.\n * @returns An array of the current value and an updater callback. Like `React.useState`, the updater\n * callback always has the same identity, and it can take either a new value, or a function which\n * is passed the previous value and returns the new value.\n * @see https://reactjs.org/docs/uncontrolled-components.html\n */\nexport function useControllableValue<TValue, TElement extends HTMLElement>(\n  controlledValue: TValue | undefined,\n  defaultUncontrolledValue: TValue | undefined,\n): Readonly<[TValue | undefined, (update: React.SetStateAction<TValue | undefined>) => void]>;\nexport function useControllableValue<\n  TValue,\n  TElement extends HTMLElement,\n  TEvent extends React.SyntheticEvent<TElement> | undefined,\n>(\n  controlledValue: TValue | undefined,\n  defaultUncontrolledValue: TValue | undefined,\n  onChange: ChangeCallback<TElement, TValue, TEvent> | undefined,\n): Readonly<\n  [TValue | undefined, (update: React.SetStateAction<TValue | undefined>, ev?: React.FormEvent<TElement>) => void]\n>;\nexport function useControllableValue<\n  TValue,\n  TElement extends HTMLElement,\n  TEvent extends React.SyntheticEvent<TElement> | undefined,\n>(\n  controlledValue: TValue | undefined,\n  defaultUncontrolledValue: TValue | undefined,\n  onChange?: ChangeCallback<TElement, TValue, TEvent>,\n) {\n  const [value, setValue] = React.useState<TValue | undefined>(defaultUncontrolledValue);\n  const isControlled = useConst<boolean>(controlledValue !== undefined);\n  const currentValue = isControlled ? controlledValue : value;\n\n  // Duplicate the current value and onChange in refs so they're accessible from\n  // setValueOrCallOnChange without creating a new callback every time\n  const valueRef = React.useRef(currentValue);\n  const onChangeRef = React.useRef(onChange);\n  React.useEffect(() => {\n    valueRef.current = currentValue;\n    onChangeRef.current = onChange;\n  });\n\n  // To match the behavior of the setter returned by React.useState, this callback's identity\n  // should never change. This means it MUST NOT directly reference variables that can change.\n  const setValueOrCallOnChange = useConst(() => (update: React.SetStateAction<TValue | undefined>, ev?: TEvent) => {\n    // Assuming here that TValue is not a function, because a controllable value will typically\n    // be something a user can enter as input\n    const newValue = typeof update === 'function' ? (update as Function)(valueRef.current) : update;\n\n    if (onChangeRef.current) {\n      onChangeRef.current(ev!, newValue);\n    }\n\n    if (!isControlled) {\n      setValue(newValue);\n    }\n  });\n\n  return [currentValue, setValueOrCallOnChange] as const;\n}\n", "import * as React from 'react';\nimport { useConst } from './useConst';\nimport { useIsomorphicLayoutEffect } from '@fluentui/utilities';\n\n/**\n * Modified `useCallback` that returns the same function reference every time, but internally calls\n * the most-recently passed callback implementation. Can be useful in situations such as:\n * - Event handler dependencies change too frequently, such as user props which might change on\n *   every render, or volatile values such as useState/useDispatch\n * - Callback must be referenced in a captured context (such as a window event handler or unmount\n *   handler that's registered once) but needs access to the latest props\n *\n * In general, prefer `useCallback` unless you've encountered one of the problems above.\n *\n * https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\n *\n * @param fn - The callback function that will be used\n * @returns A function which is referentially stable but internally calls the most recently passed callback\n */\nexport function useEventCallback<Args extends unknown[], Return>(fn: (...args: Args) => Return) {\n  const callbackRef = React.useRef<typeof fn>(() => {\n    throw new Error('Cannot call an event handler while rendering');\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    callbackRef.current = fn;\n  }, [fn]);\n\n  // useConst rather than useCallback to ensure the reference is always stable\n  // (useCallback's deps list is an optimization, not a guarantee)\n  return useConst(() => (...args: Args) => {\n    const callback = callbackRef.current;\n    return callback(...args);\n  });\n}\n", "import * as React from 'react';\nimport { useConst } from './useConst';\n\n/**\n * Hook to force update a function component by updating a dummy state.\n */\nexport function useForceUpdate(): () => void {\n  const [, setValue] = React.useState(0);\n  const forceUpdate = useConst(() => () => setValue(value => ++value));\n  return forceUpdate;\n}\n", "import * as React from 'react';\nimport { getId } from '@fluentui/utilities';\n\n/**\n * Hook to generate a unique ID in the global scope (spanning across duplicate copies of the same library).\n *\n * @param prefix - Optional prefix for the ID\n * @param providedId - Optional id provided by a parent component. Defaults to the provided value if present,\n *  without conditioning the hook call\n * @returns The ID\n */\nexport function useId(prefix?: string, providedId?: string): string {\n  // getId should only be called once since it updates the global constant for the next ID value.\n  // (While an extra update isn't likely to cause problems in practice, it's better to avoid it.)\n  const ref = React.useRef<string | undefined>(providedId);\n  if (!ref.current) {\n    ref.current = getId(prefix);\n  }\n  return ref.current;\n}\n", "import * as React from 'react';\n\n/**\n * A Ref function which can be treated like a ref object in that it has an attached\n * current property, which will be updated as the ref is evaluated.\n */\nexport type RefObjectFunction<T> = React.RefObject<T> & ((value: T) => void);\n\n/**\n * React hook to merge multiple React refs (either MutableRefObjects or ref callbacks) into a single ref callback that\n * updates all provided refs\n * @param refs - Refs to collectively update with one ref value.\n * @returns A function with an attached \"current\" prop, so that it can be treated like a RefObject.\n */\nexport function useMergedRefs<T>(...refs: (React.Ref<T> | undefined)[]): RefObjectFunction<T> {\n  const mergedCallback: RefObjectFunction<T> = React.useCallback(\n    (value: T) => {\n      // Update the \"current\" prop hanging on the function.\n      (mergedCallback as unknown as React.MutableRefObject<T>).current = value;\n\n      for (const ref of refs) {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref) {\n          // work around the immutability of the React.Ref type\n          (ref as unknown as React.MutableRefObject<T>).current = value;\n        }\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- already exhaustive\n    [...refs],\n  ) as unknown as RefObjectFunction<T>;\n\n  return mergedCallback;\n}\n", "import * as React from 'react';\n\n/**\n * Hook which asynchronously executes a callback once the component has been mounted.\n *\n * @param callback - Function to call before mount.\n */\nexport const useMount = (callback: () => void) => {\n  const mountRef = React.useRef(callback);\n  mountRef.current = callback;\n  React.useEffect(() => {\n    mountRef.current?.();\n  }, []);\n};\n", "import * as React from 'react';\n\n/**\n * Hook which synchronously executes a callback once the component has been mounted.\n *\n * `WARNING` This should only be used if you need to perform an action after the component has been mounted and\n * before the browser paints. useMountSync will trigger debug warnings in server-rendered scenarios and should be used\n * sparingly.\n *\n * @deprecated Consider to use React.useEffect() or React.useLayoutEffect() directly based on a use case\n *\n * @param callback - Function to call once the component has been mounted.\n */\nexport const useMountSync = (callback: () => void) => {\n  const mountRef = React.useRef(callback);\n  mountRef.current = callback;\n  // eslint-disable-next-line no-restricted-properties\n  React.useLayoutEffect(() => {\n    mountRef.current?.();\n  }, []);\n};\n", "import { on } from '@fluentui/utilities';\nimport * as React from 'react';\n\n/**\n * Hook to attach an event handler on mount and handle cleanup.\n * @param element - Element (or ref to an element) to attach the event handler to\n * @param eventName - The event to attach a handler for\n * @param callback - The handler for the event\n * @param useCapture - Whether or not to attach the handler for the capture phase\n */\nexport function useOnEvent<TElement extends Element, TEvent extends Event>(\n  element: React.RefObject<TElement | undefined | null> | TElement | Window | Document | undefined | null,\n  eventName: string,\n  callback: (ev: TEvent) => void,\n  useCapture?: boolean,\n) {\n  // Use a ref for the callback to prevent repeatedly attaching/unattaching callbacks that are unstable across renders\n  const callbackRef = React.useRef(callback);\n  callbackRef.current = callback;\n\n  React.useEffect(() => {\n    const actualElement = element && 'current' in element ? element.current : element;\n    if (!actualElement || !actualElement.addEventListener) {\n      return;\n    }\n\n    const dispose = on(actualElement, eventName, (ev: TEvent) => callbackRef.current(ev), useCapture);\n    return dispose;\n  }, [element, eventName, useCapture]);\n}\n", "import { useRef, useEffect } from 'react';\n\n/**\n * Hook keeping track of a given value from a previous execution of the component the Hook is used in.\n *\n * See [React Hooks FAQ](https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state)\n */\nexport function usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T | undefined>();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n", "import * as React from 'react';\n\n/**\n * A callback ref function that also has a .current member for the ref's current value.\n */\nexport type RefCallback<T> = ((value: T | null) => void) & React.RefObject<T>;\n\n/**\n * Creates a ref, and calls a callback whenever the ref changes to a non-null value. The callback can optionally return\n * a cleanup function that'll be called before the value changes, and when the ref is unmounted.\n *\n * This can be used to work around a limitation that useEffect cannot depend on `ref.current` (see\n * https://github.com/facebook/react/issues/14387#issuecomment-503616820).\n *\n * Usage example:\n * ```ts\n * const myRef = useRefEffect<HTMLElement>(element => {\n *  ...\n *  return () => { ... cleanup ... };\n * });\n * ```\n * ```jsx\n * <div ref={myRef} />\n * ```\n *\n * @param callback - Called whenever the ref's value changes to non-null. Can optionally return a cleanup function.\n * @param initial - (Optional) The initial value for the ref.\n *\n * @returns A function that should be called to set the ref's value. The object also has a `.current` member that can be\n * used to access the ref's value (like a normal RefObject). It can be hooked up to an element's `ref` property.\n */\nexport function useRefEffect<T>(callback: (value: T) => (() => void) | void, initial: T | null = null): RefCallback<T> {\n  type RefData = {\n    ref: ((value: T | null) => void) & React.MutableRefObject<T | null>;\n    callback: (value: T) => (() => void) | void;\n    cleanup?: (() => void) | void;\n  };\n\n  const createRefCallback = () => {\n    const refCallback = (value: T | null) => {\n      if (data.ref.current !== value) {\n        if (data.cleanup) {\n          data.cleanup();\n          data.cleanup = undefined;\n        }\n\n        data.ref.current = value;\n\n        if (value !== null) {\n          data.cleanup = data.callback(value);\n        }\n      }\n    };\n\n    refCallback.current = initial;\n    return refCallback;\n  };\n\n  const data = React.useRef<RefData>({\n    ref: createRefCallback(),\n    callback,\n  }).current;\n\n  data.callback = callback;\n\n  return data.ref;\n}\n", "import * as React from 'react';\nimport { useConst } from './useConst';\n\nexport type UseSetIntervalReturnType = {\n  setInterval: (callback: () => void, duration: number) => number;\n  clearInterval: (id: number) => void;\n};\n\n/**\n *  Returns a wrapper function for `setInterval` which automatically handles disposal.\n */\nexport const useSetInterval = (): UseSetIntervalReturnType => {\n  const intervalIds = useConst<Record<number, number>>({});\n\n  React.useEffect(\n    () => () => {\n      for (const id of Object.keys(intervalIds)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        clearInterval(id as any);\n      }\n    },\n    // useConst ensures this will never change, but react-hooks/exhaustive-deps doesn't know that\n    [intervalIds],\n  );\n\n  return useConst({\n    setInterval: (func: () => void, duration: number): number => {\n      const id = setInterval(func, duration) as unknown as number;\n\n      intervalIds[id] = 1;\n\n      return id;\n    },\n\n    clearInterval: (id: number): void => {\n      delete intervalIds[id];\n      clearInterval(id);\n    },\n  });\n};\n", "import * as React from 'react';\nimport { useConst } from './useConst';\n\nexport type UseSetTimeoutReturnType = {\n  setTimeout: (callback: () => void, duration: number) => number;\n  clearTimeout: (id: number) => void;\n};\n\n/**\n *  Returns a wrapper function for `setTimeout` which automatically handles disposal.\n */\nexport const useSetTimeout = (): UseSetTimeoutReturnType => {\n  const timeoutIds = useConst<Record<number, number>>({});\n\n  // Cleanup function.\n  React.useEffect(\n    () => () => {\n      for (const id of Object.keys(timeoutIds)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        clearTimeout(id as any);\n      }\n    },\n    // useConst ensures this will never change, but react-hooks/exhaustive-deps doesn't know that\n    [timeoutIds],\n  );\n\n  // Return wrapper which will auto cleanup.\n  return useConst({\n    setTimeout: (func: () => void, duration: number): number => {\n      const id = setTimeout(func, duration) as unknown as number;\n\n      timeoutIds[id] = 1;\n\n      return id;\n    },\n\n    clearTimeout: (id: number): void => {\n      delete timeoutIds[id];\n      clearTimeout(id);\n    },\n  });\n};\n", "import { getDocument, Rectangle } from '@fluentui/utilities';\nimport * as React from 'react';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport type { Point } from '@fluentui/utilities';\n\nexport type Target = Element | string | MouseEvent | Point | Rectangle | null | React.RefObject<Element>;\n\n/**\n * Hook to calculate and cache the target element specified by the given target attribute,\n * as well as the target element's (or host element's) parent window\n * @param target- Target selector passed to the component as a property, describing the element that\n * the callout should target\n * @param hostElement- The callout's host element, used for determining the parent window.\n */\nexport function useTarget<TElement extends HTMLElement = HTMLElement>(\n  target: Target | undefined,\n  hostElement?: React.RefObject<TElement | null>,\n): Readonly<[React.RefObject<Element | MouseEvent | Point | Rectangle | null>, Window | undefined]> {\n  const previousTargetProp = React.useRef<\n    Element | string | MouseEvent | Point | Rectangle | React.RefObject<Element> | null | undefined\n  >();\n\n  const targetRef = React.useRef<Element | MouseEvent | Point | Rectangle | null>(null);\n  /**\n   * Stores an instance of Window, used to check\n   * for server side rendering and if focus was lost.\n   */\n  const targetWindow = useWindow();\n\n  // If the target element changed, find the new one. If we are tracking\n  // target with class name, always find element because we do not know if\n  // fabric has rendered a new element and disposed the old element.\n  if (!target || target !== previousTargetProp.current || typeof target === 'string') {\n    const currentElement = hostElement?.current;\n    if (target) {\n      if (typeof target === 'string') {\n        // If element is part of shadow dom, then querySelector on shadow root, else query on document\n        if ((currentElement?.getRootNode() as ShadowRoot)?.host) {\n          targetRef.current = (currentElement?.getRootNode() as ShadowRoot)?.querySelector(target) ?? null;\n        } else {\n          const currentDoc: Document = getDocument(currentElement)!;\n          targetRef.current = currentDoc ? currentDoc.querySelector(target) : null;\n        }\n      } else if ('stopPropagation' in target) {\n        targetRef.current = target;\n      } else if ('getBoundingClientRect' in target) {\n        targetRef.current = target;\n      } else if ('current' in target) {\n        targetRef.current = target.current;\n      } else {\n        targetRef.current = target;\n      }\n    }\n    previousTargetProp.current = target;\n  }\n\n  return [targetRef, targetWindow] as const;\n}\n", "import * as React from 'react';\n\n/**\n * Hook which synchronously executes a callback when the component is about to unmount.\n *\n * @param callback - Function to call during unmount.\n */\nexport const useUnmount = (callback: () => void) => {\n  const unmountRef = React.useRef(callback);\n  unmountRef.current = callback;\n  React.useEffect(\n    () => () => {\n      unmountRef.current?.();\n    },\n    [],\n  );\n};\n", "import * as React from 'react';\nimport {\n  warn,\n  warnControlledUsage,\n  warnConditionallyRequiredProps,\n  warnDeprecations,\n  warnMutuallyExclusive,\n} from '@fluentui/utilities';\nimport { usePrevious } from './usePrevious';\nimport { useConst } from './useConst';\nimport type { ISettingsMap, IWarnControlledUsageParams } from '@fluentui/utilities';\n\nexport interface IWarningOptions<P> {\n  /** Name of the component */\n  name: string;\n\n  /** Current component props */\n  props: P;\n\n  /** Generic messages */\n  other?: string[];\n\n  /** Warns when props are required if a condition is met */\n  conditionallyRequired?: {\n    /** Props required when the condition is met */\n    requiredProps: string[];\n    /** Name of the prop that the condition is based on */\n    conditionalPropName: string;\n    /** Whether the condition is met */\n    condition: boolean;\n  }[];\n\n  /**\n   * Warns when deprecated props are being used. Each key is a prop name and each value is\n   * either undefined or a replacement prop name.\n   */\n  deprecations?: ISettingsMap<P>;\n\n  /**\n   * Warns when two props which are mutually exclusive are both being used.\n   * The key is one prop name and the value is the other.\n   */\n  mutuallyExclusive?: ISettingsMap<P>;\n\n  /**\n   * Check for and warn on the following error conditions with a form component:\n   * - A value prop is provided (indicated it's being used as controlled) without a change handler,\n   *    and the component is not read-only\n   * - Both the value and defaultValue props are provided\n   * - The component is attempting to switch between controlled and uncontrolled\n   *\n   * The messages mimic the warnings React gives for these error conditions on input elements.\n   * The warning will only be displayed once per component instance.\n   */\n  controlledUsage?: Pick<\n    IWarnControlledUsageParams<P>,\n    'valueProp' | 'defaultValueProp' | 'onChangeProp' | 'readOnlyProp'\n  >;\n}\n\nlet warningId = 0;\n\n/**\n * Only in development mode, display console warnings when certain conditions are met.\n * Note that all warnings except `controlledUsage` will only be shown on first render\n * (new `controlledUsage` warnings may be shown later due to prop changes).\n */\nexport function useWarnings<P extends {}>(options: IWarningOptions<P>) {\n  if (process.env.NODE_ENV !== 'production') {\n    const {\n      name,\n      props,\n      other = [],\n      conditionallyRequired,\n      deprecations,\n      mutuallyExclusive,\n      controlledUsage,\n    } = options;\n\n    /* eslint-disable react-hooks/rules-of-hooks -- build-time conditional */\n    const hasWarnedRef = React.useRef(false);\n    const componentId = useConst(() => `useWarnings_${warningId++}`);\n    const oldProps = usePrevious(props);\n    /* eslint-enable react-hooks/rules-of-hooks */\n\n    // Warn synchronously (not in useEffect) on first render to make debugging easier.\n    if (!hasWarnedRef.current) {\n      hasWarnedRef.current = true;\n\n      for (const warning of other) {\n        warn(warning);\n      }\n\n      if (conditionallyRequired) {\n        for (const req of conditionallyRequired) {\n          warnConditionallyRequiredProps(name, props, req.requiredProps, req.conditionalPropName, req.condition);\n        }\n      }\n\n      deprecations && warnDeprecations(name, props, deprecations);\n\n      mutuallyExclusive && warnMutuallyExclusive(name, props, mutuallyExclusive);\n    }\n\n    // Controlled usage warnings may be displayed on either first or subsequent renders due to\n    // prop changes. Note that it's safe to run this synchronously (not in useEffect) even in\n    // concurrent mode because `warnControlledUsage` internally tracks which warnings have been\n    // displayed for each component instance (so nothing will be displayed twice).\n    controlledUsage && warnControlledUsage({ ...controlledUsage, componentId, props, componentName: name, oldProps });\n  }\n}\n"],
  "mappings": "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,GAAA;AACb,QAAM,OAAO,MAAM,QAAQ,IAAI,IAAI,OAAO,OAAO,KAAK,IAAI;AAE1D,aAAkB,KAAA,GAAA,SAAA,MAAA,KAAA,OAAA,QAAA,MAAM;AAAnB,UAAM,MAAG,OAAA,EAAA;AACZ,aAAO,GAAG,IAAI;;;AAIlB,SAAO;AACT;AAOO,IAAM,oBAAoB,YAAY;EAC3C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;CACD;AAOM,IAAM,wBAAwB,YAAY;EAC/C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;CACD;AAOM,IAAM,wBAAwB,YAAY,uBAAuB,iBAAiB;AAOlF,IAAM,kBAAkB,YAAY,uBAAuB;EAChE;;CACD;AAOM,IAAM,kBAAkB,YAAY,uBAAuB;EAChE;EACA;EACA;EACA;EACA;EACA;;CACD;AAOM,IAAM,kBAAkB,YAAY,iBAAiB;EAC1D;;CACD;AAOM,IAAM,eAAe,YAAY,uBAAuB;EAC7D;;CACD;AAOM,IAAM,eAAe,YAAY,uBAAuB;EAC7D;;CACD;AAOM,IAAM,mBAAmB,YAAY,uBAAuB;EACjE;EACA;EACA;EACA;EACA;EACA;EACA;;CACD;AAOM,IAAM,mBAAmB,YAAY,uBAAuB;EACjE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;CACD;AAOM,IAAM,kBAAkB,YAAY,kBAAkB;EAC3D;EACA;EACA;EACA;EACA;EACA;E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",
  "names": ["Async", "now", "_a", "_a", "_a", "_a", "_a", "EventGroup", "retVal", "e", "window", "stylesheet", "_i", "_a", "Stylesheet", "stylesheet", "rules", "_a", "rules", "_a", "stylesheet", "_a", "_a", "subCompProp", "_a", "_a", "stylesheet", "stylesheet", "rules", "_stylesheet", "_global", "_a", "stylesheet", "ShadowDomStylesheet", "window", "AutoScroll", "BaseComponent", "retVal", "React", "DelayedRender", "FabricPerformance", "GlobalSettings", "_a", "Rectangle", "_i", "getItem", "React", "Async", "_a", "Component", "_a", "getRTL", "setRTL", "getRTL", "_a", "React", "stylesheet", "_a", "Customizations", "_a", "React", "React", "_a", "Customizer", "React", "React", "React", "React", "React", "_a", "useAdoptedStylesheet", "_a", "useAdoptedStylesheetEx", "useMergeStylesRootStylesheets", "useWindow", "React", "_a", "_a", "React", "_a", "_global", "_initializedStylesheetResets", "stylesheet", "_a", "methodName", "_a", "_a", "window", "_a", "React", "React", "_onMouseDown", "_onPointerDown", "_onKeyDown", "_a", "getItem", "setItem", "getItem", "setItem", "_a", "_a", "_a", "_a", "SelectionMode", "SelectionDirection", "Selection", "_a", "_a", "values", "React", "React", "React", "React", "stylesheet", "_a", "React", "_a", "useAdoptedStylesheetEx", "useShadowConfig", "useMergeStylesShadowRootContext", "useMergeStylesRootStylesheets", "useWindow", "_a", "useAdoptedStylesheet", "useAdoptedStylesheetEx", "useShadowConfig", "useMergeStylesShadowRootContext", "useHasMergeStylesShadowRootContext", "useMergeStylesRootStylesheets", "useWindow", "useStyled", "Component", "customizable", "_a", "useStyled", "_a", "_a", "_a", "React", "React", "_a", "React", "React", "_a", "React", "React", "_a", "isControlled", "React", "React", "useForceUpdate", "_a", "React", "React", "_i", "React", "_a", "React", "_a", "React", "React", "React", "_a", "React", "_a", "React", "_a", "React", "_a", "React", "_a"]
}
